<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MySQL的行锁</title>
    <url>/2021/03/12/MySQL%E7%9A%84%E8%A1%8C%E9%94%81/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>自从过年值班就一直在公司读《 MySQL实战45讲》这本书，当时看完了MySQL的全局锁、表级锁还有行锁和间隙锁。其中的行锁和间隙锁迟迟无法理解，最近趁着有空再次阅读了一遍，并且对照了《深入浅出MySQL》，发现对MySQL锁的理解又上了一个台阶，今天就来分享一下MySQL的行锁。</p>
<a id="more"></a>
<h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h2><p>MySQL的行锁又分为共享锁（S锁）和排他锁（X锁）。</p>
<p><strong>一般普通的select语句，InnoDB不加任何锁，我们称之为快照读</strong></p>
<ul>
<li>select * from test;</li>
</ul>
<p><strong>通过加S锁和X锁的select语句或者插入/更新/删除操作，我们称之为当前读</strong></p>
<ul>
<li>select * from test lock in share mode;</li>
<li>select * from test for update;</li>
<li>insert into test values(…);</li>
<li>update test set …;</li>
<li>delete from test …;</li>
</ul>
<p>特殊说明：<strong>以上的当前读，读取的都是记录的最新版本。对读取记录都会加锁，除了第一条语句lock in share mode是对记录加S锁（共享锁）外，其他的操作都是加X锁（排他锁）</strong>。</p>
<h2 id="两阶段锁协议"><a href="#两阶段锁协议" class="headerlink" title="两阶段锁协议"></a>两阶段锁协议</h2><p>传统的关系型数据库加锁都要遵循一个原则：两阶段锁原则。</p>
<p>两阶段锁是将锁的操作分为两个阶段，加锁阶段和解锁阶段，并且保证加锁阶段和解锁阶段不相交。</p>
<p>分享一个例子说明两阶段锁协议：</p>
<table>
<thead>
<tr>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody>
<tr>
<td>begin;</td>
<td></td>
</tr>
<tr>
<td>update test set name=’god-jiang’ where id=1;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>begin;</td>
</tr>
<tr>
<td></td>
<td>delete from test where name=’god-jiang’;</td>
</tr>
<tr>
<td>commit;</td>
</tr>
</tbody>
</table>
<p>事务A执行完update语句后，手上持有着name=’god-jiang’的X锁，而事务B执行delete语句删除name=’god-jiang’记录的时候会阻塞，直到事务A执行commit之后，事务B才会执行delete。</p>
<p>也就是说，<strong>在InnoDB存储引擎中，行锁是在需要的时候加上的，但并不是不需要了就立刻释放行锁，而是要等到事务结束的时候才释放，这个就是两阶段锁协议。</strong></p>
<h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>不同事务隔离级别对应的行锁也是不同的，所以我们需要先了解事务的隔离级别后，再来演示不同隔离级别的行锁如何加上去。</p>
<p>MySQL的4种隔离级别：</p>
<ol>
<li>READ UNCOMMITTED（读未提交）：任何一个事务当中，都可以看见其他事务的执行情况，会出现脏读现象。</li>
<li>READ COMMITTED（读已提交，简称：RC）：在当前事务中只能看见已经提交事务的执行结果，当同一事务在读取期间出现新的commit操作，会出现不可重复读现象。</li>
<li>REPEATABLE READ（可重复读，简称：RR）：这是MySQL默认的隔离级别，得益于MVCC，它能在同一事务在多实例并发读取数据时看到相同的数据行，消除了脏读、不可重复读，默认不会出现幻读（<strong>MySQL的行锁+间隙锁解决了快照读的幻读，未解决当前读的幻读</strong>）。</li>
<li>SERIALIZABLE（串行）：MySQL的最高隔离级别，通过加锁，强制事务执行顺序，保证不会出现幻读问题。</li>
</ol>
<h2 id="加锁分析（以下默认是RC隔离级别并且都是当前读）"><a href="#加锁分析（以下默认是RC隔离级别并且都是当前读）" class="headerlink" title="加锁分析（以下默认是RC隔离级别并且都是当前读）"></a>加锁分析（以下默认是RC隔离级别并且都是当前读）</h2><p>这里我挑选出RC隔离级别下三种常见情况分析SQL如何加锁：</p>
<ul>
<li>RC隔离级别，where字段没有索引</li>
<li>RC隔离级别，where字段有唯一索引</li>
<li>RC隔离级别，where字段有普通索引</li>
</ul>
<p><strong>以下加锁分析默认表名为test，主键为id，唯一索引为a，普通索引为b，无索引为c。</strong></p>
<h2 id="RC隔离级别-where无索引"><a href="#RC隔离级别-where无索引" class="headerlink" title="RC隔离级别+where无索引"></a>RC隔离级别+where无索引</h2><p><img src="https://pic1.zhimg.com/80/v2-82ffcecc923231297d9db93d9f10a438_1440w.jpg" alt="img"></p>
<p>由于c字段没有索引，SQL将会进行全表扫描。这个时候的所有记录，都会加上X锁。</p>
<p><strong>为什么不是只在c=10的记录上加锁呢？</strong></p>
<p>这是因为在MySQL中，如果where条件不能通过索引快速过滤，那么在MySQL的server层就会将所有记录都加锁然后调用InnoDB存储引擎查询，因此也就把所有记录都锁上了。</p>
<p>总结：<strong>没有索引的情况下，InnoDB的当前读会对所有记录都加锁。所以在实际开发中，如果是当前读或者是插入/更新/删除等操作一定要使用索引，否则会产生大量的锁等待</strong>。</p>
<h2 id="RC隔离级别-where唯一索引"><a href="#RC隔离级别-where唯一索引" class="headerlink" title="RC隔离级别+where唯一索引"></a>RC隔离级别+where唯一索引</h2><p><img src="https://pic1.zhimg.com/80/v2-e69525e2366cd0b2b0ee784b63745e00_1440w.jpg" alt="img"></p>
<p>由于a字段有唯一索引，因此通过MySQL的server层会选择走a列的索引进行过滤，找到a=2记录后，将唯一索引上a=1的索引记录加上X锁，同时读取主键id并找到聚集索引树给id=2的记录加上X锁。</p>
<p>总结：<strong>如果查询的条件是唯一索引，那么SQL在满足的唯一索引的记录上加X锁，并且在对应的聚集索引上加X锁</strong>。</p>
<h2 id="RC隔离级别-where普通索引"><a href="#RC隔离级别-where普通索引" class="headerlink" title="RC隔离级别+where普通索引"></a>RC隔离级别+where普通索引</h2><p><img src="https://pic1.zhimg.com/80/v2-8caa6854f59724e0929c2429720d5dbc_1440w.jpg" alt="img"></p>
<p>由于b字段有普通索引，所以在满足b=2的所有记录上都加上了X锁，同时对应的聚集索引记录也加上了X锁。与唯一索引对比，唯一索引查询最多有一行记录上锁，而普通索引会把满足条件的所有记录上锁。</p>
<p>总结：<strong>如果查询的条件是普通索引，那么SQL会在满足条件的非唯一索引记录加上X锁，并且会在它们对应的聚集索引上加X锁</strong>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>InnoDB支持行锁，是替代MyISAM存储引擎的重要原因之一</li>
<li>分享了两阶段锁协议和MySQL的事务隔离级别</li>
<li>分析了RC隔离级别下常见的当前读加锁情况</li>
</ul>
<p><strong>最最重要的就是，在RC隔离级别下，我们更新数据，插入数据，删除数据都要尽可能走索引，不然会使所有的记录都被加上X锁，假如在线上操作的话，会严重影响业务</strong>。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>《MySQL实战45讲》林晓斌</li>
<li>《深入浅出MySQL》20.3.4 InnoDB行锁实现方式</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL锁</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL的全局锁和表级锁</title>
    <url>/2021/02/27/MySQL%E7%9A%84%E5%85%A8%E5%B1%80%E9%94%81%E5%92%8C%E8%A1%A8%E7%BA%A7%E9%94%81/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在真实的企业开发环境中使用MySQL，MySQL肯定不会只有我一个人使用，而是一个团队显式的使用MySQL，或者是业务隐式的使用MySQL，那么多个用户或者客户端连接使用的时候，我们应该考虑一个问题：<strong>如果保证数据并发访问的一致性呢</strong>？这一篇我就来聊聊MySQL的锁，不涉及MySQL的事务隔离级别。</p>
<a id="more"></a>
<h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><p>MySQL的全局锁会关闭所有打开的表，并使全部的表处于只读状态，它们的命令为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 全局锁，简称FTWRL</span></span><br><span class="line"><span class="keyword">FLUSH</span> <span class="keyword">TABLES</span> <span class="keyword">WITH</span> <span class="keyword">READ</span> <span class="keyword">LOCK</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解锁命令</span></span><br><span class="line"><span class="keyword">UNLOCK</span> <span class="keyword">TABLES</span>;</span><br></pre></td></tr></table></figure>
<p>对FTWRL进行实验：<strong>（以下的所有实验都是在MySQL8.0.22完成的）</strong></p>
<table>
<thead>
<tr>
<th>session1</th>
<th>session2</th>
</tr>
</thead>
<tbody>
<tr>
<td>FLUSH TABLES WITH READ LOCK;</td>
<td></td>
</tr>
<tr>
<td>select * from test limit 1; <br><strong>(正常返回结果)</strong></td>
<td></td>
</tr>
<tr>
<td></td>
<td>select * from test limit 1;<br> <strong>(正常返回结果)</strong></td>
</tr>
<tr>
<td>insert into test(a,b,c) values(6,6,6); <br><strong>(报错)</strong></td>
<td></td>
</tr>
<tr>
<td></td>
<td>insert into test(a,b,c) values(8,8,8);# sql1 <br><strong>(阻塞)</strong></td>
</tr>
<tr>
<td>UNLOCK TABLES;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>insert into test(a,b,c) values(8,8,8);# sql1 <br><strong>(session1解锁后，sql1立马执行成功)</strong></td>
</tr>
</tbody>
</table>
<p>从以上实验可以得出：<strong>当执行FTWRL后，所有的表变成了只读状态，其他更新的操作将会被阻塞。</strong></p>
<p>全局锁的主要作用就是做全库逻辑备份，也就是把数据库的每个表都select出来存成文本。</p>
<p>当备份过程中，整个数据库处于只读状态，风险也是及其的大。如果是在主库备份，将会导致所有的业务表都不能修改数据；如果是在从库备份，这个时候从库不能执行主库传过来的binlog，会导致主从延迟。</p>
<p>好在InnoDB存储引擎支持事务，mysqldump有一个参数single-transaction，可以在事务中创建一致性快照，然后进行所有表备份。在有这个参数下，备份期间可以进行数据修改，所以正常开发中建议使用InnoDB存储引擎。</p>
<h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><p>表级锁分为两种，一种是表锁，另一种是元数据锁。</p>
<h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><p>表锁分为表读锁和表写锁，在MySQL的命令是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 表读锁</span></span><br><span class="line"><span class="keyword">lock</span> <span class="keyword">tables</span> <span class="keyword">test</span> <span class="keyword">read</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 表写锁</span></span><br><span class="line"><span class="keyword">lock</span> <span class="keyword">tables</span> <span class="keyword">test</span> write;</span><br></pre></td></tr></table></figure>
<p>接下来通过实验看下表读锁和表写锁有什么区别吧</p>
<h4 id="表读锁"><a href="#表读锁" class="headerlink" title="表读锁"></a>表读锁</h4><table>
<thead>
<tr>
<th>session1</th>
<th>session2</th>
</tr>
</thead>
<tbody>
<tr>
<td>lock tables test read;</td>
<td></td>
</tr>
<tr>
<td>select * from test limit1; <br><strong>(正常返回结果)</strong></td>
<td></td>
</tr>
<tr>
<td></td>
<td>select * from test limit 1; <br><strong>(正常返回结果)</strong></td>
</tr>
<tr>
<td>insert into test(a,b,c) values(6,6,6); <br><strong>(报错)</strong></td>
<td></td>
</tr>
<tr>
<td></td>
<td>insert into test(a,b,c) values(8,8,8); # sql1 <br><strong>(阻塞)</strong></td>
</tr>
<tr>
<td>unlock tables;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>insert into test(a,b,c) values(8,8,8); # sql1 <br><strong>(session1解锁后，sql1立马写入成功)</strong></td>
</tr>
</tbody>
</table>
<p>在session1会话加上了表读锁，这个时候session1和session2都可以正常的读数据，但是session1写数据会报错，session2写数据会被阻塞，等到session1解锁了，session2的写数据才能执行成功。</p>
<p>从这个实验可以得出：<strong>表加上了表读锁之后，本线程和其他线程都可以读数据，本线程写数据会报错，其他线程写数据会阻塞。</strong></p>
<h4 id="表写锁"><a href="#表写锁" class="headerlink" title="表写锁"></a>表写锁</h4><table>
<thead>
<tr>
<th>session1</th>
<th>session2</th>
</tr>
</thead>
<tbody>
<tr>
<td>lock tables test write;</td>
<td></td>
</tr>
<tr>
<td>select * from test limi1; <br><strong>(正常返回结果)</strong></td>
<td></td>
</tr>
<tr>
<td></td>
<td>select * from test limit 1; # sql1 <br><strong>(阻塞)</strong></td>
</tr>
<tr>
<td>unlock tables;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>select * from test limit; # sql1 <br><strong>(session1解锁后，sql1立马返回结果)</strong></td>
</tr>
<tr>
<td>lock tables test write;</td>
<td></td>
</tr>
<tr>
<td>insert into test(a,b,c) values(6,6,6); <br><strong>(插入成功)</strong></td>
<td></td>
</tr>
<tr>
<td></td>
<td>insert into test(a,b,c) values(8,8,8);# sql 2 <br><strong>(阻塞)</strong></td>
</tr>
<tr>
<td>unlock tables;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>insert into test(a,b,c) values(8,8,8);# sql2 <br><strong>(session1解锁后，sql2立马执行成功)</strong></td>
</tr>
</tbody>
</table>
<p>从以上实验可以得出：<strong>表加上了表写锁之后，本线程可以进行读写操作，其他线程的读写操作都会被阻塞。</strong></p>
<h3 id="元数据锁（Metadata-Locking，简称：MDL锁）"><a href="#元数据锁（Metadata-Locking，简称：MDL锁）" class="headerlink" title="元数据锁（Metadata Locking，简称：MDL锁）"></a>元数据锁（Metadata Locking，简称：MDL锁）</h3><p>在MySQL中，数据库的DDL不属于事务范畴，如果你在session1中select一行数据，这个时候session2给这张表新增了一列xxx，这个时候可能会出现事务特性被破坏、binlog顺序错乱等bug（MySQL官网上有公布出类似的bug，感兴趣可以自行去了解）。</p>
<p>为了解决以上的问题，从MySQL5.5.3引入了元数据锁，MDL锁不需要显式使用，MySQL会默认加上，它的作用就是保证数据库读写正确性。以下全部用MDL表示元数据锁。</p>
<p>当你对一张表进行增删查改的时候会默认加上MDL读锁；当你对一张表进行表结构更改的时候会默认加上MDL写锁。</p>
<table>
<thead>
<tr>
<th>session1</th>
<th>session2</th>
<th>session3</th>
<th>session4</th>
</tr>
</thead>
<tbody>
<tr>
<td>begin; </td>
</tr>
</tbody>
</table>
<p>select <em> from test lmi1; <br><strong>(正常返回结果)</strong> |                                            |                                    |                                    |<br>|                                                | select </em> from test limit 1; <br><strong>(正常返回结果)</strong> |                                    |                                    |<br>|                                                |                                            | alter table test add d int;<br> <strong>(阻塞)</strong> |                                    |<br>|                                                |                                            |                                    | select * from test limit 1; <br><strong>(阻塞)</strong> |</p>
<p>一开始session1会话查询test的时候，获取到了MDL读锁，可以正常查询到数据。然后session2会话查询数据也会获取MDL读锁，不冲突，也可以正常查询到数据返回。</p>
<p>但是到了session3会话的时候，需要获取MDL写锁，这个时候因为session1的MDL读锁没有释放，所以会阻塞。后面session4也需要MDL读锁，但是因为session3被阻塞了，所以session4也会被阻塞。</p>
<p>假如这是一张线上业务表，这种场景将会使后面的任何操作都失效，表现出来就是这张表变得无法写和读。如果客户端配置了MySQL重试机制的话，会在超时的时候重新建立一个session会话重新请求，然后MySQL就会因为线程不停新增而崩溃。</p>
<p>从上面的例子可以知道<strong>MDL锁是在语句执行的时候默认加上的，但是语句执行完是不会释放的，只有等整个事务提交了才会释放MDL锁。</strong></p>
<p>所以对于我们开发者来说，在工作中应该尽量避免满查询、尽量保证事务及时提交、避免大事务等，对于DBA来说，也应该尽量避免在业务高峰期执行DDL操作。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>全局锁会让所有的表变成只读状态，所有更新操作都会被阻塞</li>
<li>表读锁是本线程和其他线程都可以读，本线程写会报错，其他线程写会阻塞</li>
<li>表写锁是本线程可以读写，其他线程读写都会阻塞</li>
<li>引入MDL锁解决事务和DDL同时执行引发的bug</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>《深入浅出MySQL》第二版：20.3.8 什么时候使用表锁</li>
<li>《MySQL实战45讲》林晓斌</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL锁</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL日志之redo log和binlog</title>
    <url>/2021/02/16/MySQL%E6%97%A5%E5%BF%97%E4%B9%8Bredo-log%E5%92%8Cbinlog/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>只要是接触过MySQL的程序员，那么或多或少都有听过redo log（重做日志）和binlog（归档日志）。今天就来分享一下这两个日志的用处和区别。</p>
<p>简单来说，redo log是InnoDB特有的日志，如果使用的是其他存储引擎，就没有redo log，只有binlog。</p>
<p>binlog是MySQL的Server层的日志，不管使用什么存储引擎，都会有binlog的存在。那么，为什么要有redo log和binlog呢？一个binlog不就可以全部解决了吗？接下来我们就来详细看一下redo log和binlog的区别吧。</p>
<a id="more"></a>
<h2 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h2><p>在MySQL中，如果你要更新一条语句，需要带更新条件，比如update T set name = ‘god-jiang’ where id=6，一般都是先查询到id=6的语句，然后再进行更新操作。</p>
<p>如果更新的数量是100条，1000条甚至10000条的时候，每一次更新都需要写到磁盘上。然后磁盘也要找到对应的记录，然后再更新，整个过程IO成本、查找成本太大，为了解决这个问题，MySQL的设计者采用了WAL技术来解决。WAL全称是Write Ahead Logging，意思就是先写日志，再写磁盘。</p>
<p>具体操作：当有一条记录需要更新的时候，InnoDB引擎会先把记录写到redo log中，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候（系统空闲时），将这个操作记录更新到磁盘中，这个更新往往是在系统比较空闲的时候。</p>
<p>但是redo log的大小是固定的，不可能一直无限写，让我们看下MySQL怎么做到的吧。</p>
<p><img src="https://pic2.zhimg.com/80/v2-7a95bcd27432082ce985744c7fd9585d_1440w.jpg" alt="img"></p>
<p>write pos是当前记录的位置，一边写一边往后移动。check point是当前要擦除的位置，也是往后移动并且循环的，擦除记录之前要把记录更新到数据文件中。</p>
<p>write pos与check point之间绿色的部分表示可以记录新的操作。如果write pos追上了check point，表示redo log满了，这个时候就不能继续执行新的操作，需要停下擦除一些记录，并且把check point往后推进。</p>
<p>有了redo log，InnoDB可以保证即使数据库发现异常重启了，也不会丢失之前提交的事务，这个能力也被称为crash-safe。</p>
<p>以上就是redo log的介绍，看完了之后，你可以试着去问一下你公司的DBA同事，MySQL是否可以恢复到半个月内任意一秒的状态，得到的答案肯定是可以的，这都要归功于redo log的功劳。</p>
<h2 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h2><p>从MySQL整体来看，其实分为两层，一层是Server层，一层是存储引擎层。上面聊到的redo log就是属于InnoDB引擎特有的日志，而binlog是属于Server层的日志，也称为归档日志。</p>
<p><strong>redo log和binlog的区别</strong></p>
<ul>
<li>redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用</li>
<li>redo log是物理日志，记录的是“在XXX数据页上做了XXX修改”；binlog是逻辑日志，记录的是原始逻辑，其记录是对应的SQL语句</li>
<li>redo log是循环写的，空间一定会用完，需要write pos和check point搭配；binlog是追加写，写到一定大小会切换到下一个，并不会覆盖以前的日志</li>
</ul>
<p><strong>通过简单的更新语句演示执行器和InnoDB引擎的内部流程</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> T <span class="keyword">set</span> <span class="keyword">name</span> = <span class="string">'god-jiang'</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">6</span></span><br></pre></td></tr></table></figure>
<ol>
<li>通过执行器从InnoDB引擎取出id=6的记录，然后加载到内存中</li>
<li>执行器拿到引擎返回的结果，把name修改为’god-jiang’，再重新调用存储引擎的接口写入新数据</li>
<li>引擎将新数据更新到内存中，同时将这个更新操作写到redo log中，此时redo log处于prepare状态</li>
<li>执行器生成这个操作的binlog，并把binlog写到磁盘中</li>
<li>执行器调用引擎提交事务的接口，并且把刚刚写入的redo log改为commit状态，更新完成</li>
</ol>
<p><strong>对应的流程图</strong></p>
<p><img src="https://pic4.zhimg.com/80/v2-dd93c8ffd44592f4e6befeca0833907b_1440w.jpg" alt="img"></p>
<p>最后为什么写入redo log会处于prepare状态，然后写入binlog还要变成commit状态？其实这个过程就叫做“两阶段提交”。</p>
<h2 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h2><p>其实redo log和binlog都可以用于表示事务的提交的状态，而两阶段提交就是让这两个状态保持逻辑上的一致。</p>
<p>举例子：update T set name = ‘god-jiang’ where id = 6没有两阶段提交会发生什么？</p>
<p>先写redo log后写binlog。假设写完了redo log，binlog还没有写完，这个时候MySQL异常重启。因为redo log写完了，恢复系统的时候name=’god-jiang’。但是binlog没有写完，所以binlog没有记录这条语句，这个时候用binlog恢复数据的时候，恢复出来的name就是原来值，与redo log不同。</p>
<p>同理可得，先写binlog后写redo log也会发现两个日志恢复的数据不同。这个不一致会导致线上出现主从不一致的情况。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>redo log可以保存crash-safe能力，可以保证MySQL异常重启数据不丢失</li>
<li>binlog可以记录对应的SQL语句，也可以保证MySQL异常重启数据不丢失</li>
<li>提交事务的两阶段提交，可以维持数据逻辑一致性</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>MySQL实战45讲</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL日志系统</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL的基础架构</title>
    <url>/2021/02/16/MySQL%E7%9A%84%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>临近春节，这段时间闲来无事又读了一些关于MySQL的文章和书籍，觉得受益良多。尤其是阿里巴巴丁奇的MySQL实战45讲，真的让我感觉到有质的提升。以前看书看博客都是优先看索引部分，优化部分。都是一些工作中常用的知识点。但现在我对MySQL的底层越来越好奇，所以从MySQL的基础架构开始学起，就有了这篇博客。</p>
<a id="more"></a>
<h2 id="MySQL逻辑结构"><a href="#MySQL逻辑结构" class="headerlink" title="MySQL逻辑结构"></a>MySQL逻辑结构</h2><p>大体来说，MySQL可以分为Server层和存储引擎层两部分。</p>
<p><img src="https://pic3.zhimg.com/80/v2-9b52412ef7874a3c9a31160ea9d662a2_1440w.jpg" alt="img"></p>
<p>Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能以及内置函数。</p>
<p>存储引擎层负责数据的存储和提取。它的架构模式是插件式，支持InnoDB、MyISAM、Memory等多个存储引擎。从MySQL5.5.5开始，MySQL的存储引擎默认是InnoDB。</p>
<h2 id="MySQL的执行流程和组件作用"><a href="#MySQL的执行流程和组件作用" class="headerlink" title="MySQL的执行流程和组件作用"></a>MySQL的执行流程和组件作用</h2><p>在执行这条查询语句的时候：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from T where id = 10;</span><br></pre></td></tr></table></figure>
<p>我们只知道输入一条SQL，返回一个结果，却不知道这条语句在MySQL内部的执行过程。</p>
<p>接下来我会通过这条简单的查询语句，走一遍MySQL的执行流程，看一下每个组件的作用。</p>
<h2 id="1、连接器"><a href="#1、连接器" class="headerlink" title="1、连接器"></a>1、连接器</h2><p>第一步，我们要先连接到这个数据库上，就先要面对连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接的作用。命令一般如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; mysql -u root -p</span><br></pre></td></tr></table></figure>
<p>输完以上命令，就要输入连接MySQL的密码。账号密码出错会受到一个“Access denied for user”的错误，需要重新连接。</p>
<p>mysql是客户端用来跟服务端建立连接的命令，在完成TCP握手后，连接器需要认证你的身份，这个时候就要输入账号和密码，完成连接。</p>
<p>连接完成后，如果没有后续的动作，这个连接就会处于空闲状态，一般太长时间没有动静，连接器会自动断开连接。这个时间由wait_timeout决定，默认时间为8个小时。</p>
<h2 id="2、查询缓存"><a href="#2、查询缓存" class="headerlink" title="2、查询缓存"></a>2、查询缓存</h2><p>客户端和服务端建立连接后，可以执行select语句，这个时候来到了Server层的查询缓存。</p>
<p>MySQL在接到select请求之后，会先去查询缓存看看之前是不是执行过这条语句。之前执行过语句及其结果会以key-value存放在内存中。key是查询的语句，value是查询的结果。如果你的查询在查询缓存中找到key，则直接返回查询缓存的value给客户端。</p>
<p>如果查询语句不在查询缓存中，就会继续后面的执行流程。执行完成后，执行结果会被存入查询缓存中。<strong>但是在MySQL实战45讲中，作者建议我们不要使用查询缓存，为什么呢？因为查询缓存往往利大于弊</strong>。</p>
<p>查询缓存的失效非常频繁，只要对一张表进行更新操作，这个表的所有查询缓存都会被清空。因此你建立起来的查询缓存还没有使用就被清空了。对于更新压力大的数据库，查询缓存的命中率更低。</p>
<p><strong>需要注意的是，从MySQL8.0开始，直接把整个查询缓存的功能删除掉，也就是说8.0开始没有查询缓存这个功能了</strong>。</p>
<h2 id="3、分析器"><a href="#3、分析器" class="headerlink" title="3、分析器"></a>3、分析器</h2><p>如果没有命中缓存，就要开始执行查询语句。首先MySQL对你的查询语句进行解析。</p>
<p>分析器会先做“词法分析”。分析你的SQL，把查询语句的“T”识别成“表名T”，把“id”识别成“列id”。</p>
<p>做完以上识别之后，MySQL开始做“语法分析”。根据语法规则判断你输入的SQL是否满足MySQL的语法。</p>
<p>如果你的查询语句写错了，就会收到“You hava an error in you SQL syntax”的错误提醒。比如你的查询语句打少了一个“t”。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; selec * from T where id = 10;</span><br><span class="line"></span><br><span class="line">&gt; 1064 - You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'selec * from T' at line 1</span><br></pre></td></tr></table></figure>
<p>一般语法错误会提示第一个出现错误的位置，所以你要关注”use near”后面的内容。</p>
<h2 id="4、优化器"><a href="#4、优化器" class="headerlink" title="4、优化器"></a>4、优化器</h2><p>经过了分析器，MySQL就知道了你要干什么了。在开始执行之前，还需要经过优化器的处理。</p>
<p>优化器是在表中有多个索引的时候，决定使用哪个索引；或者在一个SQL中有多张表联合查询的时候，决定各个表的执行顺序。比如你执行下面的语句：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from T1 inner join T2 on T1.id=T2.id where T1.b=10 and T2.c=20;</span><br></pre></td></tr></table></figure>
<ul>
<li>即可以从表T1取出b=10的记录值id，再根据id关联T2表，再判断T2的c等于20的记录</li>
<li>又可以从表T2取出c=20的记录值id，再根据id关联T1表，再判断T1的b等于10的记录</li>
</ul>
<p>这两个方法执行完的结果是一模一样的，但是执行效率会有所不同，而优化器的作用是决定选择使用哪一个方法。</p>
<p>MySQL数据库使用的是基于成本的优化器，估算成本为CPU代价+IO代价，最后决定执行哪种方案。想更深入理解优化器，推荐你们读《数据库查询优化器的艺术》。</p>
<h2 id="5、执行器"><a href="#5、执行器" class="headerlink" title="5、执行器"></a>5、执行器</h2><p>优化器阶段完成后，确定了执行方案后，就可以进入执行器阶段。开始执行语句的时候，会先判断你对这张表T有没有执行查询的权限。如果没有，就会返回没有权限的错误。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from T where id = 10;</span><br><span class="line"></span><br><span class="line">&gt; 1142 - SELECT command denied to user 'god-jiang@localhost' for table 'T'</span><br></pre></td></tr></table></figure>
<p>如果有权限，就继续执行查询操作。执行器会根据表的存储引擎去使用引擎对应的接口。</p>
<p><img src="https://pic3.zhimg.com/80/v2-9b52412ef7874a3c9a31160ea9d662a2_1440w.jpg" alt="img"></p>
<p>执行过程为：</p>
<ol>
<li>调用InnoDB引擎接口取表T的第一行，判断id值是否等于10，如果不是则跳过，如果是则存到结果集中。</li>
<li>调用引擎接口取下一行，重复以上的相同逻辑，直到取到表T的最后一行。</li>
<li>执行器将上面的遍历过程中所有满足id=10的行组成结果集全部返回给客户端。</li>
</ol>
<p>到这里，语句select * from T where id = 10就全部执行完成了。</p>
<h2 id="知识点串起来"><a href="#知识点串起来" class="headerlink" title="知识点串起来"></a>知识点串起来</h2><p>以上都是一个个组件的说明和讲解，现在我把他们串起来方便大家理解。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> T <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'god-jiang'</span>;</span><br></pre></td></tr></table></figure>
<p><strong>按照上面讲解的MySQL执行流程，这条语句的执行流程是这样的：</strong></p>
<ul>
<li>通过连接器检查当前账号是否有select这张表的权限，如果没有，就抛异常。</li>
<li>过了连接器，就到了分析器，一般SQL没有语法错误，就会继续往下走。</li>
<li>现在到了优化器，优化器会根据基于成本的优化器来决定执行哪种方案。</li>
<li>到了执行器，直接调用存储引擎的接口，然后返回结果给客户端即可。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天根据select * from T where id = 10过了一遍MySQL的执行过程和内部组件，可以让你对整个查询过程的各个阶段有个了解。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>MySQL实战45讲 - 林晓斌</li>
<li>《数据库查询优化器的艺术》</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>SQL如何执行</tag>
      </tags>
  </entry>
  <entry>
    <title>手撸一个SpringBoot-Starter</title>
    <url>/2021/02/01/%E6%89%8B%E6%92%B8%E4%B8%80%E4%B8%AASpringBoot-Starter/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>SpringBoot几乎是我们所有Java开发者必须掌握的一个技能，它为所有开发者更快的入门，做到开箱即用，没有冗余的代码和XML配置要求，对于开发者来说几乎是“零配置”。这个得益于SpringBoot的“约定大于配置”。</p>
<p>SpringBoot的starter帮我们把繁琐的配置和注册到IOC容器的过程都做了，我们只需要按照约定配置就可以开箱即用，实现零配置，下面我们就手撸一个spring-boot-starter来加深对“零配置”和“约定大于配置”的理解吧。</p>
<a id="more"></a>
<h2 id="spring-boot-starter介绍"><a href="#spring-boot-starter介绍" class="headerlink" title="spring-boot-starter介绍"></a><strong>spring-boot-starter介绍</strong></h2><p>SpringBoot提供了一个方便我们开发者开发的环境，它的底层就是使用了starter机制，能够抛弃以前繁琐的配置，统一集成为starter。</p>
<p>开发者只需要把starter引入到你的pom.xml中，SpringBoot就会自动扫描要加载的信息并启动相应的默认配置。SpringBoot会自动通过classpath路径下的类发现需要的Bean，并注册到IOC容器中。</p>
<p>所有这些依赖的模块都遵循着约定成俗的默认配置，并允许我们修改配置信息，这就是SpringBoot的“约定大于配置”的理念。</p>
<h2 id="手撸xxx-spring-boot-starter"><a href="#手撸xxx-spring-boot-starter" class="headerlink" title="手撸xxx-spring-boot-starter"></a>手撸xxx-spring-boot-starter</h2><p>新建一个json-template-spring-boot-starter的SpringBoot项目，并引入fastjson依赖。</p>
<p><img src="https://pic3.zhimg.com/80/v2-27d567f46c041d8576cc0c660071a37a_1440w.jpg" alt="img"></p>
<p>接着创建一个JsonTemplate，调用fastjson把一个对象转换为json字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> god.jiang.jsontemplatespringbootstarter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonTemplate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String text;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">objToJsonString</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getName() + <span class="keyword">this</span>.getText() + JSONObject.toJSONString(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着创建spring-boot-starter的配置类（约定大于配置）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> god.jiang.jsontemplatespringbootstarter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"god.jiang.json"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name = <span class="string">"god-jiang-json"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String text = <span class="string">"自定义spring-boot-starter把对象转换成json"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getText</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> text;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setText</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.text = text;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着创建自动配置类，让springboot自动扫描并且注入到IOC容器中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> god.jiang.jsontemplatespringbootstarter;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnClass;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.EnableConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123;JsonTemplate.class&#125;)</span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(JsonProperties.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonTemplateAutoConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JsonProperties jsonProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span>(JsonTemplate.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> JsonTemplate <span class="title">jsonTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        JsonTemplate jsonTemplate = <span class="keyword">new</span> JsonTemplate();</span><br><span class="line">        jsonTemplate.setName(jsonProperties.getName());</span><br><span class="line">        jsonTemplate.setText(jsonProperties.getText());</span><br><span class="line">        <span class="keyword">return</span> jsonTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面做完了，最关键的一步把自动配置的类写在resource/META-INF/spring.factories文件中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=god.jiang.jsontemplatespringbootstarter.JsonTemplateAutoConfiguration</span><br></pre></td></tr></table></figure>
<p>然后用maven命令install和deploy到远程仓库，方便以后项目可以调用该starter。</p>
<p><img src="https://pic3.zhimg.com/80/v2-230c762440fffe4b7f1cb4ce93ab4f8e_1440w.jpg" alt="img"></p>
<h2 id="使用我们上面所创建的spring-boot-starter"><a href="#使用我们上面所创建的spring-boot-starter" class="headerlink" title="使用我们上面所创建的spring-boot-starter"></a>使用我们上面所创建的spring-boot-starter</h2><p>创建一个新的SpringBoot项目，在pom.xml中引入上面编写的json-templatespring-boot-starter</p>
<p><img src="https://pic4.zhimg.com/80/v2-c9831b5d11a82efa8f9f1467f360389b_1440w.jpg" alt="img"></p>
<p>接着创建一个controller调用json-template-spring-boot-starter的objToJsonString方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> god.jiang.teststarter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> god.jiang.jsontemplatespringbootstarter.JsonTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JsonTemplate jsonTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/toJson"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toJson</span><span class="params">()</span></span>&#123;</span><br><span class="line">        GodJiang godJiang = <span class="keyword">new</span> GodJiang();</span><br><span class="line">        godJiang.setName(<span class="string">"god-jiang"</span>);</span><br><span class="line">        godJiang.setAge(<span class="number">18</span>);</span><br><span class="line">        godJiang.setText(<span class="string">"自定义一个spring-boot-starter"</span>);</span><br><span class="line">        <span class="keyword">return</span> jsonTemplate.objToString(godJiang);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照约定配置application.properties</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">god.jiang.json.name=god-jiang</span><br><span class="line">god.jiang.json.text=-study-spring-boot-starter</span><br></pre></td></tr></table></figure>
<p>启动项目运行访问localhost:8080/toJson</p>
<p><img src="https://pic3.zhimg.com/80/v2-8bd002c8ff6ad066bcd8fb66649e91fe_1440w.jpg" alt="img"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是手写一个spring-boot-starter的过程，实际上读完springboot的自动加载源码我就大概知道整个加载的过程，这次接着手写starter来实现整个过程，让我对springboot源码有了更深的理解，希望以上的分享对你们有所帮助～～～</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>spring-boot-starter</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring自带的线程池ThreadPoolTaskExecutor</title>
    <url>/2021/01/24/Spring%E8%87%AA%E5%B8%A6%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0ThreadPoolTaskExecutor/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇分享了JDK自带的线程池ThreadPoolTaskExecutor的配置和参数详解，然而我们实际开发中更多的是使用SpringBoot来开发，Spring默认也是自带了一个线程池方便我们开发，它就是ThreadPoolTaskExecutor，接下来我们就来聊聊Spring的线程池吧。</p>
<a id="more"></a>
<h2 id="Spring默认线程池simpleAsyncTaskExecutor"><a href="#Spring默认线程池simpleAsyncTaskExecutor" class="headerlink" title="Spring默认线程池simpleAsyncTaskExecutor"></a>Spring默认线程池simpleAsyncTaskExecutor</h2><p>Spring异步线程池的接口类是TaskExecutor，本质还是java.util.concurrent.Executor，没有配置的情况下，默认使用的是simpleAsyncTaskExecutor。</p>
<p><strong>@Async演示Spring默认的simpleAsyncTaskExecutor</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduleTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="meta">@Scheduled</span>(fixedRate = <span class="number">2000</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testScheduleTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">            System.out.println(<span class="string">"Spring1自带的线程池"</span> + Thread.currentThread().getName() + <span class="string">"-"</span> + sdf.format(<span class="keyword">new</span> Date()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="meta">@Scheduled</span>(cron = <span class="string">"*/2 * * * * ?"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAsyn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">"Spring2自带的线程池"</span> + Thread.currentThread().getName() + <span class="string">"-"</span> + sdf.format(<span class="keyword">new</span> Date()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic4.zhimg.com/80/v2-6e0f0419b976ed6c3025b91f780a7ce7_1440w.jpg" alt="img"></p>
<p>从运行结果可以看出Spring默认的@Async用线程池名字为SimpleAsyncTaskExecutor，而且每次都会重新创建一个新的线程，所以可以看到TaskExecutor-后面带的数字会一直变大。</p>
<p>simpleAsyncTaskExecutor的特点是，每次执行任务时，它会重新启动一个新的线程，并允许开发者控制并发线程的最大数量（concurrencyLimit），从而起到一定的资源节流作用。默认是concurrencyLimit取值为-1，即不启用资源节流。</p>
<h2 id="Spring的线程池ThreadPoolTaskExecutor"><a href="#Spring的线程池ThreadPoolTaskExecutor" class="headerlink" title="Spring的线程池ThreadPoolTaskExecutor"></a>Spring的线程池ThreadPoolTaskExecutor</h2><p>上面介绍了Spring默认的线程池simpleAsyncTaskExecutor，但是Spring更加推荐我们开发者使用ThreadPoolTaskExecutor类来创建线程池，其本质是对java.util.concurrent.ThreadPoolExecutor的包装。</p>
<p>这个类则是spring包下的，是Spring为我们开发者提供的线程池类，这里重点讲解这个类的用法。</p>
<p>Spring提供了xml给我们配置ThreadPoolTaskExecutor线程池，但是现在普遍都在用SpringBoot开发项目，所以直接上yaml或者properties配置即可，或者也可以使用@Configuration配置也行，下面演示配置和使用。</p>
<h2 id="ThreadPoolTaskExecutor配置"><a href="#ThreadPoolTaskExecutor配置" class="headerlink" title="ThreadPoolTaskExecutor配置"></a>ThreadPoolTaskExecutor配置</h2><p>application.properties</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 核心线程池数</span><br><span class="line">spring.task.execution.pool.core-size=<span class="number">5</span></span><br><span class="line"># 最大线程池数</span><br><span class="line">spring.task.execution.pool.max-size=<span class="number">10</span></span><br><span class="line"># 任务队列的容量</span><br><span class="line">spring.task.execution.pool.queue-capacity=<span class="number">5</span></span><br><span class="line"># 非核心线程的存活时间</span><br><span class="line">spring.task.execution.pool.keep-alive=<span class="number">60</span></span><br><span class="line"># 线程池的前缀名称</span><br><span class="line">spring.task.execution.thread-name-prefix=god-jiang-task-</span><br></pre></td></tr></table></figure>
<p>AsyncScheduledTaskConfig.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncScheduledTaskConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.task.execution.pool.core-size&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> corePoolSize;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.task.execution.pool.max-size&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxPoolSize;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.task.execution.pool.queue-capacity&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> queueCapacity;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.task.execution.thread-name-prefix&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String namePrefix;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.task.execution.pool.keep-alive&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> keepAliveSeconds;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">myAsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadPoolTaskExecutor executor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">        <span class="comment">//最大线程数</span></span><br><span class="line">        executor.setMaxPoolSize(maxPoolSize);</span><br><span class="line">        <span class="comment">//核心线程数</span></span><br><span class="line">        executor.setCorePoolSize(corePoolSize);</span><br><span class="line">        <span class="comment">//任务队列的大小</span></span><br><span class="line">        executor.setQueueCapacity(queueCapacity);</span><br><span class="line">        <span class="comment">//线程前缀名</span></span><br><span class="line">        executor.setThreadNamePrefix(namePrefix);</span><br><span class="line">        <span class="comment">//线程存活时间</span></span><br><span class="line">        executor.setKeepAliveSeconds(keepAliveSeconds);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 拒绝处理策略</span></span><br><span class="line"><span class="comment">         * CallerRunsPolicy()：交由调用方线程运行，比如 main 线程。</span></span><br><span class="line"><span class="comment">         * AbortPolicy()：直接抛出异常。</span></span><br><span class="line"><span class="comment">         * DiscardPolicy()：直接丢弃。</span></span><br><span class="line"><span class="comment">         * DiscardOldestPolicy()：丢弃队列中最老的任务。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">        <span class="comment">//线程初始化</span></span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在方法上添加@Async注解，然后还需要在@SpringBootApplication启动类或者@Configuration注解类上 添加注解@EnableAsync启动多线程注解，@Async就会对标注的方法开启异步多线程调用，注意，这个方法的类一定要交给Spring容器来管理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduleTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span>(<span class="string">"myAsync"</span>)</span><br><span class="line">    <span class="meta">@Scheduled</span>(fixedRate = <span class="number">2000</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testScheduleTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">            System.out.println(<span class="string">"Spring1自带的线程池"</span> + Thread.currentThread().getName() + <span class="string">"-"</span> + sdf.format(<span class="keyword">new</span> Date()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span>(<span class="string">"myAsync"</span>)</span><br><span class="line">    <span class="meta">@Scheduled</span>(cron = <span class="string">"*/2 * * * * ?"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAsyn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">"Spring2自带的线程池"</span> + Thread.currentThread().getName() + <span class="string">"-"</span> + sdf.format(<span class="keyword">new</span> Date()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic4.zhimg.com/80/v2-7e672516479a8049943261dcd4fa6bf7_1440w.jpg" alt="img"></p>
<p>以上从运行结果可以看出，自定义ThreadPoolTaskExecutor可以实现线程的复用，而且还能控制好线程数，写出更好的多线程并发程序。</p>
<p><strong>另外需要注意的是：关于注解失效需要注意以下几点</strong></p>
<ol>
<li>注解的方法必须是public方法</li>
<li>方法一定要从另一个类中调用，也就是从类的外部调用，类的内部调用是无效的，因为@Transactional和@Async注解的实现都是基于Spring的AOP，而AOP的实现是基于动态代理模式实现的。那么注解失效的原因就很明显了，有可能因为调用方法的是对象本身而不是代理对象，因为没有经过Spring容器。</li>
<li>异步方法使用注解@Async的返回值只能为void或者Future</li>
</ol>
<p><strong>上面注解中已经注释了参数的详解，这里重点讲解一下Spring线程池的拒绝策略和处理流程。</strong></p>
<h2 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a><strong>拒绝策略</strong></h2><p><strong>rejectedExectutionHandler参数字段用于配置绝策略，常用拒绝策略如下</strong></p>
<ul>
<li>AbortPolicy：用于被拒绝任务的处理程序，它将抛出RejectedExecutionException</li>
<li>CallerRunsPolicy：用于被拒绝任务的处理程序，它直接在execute方法的调用线程中运行被拒绝的任务。</li>
<li>DiscardOldestPolicy：用于被拒绝任务的处理程序，它放弃最旧的未处理请求，然后重试execute。</li>
<li>DiscardPolicy：用于被拒绝任务的处理程序，默认情况下它将丢弃被拒绝的任务。</li>
</ul>
<h2 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h2><ol>
<li>查看核心线程池是否已满，不满就创建一条线程执行任务，否则执行第二步。</li>
<li>查看任务队列是否已满，不满就将任务存储在任务队列中，否则执行第三步。</li>
<li>查看线程池是否已满，即就是是否达到最大线程池数，不满就创建一条线程执行任务，否则就按照策略处理无法执行的任务。</li>
</ol>
<p><img src="https://pic1.zhimg.com/80/v2-11da400eea7f7bd30b95b9b344258cec_1440w.jpg" alt="img"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次分享了Spring自带的线程池ThreadPoolTaskExecutor的配置和使用，并且讲了线程池的参数和处理流程。当然Spring提供了7个线程池的实现，感兴趣的可以自行了解～～～</p>
<p>希望以上的分享对你们有所帮助，喜欢的点个赞支持一下我吧～～～</p>
]]></content>
      <categories>
        <category>线程池</category>
      </categories>
      <tags>
        <tag>spring线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK线程池之ThreadPoolExecutor</title>
    <url>/2021/01/20/JDK%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B9%8BThreadPoolExecutor/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在真实的企业开发过程中，有时候我们需要通过并行计算提高程序执行的性能，或者是遇到等待网络、IO响应导致耗费大量的执行时间，这些情况下我们可以通过采用异步多线程的方式来减少阻塞。这个时候我们就要学习多线程并发来实现这些业务场景。</p>
<a id="more"></a>
<h2 id="使用线程池的好处"><a href="#使用线程池的好处" class="headerlink" title="使用线程池的好处"></a>使用线程池的好处</h2><ol>
<li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗</li>
<li>提高响应速度。当任务到达时，可以不需要等待线程的创建就能立刻执行</li>
<li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以统一分配、调优和监控。</li>
</ol>
<h2 id="JDK默认Executors提供四种线程池"><a href="#JDK默认Executors提供四种线程池" class="headerlink" title="JDK默认Executors提供四种线程池"></a><strong>JDK默认Executors提供四种线程池</strong></h2><ol>
<li>newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则创建线程</li>
<li>newFixedThreadPool创建一个定长的线程池，可控制线程最大并发数，超出的线程会在队列中等待</li>
<li>newSingleThreadExecutor创建一个单线程化的线程池，只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序进行</li>
<li>newScheduledThreadPool创建一个定长线程池，支持定时及周期性任务执行</li>
</ol>
<p>虽然以上是JDK提供给我们方便使用的线程池，但是阿里巴巴开发规范不推荐我们使用Executors创建线程池。感兴趣的可以去看看它们的源码，这里就不多赘述了。</p>
<p><img src="https://pic3.zhimg.com/80/v2-111bdd076366a8ab42a40175b161003e_1440w.jpg" alt="img"></p>
<p>相信看过Executors提供的四种线程池的源码就会发现，它们提供的任务队列允许的最大长度是Integer的最大值，很容易引发Out Of Memory，所以不推荐使用默认的。</p>
<h2 id="那么我们要怎么样创建线程池呢？"><a href="#那么我们要怎么样创建线程池呢？" class="headerlink" title="那么我们要怎么样创建线程池呢？"></a>那么我们要怎么样创建线程池呢？</h2><p>看过Executors的源码就知道，其实JDK提供四种默认线程池都是用ThreadPoolExecutor的构造函数来实现的，所以我们自己实现也可以。</p>
<p>直接上源码分析一下线程池的参数。ThreadPoolExecutor有四个构造函数，其实我们只需要弄懂7个参数的构造函数就可以了（其他三种都是直接用7个参数的构造函数），让我们来看看它的构造函数吧。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">            <span class="keyword">null</span> :</span><br><span class="line">            AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>corePoolSize：核心线程数，初始创建的线程都是核心线程数，线程池中正常情况下始终保留该大小的线程实例存活</li>
<li>maximumPoolSize：最大线程数，当核心线程都在执行任务，任务队列满的情况下会创建非核心线程来执行任务，当非核心线程处于空闲时间，且超过keepAliveTime时，会销毁非核心线程</li>
<li>keepAliveTime：存活时间，用于控制非核心线程的空闲时存活时间</li>
<li>unit：存活时间的单位。具体是TimeUnit枚举，有毫秒、秒、分钟、小时等等</li>
<li>workQueue：线程池的任务队列，当线程池的核心线程都处于繁忙状态，且有新任务到来，则会进入任务队列，当任务队列满了，则会创建非核心线程执行新任务</li>
<li>threadFactory：线程池创建线程实例的线程工厂，一般默认为Executors.defaultThreadFactory</li>
<li>handler：线程池拒绝策略，当核心线程全部繁忙，任务队列已满，非核心线程全部繁忙，会触发线程池拒绝策略。默认为AbortPolicy，直接抛出异常并且拒绝。剩下还有其他三种拒绝策略可以自行去了解</li>
</ol>
<h2 id="线程池使用"><a href="#线程池使用" class="headerlink" title="线程池使用"></a>线程池使用</h2><p>我们现在知道了根据ThreadPoolExecutor自定义一个线程池，之后我们就需要用这个线程池来实现多线程并发编程，以下用execute和submit来演示一遍。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadPoolExecutor</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//使用jdk自带的ThreadPoolExecutor创建线程池</span></span><br><span class="line">        ExecutorService executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>, <span class="number">60</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">        <span class="comment">//用execute执行，无返回结果</span></span><br><span class="line">        executor.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"-"</span> + <span class="string">"god-jiang用线程池实现并发编程"</span> + <span class="string">"-"</span> + i);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"异常处理"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//用submit执行，带返回结果</span></span><br><span class="line">        Future&lt;?&gt; submit = executor.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">66</span>; i &lt; <span class="number">69</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"-"</span> + <span class="string">"god-jiang用线程池实现并发编程"</span> + <span class="string">"-"</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(submit);</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>执行完的结果</strong></p>
<p><img src="https://pic1.zhimg.com/80/v2-a8e0a48c2d722f5eccdd992ef853f7a4_1440w.jpg" alt="img"></p>
<p>可以看到是两个不同的线程在跑任务，这就是使用JDK的ThreadPoolExecutor自定义的线程池来执行任务</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>虽然使用Executors创建线程池非常方便，但是还是推荐大家少用，因为很多次生产事故都是因为Executors默认的线程池提交任务导致的</li>
<li>创建线程池必须知道每个参数的作用并且根据所负责的业务场景来实现线程池</li>
<li>请尽量使用线程池替代new Thread().start()</li>
</ul>
<p>希望以上的分享对那些正在学习线程池的程序猿有所帮助~~~</p>
]]></content>
      <categories>
        <category>Java进阶</category>
      </categories>
      <tags>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot定时任务+自定义线程池</title>
    <url>/2021/01/20/SpringBoot%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在真实的Java开发环境中，我们经常会需要用到定时任务来帮助我们完成一些特殊的任务，比如我最近写的晚上11点定时拉取第三方的数据入库，晚上12点清理脏数据等等。</p>
<p>如果我们使用SpringBoot来开发，那么定时任务将会变得非常简单。SpringBoot默认已经帮我们封装好了相关定时任务的组件和配置，我们只需要在相应的地方加上@Schedule注解就可以实现定时任务。</p>
<a id="more"></a>
<h2 id="启动定时任务"><a href="#启动定时任务" class="headerlink" title="启动定时任务"></a>启动定时任务</h2><p>SpringBoot项目只需要在启动类上加上@EnableScheduling即可开启定时任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduleTestApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ScheduleTestApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建定时任务"><a href="#创建定时任务" class="headerlink" title="创建定时任务"></a>创建定时任务</h2><p>SpringBoot的Scheduler支持四种定时任务格式</p>
<ul>
<li><strong>fixedRate</strong>：固定速率执行，例如每3秒执行一次</li>
<li><strong>fixedDelay</strong>：固定延迟执行，例如距离上一次调用成功后3秒执行</li>
<li><strong>initialDelay</strong>：初始延迟任务，例如任务开启过3秒后再执行，之后以固定频率或者间隔执行</li>
<li><strong>cron</strong>：使用 Cron 表达式执行定时任务</li>
</ul>
<p>以上在企业开发中经常用到的是cron表达式，可以说掌握了cron表达式，基本就掌握了SpringBoot的定时任务了。</p>
<h2 id="使用cron表达式"><a href="#使用cron表达式" class="headerlink" title="使用cron表达式"></a>使用cron表达式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduleTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每隔5秒执行一次该方法</span></span><br><span class="line">    <span class="meta">@Scheduled</span>(cron = <span class="string">"*/5 * * * * ?"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testScheduleTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SpringBoot的定时任务"</span> + Thread.currentThread().getName() + sdf.format(<span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-1b5a449d73ff25b2f72be3efcd93ce16_1440w.jpg" alt="img"></p>
<h2 id="Schedule默认线程池大小"><a href="#Schedule默认线程池大小" class="headerlink" title="@Schedule默认线程池大小"></a>@Schedule默认线程池大小</h2><p>其实@Schedule默认线程池大小为1，我们可以实验得出这个结论。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduleTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//固定2秒执行一次该方法</span></span><br><span class="line">    <span class="meta">@Scheduled</span>(fixedRate = <span class="number">2000</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testScheduleTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">            System.out.println(<span class="string">"SpringBoot的定时任务"</span> + Thread.currentThread().getName() + sdf.format(<span class="keyword">new</span> Date()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/80/v2-19315abae84406b542a8f42a47317198_1440w.jpg" alt="img"></p>
<p>结果每隔6秒执行一次，可以看到线程的名字为scheduleing-12021-01-12，表示都是用的同一个线程，默认@Schedule是开启一个线程。</p>
<p>一般情况下使用默认@Schedule没有问题，但是如果有多个定时任务，每个定时任务执行时间可能不短的情况下，会有可能出现定时任务一直没有机会执行的情况。</p>
<h2 id="异步执行定时任务"><a href="#异步执行定时任务" class="headerlink" title="异步执行定时任务"></a>异步执行定时任务</h2><p>给该方法加上@Async进行异步处理，看看会是什么效果～</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduleTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="meta">@Scheduled</span>(fixedRate = <span class="number">2000</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testScheduleTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">            System.out.println(<span class="string">"SpringBoot的定时任务"</span> + Thread.currentThread().getName() + sdf.format(<span class="keyword">new</span> Date()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/80/v2-bb432aa7a5da5c5c89b5855a128cfd9c_1440w.jpg" alt="img"></p>
<p>可以看出线程的名字都是不一样的，然后每隔2秒的执行一次该方法，异步处理不受方法内的时间影响，并行执行。</p>
<h2 id="手动实现自定义任务线程池"><a href="#手动实现自定义任务线程池" class="headerlink" title="手动实现自定义任务线程池"></a>手动实现自定义任务线程池</h2><p>虽然可以用SpringBoot提供给我们的异步注解@Async处理，但是我们开发者也可以手动实现一个线程池，更好的配置和使用我们的异步处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncScheduledTaskConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">myAsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadPoolTaskExecutor executor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">        <span class="comment">//最大线程数</span></span><br><span class="line">        executor.setMaxPoolSize(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">//核心线程数</span></span><br><span class="line">        executor.setCorePoolSize(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//任务队列的大小</span></span><br><span class="line">        executor.setQueueCapacity(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//线程前缀名</span></span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">"god-jiang-"</span>);</span><br><span class="line">        <span class="comment">//线程存活时间</span></span><br><span class="line">        executor.setKeepAliveSeconds(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 拒绝处理策略</span></span><br><span class="line"><span class="comment">         * CallerRunsPolicy()：交由调用方线程运行，比如 main 线程。</span></span><br><span class="line"><span class="comment">         * AbortPolicy()：直接抛出异常。</span></span><br><span class="line"><span class="comment">         * DiscardPolicy()：直接丢弃。</span></span><br><span class="line"><span class="comment">         * DiscardOldestPolicy()：丢弃队列中最老的任务。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">        <span class="comment">//线程初始化</span></span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用自定义的线程池实现异步处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduleTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span>(<span class="string">"myAsync"</span>)</span><br><span class="line">    <span class="meta">@Scheduled</span>(fixedRate = <span class="number">2000</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testScheduleTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">            System.out.println(<span class="string">"SpringBoot的定时任务"</span> + Thread.currentThread().getName() + sdf.format(<span class="keyword">new</span> Date()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-f8c5a9d0df29ad19b498546cf938e7be_1440w.jpg" alt="img"></p>
<p>当前线程名称已经被改成自定义god-jiang-的前缀！</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是我在企业开发中所用到的SpringBoot的@Schedule定时任务，并且搭配上我手动实现的线程池异步执行，基本可以满足绝大部分的开发需求，希望以上的内容对你们有所帮助～～～</p>
]]></content>
      <categories>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>SpringBoot定时任务</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反射机制</title>
    <url>/2021/01/03/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="反射机制概念"><a href="#反射机制概念" class="headerlink" title="反射机制概念"></a>反射机制概念</h2><p>Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够动态调用它的任意一个方法和属性；这个动态获取信息以及动态调用对象的方法的功能称为Java语言的反射机制。</p>
<p>在Java的设计模式和流行框架中，反射机制被大量的使用，如果不深刻理解Java反射机制，是无法理解Java的设计模式或阅读流行框架底层代码的。</p>
<a id="more"></a>
<h2 id="反射机制提供的功能"><a href="#反射机制提供的功能" class="headerlink" title="反射机制提供的功能"></a>反射机制提供的功能</h2><ul>
<li>在运行时判断任意一个对象所属的类</li>
<li>在运行时构造任意一个类的对象</li>
<li>在运行时访问一个类所具有的成员变量</li>
<li>在运行时调用任意一个对象的方法</li>
<li>生成动态代理</li>
</ul>
<h2 id="反射实现的类"><a href="#反射实现的类" class="headerlink" title="反射实现的类"></a>反射实现的类</h2><p>在JDK中，主要由以下类来实现Java反射机制，这些类都位于java.lang.reflect包中。</p>
<ol>
<li>Class类：封装了描述方法的Method，描述字段的Field，描述构造器的Constructor等属性。对于每个类，JRE都会为其保留一个不变的Class类型的对象</li>
<li>Field类：代表类的成员变量（成员变量也称为类的属性）</li>
<li>Method类：代表类的方法</li>
<li>Constructor类：代表类的构造方法</li>
</ol>
<h2 id="获取类的字节码对象"><a href="#获取类的字节码对象" class="headerlink" title="获取类的字节码对象"></a>获取类的字节码对象</h2><p>要想解剖一个类，必须要获取到该类的字节码文件对象。常用的获取Class对象的3中方式：<strong>使用Class类的静态方法、使用类的.class方法、使用对象的getClass()。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取Class对象演示</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/1/2 17:09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reflect</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取类的三种方法</span></span><br><span class="line">        <span class="comment">// 第一种 Class.forName("类名")（强烈推荐）</span></span><br><span class="line">        Class c1 = Class.forName(<span class="string">"java.lang.String"</span>);</span><br><span class="line">        System.out.println(<span class="string">"第一种方法获取的类："</span> + c1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二种 类名.class</span></span><br><span class="line">        Class c2 = String.class;</span><br><span class="line">        System.out.println(<span class="string">"第二种方法获取的类："</span> + c2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第三种 对象.getClass()</span></span><br><span class="line">        String str = <span class="keyword">new</span> String();</span><br><span class="line">        Class c3 = str.getClass();</span><br><span class="line">        System.out.println(<span class="string">"第三种方法获取的类："</span> + c3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic4.zhimg.com/80/v2-53fa675960c641645f032bd527936a5f_1440w.jpg" alt="img"></p>
<h2 id="反射机制的运用"><a href="#反射机制的运用" class="headerlink" title="反射机制的运用"></a>反射机制的运用</h2><p><strong>1、在运行时判断任意一个对象所属的类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反射的运用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/1/2 17:33</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reflect</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 1、在运行时判断任意一个对象所属的类</span></span><br><span class="line">        Class c1 = Class.forName(<span class="string">"java.lang.String"</span>);</span><br><span class="line">        String str = <span class="keyword">new</span> String(<span class="string">"god-jiang"</span>);</span><br><span class="line">        Integer itr = <span class="number">666</span>;</span><br><span class="line">        <span class="comment">// 同一个类则返回true,否则返回false</span></span><br><span class="line">        <span class="keyword">boolean</span> instance1 = c1.isInstance(str);</span><br><span class="line">        <span class="keyword">boolean</span> instance2 = c1.isInstance(itr);</span><br><span class="line">        System.out.println(<span class="string">"运行时获取的对象c1是否属于String类："</span> + instance1);</span><br><span class="line">        System.out.println(<span class="string">"运行时获取的对象c1是否属于Integer类："</span> + instance2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/80/v2-20494871aa7fecd77016f7c0b5d2fcc9_1440w.jpg" alt="img"></p>
<p><strong>2、在运行时构造任意一个类的对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反射的运用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/1/2 17:33</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reflect</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 2、在运行时构造任意一个类的对象</span></span><br><span class="line">        Class c1 = Class.forName(<span class="string">"java.lang.String"</span>);</span><br><span class="line">        <span class="comment">// 调用无参的构造器</span></span><br><span class="line">        Object str1 = c1.newInstance();</span><br><span class="line">        System.out.println(str1.hashCode());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用有参的构造器</span></span><br><span class="line">        <span class="comment">// 获取String类带一个String参数的构造器</span></span><br><span class="line">        Constructor constructor = c1.getConstructor(String.class);</span><br><span class="line">        Object str2 = constructor.newInstance(<span class="string">"god-jiang"</span>);</span><br><span class="line">        System.out.println(str2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic4.zhimg.com/80/v2-11f189eb14eba6e5fe9d5f2eede09c9b_1440w.jpg" alt="img"></p>
<p><strong>3、在运行时访问类所具有的成员变量</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> god.jiang;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示的POJO</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/1/2 18:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String tag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>演示反射机制获取成员变量并且修改变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反射的运用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/1/2 17:33</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reflect</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 3、在运行时访问类所具有的成员变量</span></span><br><span class="line">        Class c1 = Class.forName(<span class="string">"god.jiang.User"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实例化对象</span></span><br><span class="line">        User user = (User) c1.newInstance();</span><br><span class="line">        user.setName(<span class="string">"god-jiang"</span>);</span><br><span class="line">        user.setAge(<span class="number">18</span>);</span><br><span class="line">        user.setTag(<span class="string">"god-jiang演示反射的运用"</span>);</span><br><span class="line"></span><br><span class="line">        Field[] fields = c1.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            <span class="comment">// 获取private变量的访问权</span></span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            System.out.println(<span class="string">"成员变量"</span> + field.getName() + <span class="string">"的值为："</span> + field.get(user));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"====================================================="</span>);</span><br><span class="line">        <span class="comment">// 动态修改对象的值</span></span><br><span class="line">        Field field = c1.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field.set(user, <span class="string">"wuxijiang666"</span>);</span><br><span class="line">        System.out.println(<span class="string">"name的值修改后为："</span> + user.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/80/v2-843748842ab6e0bd7dfedb14e8ad97bc_1440w.jpg" alt="img"></p>
<p><strong>4、在运行时调用对象所具有的方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反射的运用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/1/2 17:33</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reflect</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 4、在运行时调用对象所具有的方法</span></span><br><span class="line">        Class c1 = Class.forName(<span class="string">"java.lang.String"</span>);</span><br><span class="line">        Object str = c1.getConstructor(String.class).newInstance(<span class="string">"god-jiang"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反射获取String类的indexOf方法</span></span><br><span class="line">        Method indexOf = c1.getDeclaredMethod(<span class="string">"indexOf"</span>, String.class);</span><br><span class="line">        <span class="comment">// 获取private的访问权</span></span><br><span class="line">        indexOf.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 调用方法,获取'-'在“god-jiang”的位置</span></span><br><span class="line">        Object invoke = indexOf.invoke(str, <span class="string">"-"</span>);</span><br><span class="line">        System.out.println(<span class="string">"获取'-'在“god-jiang”的位置为："</span> + invoke);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-4203a6c7043621dbac09851f093fb926_1440w.jpg" alt="img"></p>
<h2 id="反射的缺点"><a href="#反射的缺点" class="headerlink" title="反射的缺点"></a>反射的缺点</h2><ul>
<li>反射会额外消耗一些系统资源，因此如果不需要动态创建一个对象那就不要使用反射</li>
<li>反射调用方法可以忽略权限检查，因此可能会破坏封装性而导致安全问题</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>反射是每个Java程序员都必定要掌握的一个知识点，只会CRUD的只能是初级程序员，而初级往中高级的途径中，必有反射机制这个门槛，希望每位Java程序员都能够迈过去，一步步成长和升级。</p>
<p><strong>希望以上这篇Java反射机制对正在学习Java或者已经工作的程序猿有所帮助。</strong></p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>Java之自定义注解</title>
    <url>/2020/12/27/Java%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="什么是注解？"><a href="#什么是注解？" class="headerlink" title="什么是注解？"></a>什么是注解？</h2><ul>
<li>Annotation是JDK5.0开始引入的技术</li>
<li>Annotation的作用可以对程序作出解释（和注释没什么区别），可以被其他程序读取</li>
<li>Annotation的格式是以“@注释名“在代码中存在的，还可以添加参数值，如@SuppressWarnings(value = “all”)</li>
<li>Annotation可以附加在package，class，method，field等上面，给他们添加额外的辅助信息，可以配合反射实现对元数据的访问</li>
</ul>
<a id="more"></a>
<h2 id="Java内置注解"><a href="#Java内置注解" class="headerlink" title="Java内置注解"></a>Java内置注解</h2><ul>
<li>@Override：定义在java.lang.Override中，此注释作用于方法上，表示一个方法重写超类中的另一个方法声明</li>
<li>@Deprecated：定义在java.lang.Deprecated中，此注释作用于方法，属性，类，表示不鼓励程序员使用，通常是因为它很危险或者存在更好的选择</li>
<li>@SuppressWarnings：定义在java.lang.SuppressWarnings中，用来意志编译时的警告信息</li>
<li><strong>JDK还有许多内置注解，有兴趣可以去观看源码，这里就不一一列举了</strong></li>
</ul>
<h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>元注解的作用是负责注解其他注解，Java定义了4个标准的meta-annotation类型，它们被用来提供对其他annotation类型作解释。</p>
<p>这些类型和它们所支持的类在java.lang.annotation包中可以找到（@Target，@Retention，@Decumented，@Inherited）</p>
<ul>
<li>@Target：用于描述注解的使用范围（注解使用在类上，方法上，字段上等等）</li>
<li>@Retention：表示需要在什么级别保存该注释信息，用于描述注解的生命周期（SOURCE &lt; CLASS &lt; RUNTIME）</li>
<li>@Decument：说明该注解将被javadoc打包生成</li>
<li>@Inherited：说明子类可以继承父类中的注解</li>
</ul>
<h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><ul>
<li>@interface用来声明一个注解，格式为：public @interface 注解名 { 定义内容 }</li>
<li>其中的每一个方法实际上是声明了一个配置参数</li>
<li>方法的名称就是参数的名称</li>
<li>返回值类型就是参数的类型（返回值只能是基本类型Class，String，Enum）</li>
<li>可以通过default来声明参数的默认值</li>
<li>如果只有一个参数成员，一般参数名为value</li>
<li>注解元素必须要有值，我们定义注解元素时，经常使用空字符串或者0作为默认值</li>
</ul>
<h2 id="自定义注解演示案例"><a href="#自定义注解演示案例" class="headerlink" title="自定义注解演示案例"></a>自定义注解演示案例</h2><p>创建一个注解MyAnnotation.java：</p>
<p><img src="https://pic1.zhimg.com/80/v2-f62dadfddb16c10ee575c2111eda4ef0_1440w.jpg" alt="img"></p>
<p>创建一个pojo名为User.java：</p>
<p><img src="https://pic1.zhimg.com/80/v2-7eb75e6ca60ea7016158d047545e1f84_1440w.jpg" alt="img"></p>
<p>创建一个Test.java演示自定义注解：</p>
<p><img src="https://pic1.zhimg.com/80/v2-81ddb6f36811f54d74a5c1d2fc2c8610_1440w.jpg" alt="img"></p>
<p>最终控制台输出结果：</p>
<p><img src="https://pic1.zhimg.com/80/v2-0836c7c07d29f0111a32b103a6df6f4c_1440w.jpg" alt="img"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>注解其实跟我们平时写代码的注释没多大区别，主要是注释给我们程序员看的，而注解是给程序解释的。通常注解和反射一起运用才是绝配，可以发挥出很强大的作用。希望这篇自定义注解对你们有所帮助～～～</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>注解与反射</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot自动配置（源码解读）</title>
    <url>/2020/12/15/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%EF%BC%88%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%EF%BC%89/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我参加SpringBoot项目开发也已经五个多月时间了，项目遇到一个大数据量文本的取存问题，DBA不允许我们存text或者blob类型的数据在MySQL中，不得已采取了ElasticSearch作为一个中间数据库使用，然后根据网上的方法把maven依赖导入，application.properties粘贴过来，发现已经引入了ElasticSearch这个组件，最后把问题解决了。</p>
<p>但是这也引发了我的思考，为啥SpringBoot可以自动识别并且帮我初始化ES呢？阅读了SpringBoot源码，我按照我的理解讲一下SpringBoot的自动配置。</p>
<a id="more"></a>
<h2 id="理论知识"><a href="#理论知识" class="headerlink" title="理论知识"></a>理论知识</h2><p>创建一个SpringBoot项目，它会帮我们生成我们开发者所需要的环境，它的一个注解@SpringBootApplication可以帮助我们开发者开启自动配置并且初始化我们所需要的bean。</p>
<p><img src="https://pic3.zhimg.com/80/v2-8f5371ee090523bb7360f1c0f57e162e_1440w.jpg" alt="img"></p>
<p><strong>但是@SpringBootApplication为什么可以这样呢？</strong></p>
<p>点进去看这个注解，原来这个注解是一个复合注解，里面还有一个@EnableAutoConfiguration，顾名思义就是自动开启配置。</p>
<p><img src="https://pic3.zhimg.com/80/v2-0fb5141c20fabfdb3362ced59613b032_1440w.jpg" alt="img"></p>
<p>然后再点进去查看它的源码</p>
<p><img src="https://pic2.zhimg.com/80/v2-9cab0333e5cd049b2e51c82f928fff85_1440w.jpg" alt="img"></p>
<p>发现原来SpringBoot自动配置的关键就是这个注解@Import({AutoConfigurationImportSelector.class})，点进去查看源码</p>
<p><img src="https://pic4.zhimg.com/80/v2-1c6fd564121e5f8429f57ba6a434c3df_1440w.jpg" alt="img"></p>
<p>它的作用就是导入AutoConfigurationImportSelector的selectImports方法，通过SpringFactoriesLoader.loadFactoryNames()扫描所有META-INF/spring.factories的jar包。然后spring-boot-autoconfigure-2.4.1.jar里面有一个spring.factories文件。该文件由一堆key=value组成，其中key是EnableAutoConfiguration类的全类名，而value是xxxAutoConfiguration的类名列表，以逗号分隔。</p>
<p><img src="https://pic3.zhimg.com/80/v2-99207f853d42a9a78bed0f84a5ec1f9a_1440w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-f3772b7b4916d6d7c57fa8bf5013156a_1440w.jpg" alt="img"></p>
<p>上面所列出来的org.springframework.boot.autoconfigure.xxx.yyyAutoConfiguration列表会被初始化到Spring容器中。</p>
<p>当SpringBoot项目启动时，@SpringBootApplication在启动类SpringApplication.run(xxx.class)的内部会执行selectImports()方法，找到所有自动配置类的全限定名对应的class，然后把所有的自动配置类加载到Spring容器中。</p>
<p><strong>那么这么多xxxAutoConfiguration类都会被加载吗？</strong></p>
<p>答案是不会。因为注解类会有一个@ConditionalOnClass注解，只要在当前的类路径下找到对应的类才会被加载，否则放弃加载并且初始化到Spring容器中。</p>
<p>这就很好理解为啥SpringBoot项目引入一个依赖就能自动帮你初始化bean了吧。</p>
<h2 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h2><p>举例我最近用的elasticSearch的配置信息如何加载到bean容器中的。</p>
<p>引入组件所需要的maven依赖：</p>
<p><img src="https://pic1.zhimg.com/80/v2-441f07cc5a3d51531b3c3901edd48a70_1440w.jpg" alt="img"></p>
<p>配置application.properties基础信息：</p>
<p><img src="https://pic4.zhimg.com/80/v2-64ad9ed965aa6df64cb534baa25ad8bb_1440w.jpg" alt="img"></p>
<p><strong>为何要这样配置呢？源码告诉你答案。</strong></p>
<p>springboot自动配置全都是由autoconfigure注入的，打开maven引入的autoconfigure的jar包</p>
<p><img src="https://pic3.zhimg.com/80/v2-da0ab23a8d7a1fd6cbca34c7b6c347fe_1440w.jpg" alt="img"></p>
<p>SpringBoot加载会读取里面的spring.factories文件</p>
<p><img src="https://pic3.zhimg.com/80/v2-3de5eed83d47b6efc7c6e5290fe4ff7e_1440w.jpg" alt="img"></p>
<p>所有的配置都是由org.springframework.boot.autoconfigure.EnableAutoConfiguration来完成注入，格式都是为org.springframework.boot.autoconfigure.xxx.yyyAutoConfiguration。</p>
<p>拿我们配置的elasticsearch来说明一下，点进去看它配置的源码</p>
<p><img src="https://pic2.zhimg.com/80/v2-063db3b62d349c5f82245e1ea73ec181_1440w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-a303e4ed3985b225f7df1f09cc1b1184_1440w.jpg" alt="img"></p>
<p>可以看到有一个注解@EnableConfigurationProperties，就是用来配置和初始化bean的。点进去看ElasticsearchRestClientProperties的配置信息</p>
<p><img src="https://pic4.zhimg.com/80/v2-d988172fc5d634c7946340d1a83445bf_1440w.jpg" alt="img"></p>
<p>一切恍然大悟，原来这里的@ConfigurationProperties(prefix=”spring.elasticsearch.rest”)已经规定了配置文件该如何写了，就是限制了前缀”spring.elasticsearch.rest”，后面的uris的类型是List代表它支持集群，可以加载多个服务器。然后它们有对应的get/set方法可以帮助我们开发者注入，这就对应上我们的application.properties文件了吧。</p>
<p><img src="https://pic2.zhimg.com/80/v2-9053d0afdfcb3c0d5cb3e172fb0a2bf9_1440w.jpg" alt="img"></p>
<p><strong>就是通过这种方式注入到bean容器并且初始化的，这就是springboot的“约定大于配置”。</strong></p>
<h2 id="类比其他配置信息"><a href="#类比其他配置信息" class="headerlink" title="类比其他配置信息"></a><strong>类比其他配置信息</strong></h2><p>我直接把springboot中redis的约定贴出来，你们也可以对比一下你们自己的项目配置，知道为什么要这样写就行了。</p>
<p><img src="https://pic2.zhimg.com/80/v2-a6684c8853899867821d1a4ac1b99e5d_1440w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-1f96b7902acb3cf76a13c4703b847848_1440w.jpg" alt="img"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这一次项目引入ElasticSearch引发的一场SpringBoot自动配置源码阅读，我觉得还是受益匪浅的，希望以上的内容对正在学SpringBoot或者已经工作的开发者们有帮助。</p>
]]></content>
      <categories>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>SpringBoot自动配置</tag>
      </tags>
  </entry>
  <entry>
    <title>解读阿里巴巴开发规范之MySQL</title>
    <url>/2020/11/29/%E8%A7%A3%E8%AF%BB%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83%E4%B9%8BMySQL/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从7月份毕业开始算起，也是将近有5个月的工作经验了吧。在工作上，经历了一段时间的适应，现在接触到不同大神写出来的代码，发现各有优劣，于是就在思考一个问题，什么样的代码才是最正常最规范的呢？我的同事甩给我了一本《阿里巴巴Java开发手册》，从头到尾也算是过了一遍。今天趁着双休的假期，我就来讲一下这本书里面的MySQL规范制约吧</p>
<a id="more"></a>
<h2 id="建表规约"><a href="#建表规约" class="headerlink" title="建表规约"></a>建表规约</h2><p>1、【强制】每张表必须设置一个主键ID，并且这个主键ID要自增（在满足需要的情况下尽量短），除非是分库分表</p>
<p>理解：由于InnoDB存储引擎决定了需要有一个主键，而且这个主键ID是自增的话可以有效提高插入的性能，避免过多的页分裂，减少表碎片提高空间的利用率。</p>
<p>但是在分库分表下，会有分片规则，这个时候需要统一分配各个表中的主键值，从而避免整个逻辑表中主键重复，一般我们会使用雪花ID来实现。</p>
<p>2、【强制】必须使用utf8mb4字符集</p>
<p>理解：在MySQL中的UTF-8并非是真正的”UTF-8”，而utf8mb4才是真正的”UTF-8”。</p>
<p>3、【强制】数据库表、表字段必须加入中文注释</p>
<p>理解：程序员都不要给我懒，这样可以让后来者更好的上手和理解。</p>
<p>4、【强制】库名、表名、字段名必须小写，下划线风格，不超过32个字符，必须见名知意，禁止拼音英文混用</p>
<p>理解：在linux环境下MySQL是区分大小写的，而在windows是不区分大小写的，所以统一使用小写+下划线可以避免不必要的混淆。</p>
<p>5、【强制】单表列数目必须小于30，若超过则应该考虑将表拆分</p>
<p>理解：单表列数太多会使得MySQL处理InnoDB返回数据之间的映射成本太高。</p>
<p>6、【强制】禁止使用外键，如果有外键完整性约束，需要应用程序控制</p>
<p>理解：外键会导致表与表之间耦合，UPDATE与DELETE操作都会涉及相关联的表，十分影响SQL的性能，甚至会造成死锁。</p>
<p>7、【强制】必须把字段定义为NOT NULL并且提供默认值</p>
<p>理解：NULL需要更多的存储空，无论是表还是索引中每行中的NULL的列都需要额外的空间来标识。NULL这种类型需要MySQL内部进行特殊处理，增加了数据库处理记录的复杂性，同等条件下，表中较多NULL字段会导致数据库处理性能下降。</p>
<p>8、【强制】禁止使用保留字，如DESC、RANGE、MAX等</p>
<p>理解：请参考MySQL官方保留字。</p>
<p>9、【强制】如果存储的字符串长度几乎相等，使用CHAR定长字符串类型</p>
<p>理解：能够减少空间碎片，节省存储空间。</p>
<p>10、【强制】小数类型为 decimal，禁止使用 float 和 double</p>
<p>理解：float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数分开存储。</p>
<p>11、【强制】表必备三字段：id, gmt_create, gmt_modified。</p>
<p>理解：其中 id 必为主键，类型为 bigint unsigned、单表时自增、步长为 1。gmt_create,gmt_modified 的类型均为 datetime 类型，前者现在时表示主动创建，后者过去分词表示被动更新。</p>
<p>12、【推荐】在一些场景下，考虑使用TIMESTAMP代替DATETIME</p>
<p>理解：TIMESTAMP可以表达1970-2038年，而且TIMESTAMP需要4字节存储空间，而DATETIME需要8字节，存储1001-9999年</p>
<p>13、【推荐】对于自动生成的schema不要太过信任，最好自己手动写</p>
<p>理解：对于一些数据库客户端不要过分信任。</p>
<h2 id="索引规约"><a href="#索引规约" class="headerlink" title="索引规约"></a>索引规约</h2><p>1、【强制】业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引</p>
<p>理解：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。</p>
<p>2、【强制】超过三个表禁止 join。需要 join 的字段，数据类型必须绝对一致；多表关联查询时，保证被关联的字段需要有索引</p>
<p>理解：多表的join操作会影响SQL的性能</p>
<p>3、【强制】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可</p>
<p>理解：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达 90%以上，可以使用 count(distinct left(列名, 索引长度))/count(*)的区分度来确定。</p>
<p>4、【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决</p>
<p>理解：索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。</p>
<p>5、【推荐】如果有 order by 的场景，请注意利用索引的有序性。order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现 file_sort 的情况，影响查询性能</p>
<p>理解：组合索引的顺序会影响到SQL的查询性能</p>
<p>6、【推荐】利用覆盖索引来进行查询操作，避免回表</p>
<p>理解：覆盖索引只需要通过索引即可拿到所需的数据，而不再需要再次回表查询，提高了SQL的查询效率。</p>
<p>7、【推荐】利用延迟关联或者子查询优化超多分页场景</p>
<p>理解：MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL 改写。</p>
<p>8、【推荐】建组合索引的时候，区分度最高的在最左边</p>
<p>理解：区分度最高的放左边，能够在一开始过滤掉很多无用数据，提高索引的效率。需要注意的是各个条件的顺序尽量和索引的顺序一致。</p>
<p>9、【推荐】防止因字段类型不同造成的隐式转换，导致索引失效</p>
<p>理解：详细细节可以参考这篇文章哦~~~</p>
<p><a href="https://zhuanlan.zhihu.com/p/277647111" target="_blank" rel="noopener">god-jiang：MySQL索引（三）索引不生效的情况zhuanlan.zhihu.com<img src="https://zhstatic.zhihu.com/assets/zhihu/editor/zhihu-card-default.svg" alt="图标"></a></p>
<h2 id="SQL规约"><a href="#SQL规约" class="headerlink" title="SQL规约"></a>SQL规约</h2><p>1、【强制】不要使用 count(列名)或 count(常量)来替代 count(<em>)，count(</em>)是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关</p>
<p>理解：count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。</p>
<p>2、【强制】使用 ISNULL()来判断是否为 NULL 值</p>
<p>理解：NULL与任何值直接比较都为NULL。</p>
<ol>
<li>NULLNULL返回结果是NULL，而不是false。</li>
<li>NULL=NULL返回结果是NULL，而不是false。</li>
<li>NULL1返回结果是NULL，而不是true。</li>
</ol>
<p>3、【强制】在代码中写分页查询逻辑时，若 count 为 0 应直接返回，避免执行后面的分页语句</p>
<p>理解：提高SQL的效率，避免不必要的无用查询。</p>
<p>4、【强制】不得使用外键与级联，一切外键概念必须在应用层解决</p>
<p>理解：外键会导致表与表之间耦合，UPDATE与DELETE操作都会涉及相关联的表，十分影响SQL的性能，甚至会造成死锁。</p>
<p>5、【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性</p>
<p>理解：避免不必要的维护。</p>
<p>6、【推荐】TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但 TRUNCATE无事务且不触发 trigger，有可能造成事故，故不建议在开发代码中使用此语句。</p>
<p>理解：TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《阿里巴巴Java开发手册》</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL规范</tag>
      </tags>
  </entry>
  <entry>
    <title>聊聊MySQL的COUNT(*)的性能</title>
    <url>/2020/11/17/%E8%81%8A%E8%81%8AMySQL%E7%9A%84COUNT-%E7%9A%84%E6%80%A7%E8%83%BD/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>基本职场上的程序员用来统计数据库表的行数都会使用count(*)，count(1)或者count(主键)，那么它们之间的区别和性能你又是否了解呢？</p>
<p>其实程序员在开发的过程中，在一张大表上统计总行数是非常耗时的一个操作，那么我们应该用哪个方法统计会更快呢？</p>
<p>接下来我们就来聊一聊MySQL中统计总行数的方法和性能。</p>
<a id="more"></a>
<h2 id="count-，count-1-，count-主键-哪个更快？"><a href="#count-，count-1-，count-主键-哪个更快？" class="headerlink" title="count(*)，count(1)，count(主键)哪个更快？"></a>count(*)，count(1)，count(主键)哪个更快？</h2><h2 id="1、建表并且插入1000万条数据进行实验测试："><a href="#1、建表并且插入1000万条数据进行实验测试：" class="headerlink" title="1、建表并且插入1000万条数据进行实验测试："></a>1、建表并且插入1000万条数据进行实验测试：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建测试表</span><br><span class="line">CREATE TABLE `t6` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(50) NOT NULL,</span><br><span class="line">  `status` tinyint(4) NOT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `idx_status` (`status`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line"># 创建存储过程插入1000w数据</span><br><span class="line">CREATE PROCEDURE insert_1000w()</span><br><span class="line">BEGIN</span><br><span class="line">    DECLARE i INT;</span><br><span class="line">    SET i=1;</span><br><span class="line">    WHILE i&lt;=10000000 DO</span><br><span class="line">        INSERT INTO t6(name,status) VALUES(&apos;god-jiang-666&apos;,1);</span><br><span class="line">        SET i=i+1;</span><br><span class="line">    END WHILE;</span><br><span class="line">END;</span><br><span class="line"></span><br><span class="line">#调用存储过程，插入1000万行数据</span><br><span class="line">call insert_1000w();</span><br></pre></td></tr></table></figure>
<h2 id="2、分析实验结果"><a href="#2、分析实验结果" class="headerlink" title="2、分析实验结果"></a>2、分析实验结果</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 花了0.572秒</span><br><span class="line">select count(*) from t6;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/80/v2-0a2bb0c9a316184341faa427e1eb5d34_1440w.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 花了0.572秒</span><br><span class="line">select count(1) from t6;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/80/v2-fce8bb342f50956ff6c65bfe8f56cbd0_1440w.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 花了0.580秒</span><br><span class="line">select count(id) from t6;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/80/v2-198f3c672164c27ac1a82f7d087f2dd4_1440w.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 花了0.620秒</span><br><span class="line">select count(*) from t6 force index (primary);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/80/v2-2bfec4e5d385baa7bfb7a4bc1f3276e2_1440w.png" alt="img"></p>
<p>从上面的实验我们可以得出，<strong>count(*)和count(1)是最快的，其次是count(id)，最慢的是count使用了强制主键</strong>的情况。</p>
<p>下面我们继续测试一下它们各自的执行计划：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain select count(*) from t6;</span><br><span class="line">show warnings;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/80/v2-fa553094fa8a44bd136d32f79a97494b_1440w.png" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-0e61a8bb4dee6839ccc9e68224ff84ee_1440w.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain select count(1) from t6;</span><br><span class="line">show warnings;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/80/v2-a5571b99df2242fc0d7dcae220cfdb57_1440w.png" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-a7c11018c55fb6753cc95a7f471c93e8_1440w.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain select count(id) from t6;</span><br><span class="line">show warnings;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic4.zhimg.com/80/v2-0ff199a9d1694836a9a0a1f6e2641883_1440w.png" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-900eda9d3f36c560da2a9a2bace72951_1440w.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain select count(*) from t6 force index (primary);</span><br><span class="line">show warnings;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/80/v2-5402f12b831c7295a87f94c25454c59e_1440w.png" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-8cd2b8ce13f2cc79825800a58e45c75c_1440w.png" alt="img"></p>
<p>从上面的实验可以得出这三点：</p>
<ol>
<li>count(*)被MySQL查询优化器改写成了count(0)，并选择了idx_status索引</li>
<li>count(1)和count(id)都选择了idx_statux索引</li>
<li>加了force index(primary)之后，走了强制索引</li>
</ol>
<p>这个idx_status就是相当于是二级辅助索引树，目的就是为了说明： InnoDB在处理count(*)的时候，有辅助索引树的情况下，会优先选择辅助索引树来统计总行数。</p>
<p>为了验证count(*)会优先选择辅助索引树这个结论，我们继续来看看下面的实验：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 删除idx_status索引，继续执行count(*)</span><br><span class="line">alter table t6 drop index idx_status;</span><br><span class="line"></span><br><span class="line">explain select count(*) from t6;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/80/v2-adb7c38912a825e805c5233917e9d86a_1440w.png" alt="img"></p>
<p>从以上实验可以得出，删除了idx_status这个辅助索引树，count(<em>)就会选择走主键索引。所以结论：**count(\</em>)会优先选择辅助索引，假如没有辅助索引的存在，就会走主键索引**。</p>
<h2 id="为什么count-会优先选择辅助索引？"><a href="#为什么count-会优先选择辅助索引？" class="headerlink" title="为什么count(*)会优先选择辅助索引？"></a>为什么count(*)会优先选择辅助索引？</h2><p>在MySQL5.7.18之前，InnoDB通过扫描聚集索引来处理count(*)语句。</p>
<p>从MySQL5.7.18开始，InnoDB通过遍历最小的可用二级索引来处理count(*)语句。如果不存在二级索引，则扫描聚集索引。</p>
<h2 id="新版本为何会使用二级索引来处理count-呢？"><a href="#新版本为何会使用二级索引来处理count-呢？" class="headerlink" title="新版本为何会使用二级索引来处理count(*)呢？"></a>新版本为何会使用二级索引来处理count(*)呢？</h2><p>因为InnoDB二级索引树的叶子节点上存放的是主键，而主键索引树的叶子节点存放的是整行数据，所以二级索引树比主键索引树小。因此查询优化器基于成本考虑，优先选择的是二级索引。所以索引count(*)快于count(主键)。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章的结论就是<strong>count(*)=count(1)&gt;count(id)</strong>。</p>
<p>为什么count(id)走了主键索引还会更慢呢？因为除了计算总行数之外，count(id)需要遍历主键索引树（聚集索引树），代价更高。</p>
<p>count(*)是会总计出所有NOT NULL和NULL的字段，而count(id)是不会统计NULL字段的，所以我们在建表的尽量使用NOT NULL并且给它一个默认是空即可。</p>
<p>最后，在以后总计数据库表的总行数的时候，可以大胆的使用count(*)或者count(1)。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>《高性能MySQL》（第三版）第六章优化COUNT()查询</li>
<li>《MySQL实战45讲》林晓斌</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL的COUNT(*)</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL优化之超大分页查询</title>
    <url>/2020/11/10/MySQL%E4%BC%98%E5%8C%96%E4%B9%8B%E8%B6%85%E5%A4%A7%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>基本上只要是做后台开发，都会接触到分页这个需求或者功能吧。基本上大家都是会用MySQL的LIMIT来处理，而且我现在负责的项目也是这样写的。但是一旦数据量起来了，其实LIMIT的效率会极其的低，这一篇文章就来讲一下LIMIT子句优化的。</p>
<a id="more"></a>
<h2 id="LIMIT优化"><a href="#LIMIT优化" class="headerlink" title="LIMIT优化"></a>LIMIT优化</h2><p>很多业务场景都需要用到分页这个功能，基本上都是用LIMIT来实现。</p>
<p>建表并且插入200万条数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 新建一张t5表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t5`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`text`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`ix_name`</span> (<span class="string">`name`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`ix_test`</span> (<span class="string">`text`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建存储过程插入200万数据</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> t5_insert_200w()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> i <span class="built_in">INT</span>;</span><br><span class="line">    <span class="keyword">SET</span> i=<span class="number">1000000</span>;</span><br><span class="line">    WHILE i&lt;=3000000 DO</span><br><span class="line">        <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t5(<span class="string">`name`</span>,<span class="built_in">text</span>) <span class="keyword">VALUES</span>(<span class="string">'god-jiang666'</span>,<span class="keyword">concat</span>(<span class="string">'text'</span>, i));</span><br><span class="line">        <span class="keyword">SET</span> i=i+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">WHILE</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用存储过程插入200万数据</span></span><br><span class="line"><span class="keyword">call</span> t5_insert_200w();</span><br></pre></td></tr></table></figure>
<p>在翻页比较少的情况下，LIMIT是不会出现任何性能上的问题的。</p>
<p>但是如果用户需要查到最后面的页数呢？</p>
<p>通常情况下，我们要保证所有的页面可以正常跳转，因为不会使用order by xxx desc这样的倒序SQL来查询后面的页数，而是采用正序顺序来做分页查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t5 <span class="keyword">order</span> <span class="keyword">by</span> <span class="built_in">text</span> <span class="keyword">limit</span> <span class="number">100000</span>, <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-cc7f6549895ff407b6d59548ad605186_1440w.jpg" alt="img"></p>
<p>采用这种SQL查询分页的话，从200万数据中取出这10行数据的代价是非常大的，需要先排序查出前1000010条记录，然后抛弃前面1000000条。我的macbook pro跑出来花了5.578秒。</p>
<p>接下来我们来看一下，上面这条SQL语句的执行计划：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t5 <span class="keyword">order</span> <span class="keyword">by</span> <span class="built_in">text</span> <span class="keyword">limit</span> <span class="number">1000000</span>, <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-1902a67f4083fa576387388dc0964dc6_1440w.jpg" alt="img"></p>
<p>从执行计划可以看出，在大分页的情况下，MySQL没有走索引扫描，即使text字段我已经加上了索引。</p>
<p>这是为什么呢？</p>
<p>回到<strong>MySQL索引（二）如何设计索引</strong>中有提及到，MySQL数据库的查询优化器是采用了基于代价的，而查询代价的估算是基于<strong>CPU代价</strong>和<strong>IO代价</strong>。</p>
<p>如果MySQL在查询代价估算中，认为全表扫描方式比走索引扫描的方式效率更高的话，就会放弃索引，直接全表扫描。</p>
<p>这就是为什么在大分页的SQL查询中，明明给该字段加了索引，但是MySQL却走了全表扫描的原因。</p>
<p>然后我们继续用上面的查询SQL来验证我的猜想：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t5 <span class="keyword">order</span> <span class="keyword">by</span> <span class="built_in">text</span> <span class="keyword">limit</span> <span class="number">7774</span>, <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/80/v2-76a0f5a4532bccdff895390f08898a1d_1440w.jpg" alt="img"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t5 <span class="keyword">order</span> <span class="keyword">by</span> <span class="built_in">text</span> <span class="keyword">limit</span> <span class="number">7775</span>, <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-721252409034d53e854fb072c5cf9c92_1440w.jpg" alt="img"></p>
<p>以上的实验均在我的mbp上运行的，在7774这个临界点上，MySQL分别采用了索引扫描和全表扫描的查询优化方式。</p>
<p><strong>所以可以认为MySQL会根据它自己的代价查询优化器来判断是否使用索引。</strong></p>
<p>由于MySQL的查询优化器的算法核心是我们无法人工干预的，所以我们的优化思路就要着手于如何让分页维持在最佳的的分页临界点。</p>
<h2 id="优化方式"><a href="#优化方式" class="headerlink" title="优化方式"></a>优化方式</h2><h2 id="1、使用覆盖索引"><a href="#1、使用覆盖索引" class="headerlink" title="1、使用覆盖索引"></a>1、使用覆盖索引</h2><p>如果一条SQL语句，通过索引可以直接获取查询的结果，不再需要回表查询，就称这个索引为<strong>覆盖索引</strong>。</p>
<p>在MySQL数据库中使用explain关键字查看执行计划，如果extra这一列显示<strong>Using index</strong>，就表示这条SQL语句使用了覆盖索引。</p>
<p>让我们来对比一下使用了覆盖索引，性能会提升多少吧。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t5 <span class="keyword">order</span> <span class="keyword">by</span> <span class="built_in">text</span> <span class="keyword">limit</span> <span class="number">1000000</span>, <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic4.zhimg.com/80/v2-606081e5a1e9a6c6bd3e15d08b160c13_1440w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-f4567af54364cbbe2dc9c77b0fdcdec8_1440w.jpg" alt="img"></p>
<p>这次查询花了3.690秒，让我们看一下使用了覆盖索引优化会提升多少性能吧。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>, <span class="string">`text`</span> <span class="keyword">from</span> t5 <span class="keyword">order</span> <span class="keyword">by</span> <span class="built_in">text</span> <span class="keyword">limit</span> <span class="number">1000000</span>, <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/80/v2-f79b2a23b80b26be5a1bb18c6eecd7a1_1440w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-57d4020ee03f829003d82d79d271d42c_1440w.jpg" alt="img"></p>
<p>从上面的对比中，超大分页查询中，使用了覆盖索引之后，花了0.201秒，而没有使用覆盖索引花了3.690秒，提高了18倍多，这在实际开发中，就是一个大的性能优化了。（该数据在我的mbp上运行得出）</p>
<h2 id="2、子查询优化"><a href="#2、子查询优化" class="headerlink" title="2、子查询优化"></a>2、子查询优化</h2><p>因为实际开发中，用SELECT查询一两列操作是非常少的，因此上述的覆盖索引的适用范围就比较有限。</p>
<p>所以我们可以通过把分页的SQL语句改写成子查询的方法获得性能上的提升。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t5 <span class="keyword">where</span> <span class="keyword">id</span>&gt;=(<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t5 <span class="keyword">order</span> <span class="keyword">by</span> <span class="built_in">text</span> <span class="keyword">limit</span> <span class="number">1000000</span>, <span class="number">1</span>) <span class="keyword">limit</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/80/v2-ef3e5410014412d43f0cc1e1b7df99dc_1440w.jpg" alt="img"></p>
<p>其实使用这种方法，提升的效率和上面使用了覆盖索引基本一致。</p>
<p>但是这种优化方法也有局限性：</p>
<ol>
<li>这种写法，要求主键ID必须是连续的</li>
<li>Where子句不允许再添加其他条件</li>
</ol>
<h2 id="3、延迟关联"><a href="#3、延迟关联" class="headerlink" title="3、延迟关联"></a>3、延迟关联</h2><p>和上述的子查询做法类似，我们可以使用JOIN，先在索引列上完成分页操作，然后再回表获取所需要的列。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a.* <span class="keyword">from</span> t5 a <span class="keyword">inner</span> <span class="keyword">join</span> (<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t5 <span class="keyword">order</span> <span class="keyword">by</span> <span class="built_in">text</span> <span class="keyword">limit</span> <span class="number">1000000</span>, <span class="number">10</span>) b <span class="keyword">on</span> a.id=b.id;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/80/v2-2d651149561eb3d6ad0b36c55ed0bca9_1440w.jpg" alt="img"></p>
<p>从实验中可以得出，在采用JOIN改写后，上面的两个局限性都已经解除了，而且SQL的执行效率也没有损失。</p>
<h2 id="4、记录上次查询结束的位置"><a href="#4、记录上次查询结束的位置" class="headerlink" title="4、记录上次查询结束的位置"></a>4、记录上次查询结束的位置</h2><p>和上面使用的方法都不同，记录上次结束位置优化思路是使用某种变量记录上一次数据的位置，下次分页时直接从这个变量的位置开始扫描，从而避免MySQL扫描大量的数据再抛弃的操作。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t5 <span class="keyword">where</span> <span class="keyword">id</span>&gt;=<span class="number">1000000</span> <span class="keyword">limit</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-eca6a898ece7883b1d6beac99fdefbc2_1440w.jpg" alt="img"></p>
<p>根据以上实验，不难得出，由于使用了主键索引做分页操作，SQL的性能是最快的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>介绍了超大分页查询性能过差的原因，还有分享了几个优化思路</li>
<li>超大分页的优化思路就是让分页的SQL尽量在最佳的性能区间执行，不要触发全表扫描即可</li>
<li>希望以上的分享，可以让你们在MySQL这条路上少走弯路～～～</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>《MySQL性能优化》第六章 查询优化性能</li>
<li>《数据库查询优化器的艺术》</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL分页优化</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL索引（三）索引不生效的情况</title>
    <url>/2020/11/10/MySQL%E7%B4%A2%E5%BC%95%EF%BC%88%E4%B8%89%EF%BC%89%E7%B4%A2%E5%BC%95%E4%B8%8D%E7%94%9F%E6%95%88%E7%9A%84%E6%83%85%E5%86%B5/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>经历了前面两篇的介绍MySQL索引，相信大家也可以很清晰的认识到索引。这一节想分享一下在MySQL中给字段加了索引，但是查询的时候却不生效索引的情况，让更多的开发者可以少踩坑，接下来直接进入正文～～～</p>
<a id="more"></a>
<h2 id="为什么索引不生效"><a href="#为什么索引不生效" class="headerlink" title="为什么索引不生效"></a>为什么索引不生效</h2><p>在上一篇MySQL（二）如何设计索引我们有提到过，MySQL使用的是基于成本的优化器，但是由于查询优化技术是关系型数据库实现中的难点，因此总会有一些索引不生效的情况。</p>
<p>接下来我们先建立一张表，并且插入模拟数据，来分析什么情况索引不生效。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t4`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`account`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`client_type`</span> tinyint <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`security_code`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_client_type`</span> (<span class="string">`client_type`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_account`</span> (<span class="string">`account`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_security_code`</span> (<span class="string">`security_code`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8</span><br></pre></td></tr></table></figure>
<h3 id="1、在索引字段上运算"><a href="#1、在索引字段上运算" class="headerlink" title="1、在索引字段上运算"></a>1、在索引字段上运算</h3><p>查询数据库表的时候，已经创建了索引，WHERE条件中也包含了索引列，但是列对象上有函数或者运算符，这样会导致索引失效。</p>
<p>比如下面这条SQL语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t4 <span class="keyword">where</span> <span class="keyword">id</span><span class="number">-1</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-23a56a513778f89c37422a994c415bfa_1440w.jpg" alt="img"></p>
<p>从上面实验的执行计划可以得出，在索引列上使用函数或者运算符，会导致索引无法生效。</p>
<h3 id="2、多个索引字段进行运算"><a href="#2、多个索引字段进行运算" class="headerlink" title="2、多个索引字段进行运算"></a>2、多个索引字段进行运算</h3><p>查询数据库表时，已经创建了索引，WHERE条件中也包含了索引列，但是列对象进行了运算操作。</p>
<p>比如下面这条SQL语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t4 <span class="keyword">where</span> <span class="keyword">id</span> + client_type = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/80/v2-3f6556a29e583fc50007d156174876c5_1440w.jpg" alt="img"></p>
<p>从以上实验来看，即使两个列上都有索引字段，MySQL仍然无法在表达式中使用这些索引。</p>
<h3 id="3、隐性转换"><a href="#3、隐性转换" class="headerlink" title="3、隐性转换"></a>3、隐性转换</h3><p>如果索引列是INT类型，隐性转换可以使用到索引。但是如果索引列是字符型，隐性转换无法使用索引。</p>
<p>比如下面这条SQL语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 不能使用索引，因为security_code字段是字符，它要变成INT型才能和688688比较，所以索引失效</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t4 <span class="keyword">where</span> security_code = <span class="number">688688</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以使用索引，因为查询优化器是把'1'变成1，然后索引列没有变化，可以使用索引。</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t4 <span class="keyword">where</span> <span class="keyword">id</span> = <span class="string">'1'</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-79f1973e408e83605b7fdb772312a126_1440w.jpg" alt="img"></p>
<p>在当前版本中，MySQL查询优化器已经可以转换字符型数字了，从而使用索引。但是反过来，索引失效。</p>
<h3 id="4、Like"><a href="#4、Like" class="headerlink" title="4、Like"></a>4、Like</h3><p>LIKE关键字，如果值是’%XXX’或者’%XXX%’，则无法使用索引。</p>
<p>如果值是’XXX%’，可以正常使用索引。这是因为通配符’%’位于前面，会导致查询优化器不得不使用全表查询，导致索引失效。</p>
<p>比如下面的SQL语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t4 <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">like</span> <span class="string">'%1'</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/80/v2-506816111cab945685d966598de4c6e8_1440w.jpg" alt="img"></p>
<p>如果业务中必须要用到模糊查询的话，我们可以试着引入全文搜索引擎ElasticSearch。</p>
<h3 id="5、OR操作符"><a href="#5、OR操作符" class="headerlink" title="5、OR操作符"></a>5、OR操作符</h3><p>篇幅原因，我就不一一演示了，直接说结论，你们也可以去试试。</p>
<ol>
<li>OR条件的两边都是同一个索引列的情况下，如果WHERE条件是主键，则可以使用索引</li>
<li>OR条件的两边都是同一个索引列的情况下，如果WHERE条件不是主键，则是否使用索引取决于MySQL查询优化器的代价估算。</li>
<li>OR条件的两边是不同的索引列，是否使用索引取决于MySQL查询优化器的代价估算。如果能使用索引，MySQL会使用索引，如果代价太高，仍然会走全表索引</li>
<li>如果多个OR条件中有其中一个条件没有索引，则必须进行全表索引</li>
</ol>
<h3 id="6、GROUP-BY子句"><a href="#6、GROUP-BY子句" class="headerlink" title="6、GROUP BY子句"></a>6、GROUP BY子句</h3><p>查询数据库表，WHERE条件不包含索引列，但是GROUP BY子句的条件中包含索引列。这个时候即使explain会显示它是走group by字句的索引，但是扫描的rows也是接近于全表扫描。</p>
<p>你可以自己对比一下，WHERE字句中的条件有索引和无索引的SQL性能将会差距非常大，在全表扫描的情况下SQL的性能惨不忍睹。</p>
<h3 id="7、ORDER-BY子句"><a href="#7、ORDER-BY子句" class="headerlink" title="7、ORDER BY子句"></a>7、ORDER BY子句</h3><p>和上面的GROUP BY子句类似，在MySQL查询优化器的代价估算模型中， ORDER BY和GROUP BY的代价，相对来说非常高，如果有索引就会尽可能的使用它。</p>
<h3 id="8、联合索引"><a href="#8、联合索引" class="headerlink" title="8、联合索引"></a>8、联合索引</h3><p>根据上面的第6条和第7条，只要给SQL语句中的WHERE子句和ORDER BY/GROUP BY子句加上一个联合索引就可以解决全表扫描的问题。</p>
<p>联合索引中索引失效的情况：</p>
<ul>
<li>没有使用索引前缀，就是没有遵循联合索引的最左匹配原则</li>
<li>使用了联合索引的全部列，但是索引键不是AND操作，可能使用了OR操作符</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>这一节讨论了MySQL中无法使用索引的一些场景，可能会有遗漏，有错误的地方可以评论区提出来。</li>
<li>对于WHERE子句来说，建议不要把运算操作放到SQL语句中，能在代码里面去运算尽量在代码里面运算，可以避免索引失效</li>
<li>如果模糊查询比较多，可以引入ES来帮助你进行模糊查询</li>
<li>ORDER BY和GROUP BY这两个子句，需要防范的问题是没有给WHERE条件设计索引，你在查看执行计划时也会比较迷惑，所以一定要注意</li>
</ul>
<p>希望你们读完这篇文章， 可以让你们在MySQL的这条路上少走弯路～～～</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL索引</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL索引（二）如何设计索引</title>
    <url>/2020/11/10/MySQL%E7%B4%A2%E5%BC%95%EF%BC%88%E4%BA%8C%EF%BC%89%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>到这一篇文章，我就已经默认你阅读完了前面的MySQL文章。你可能已经知道了索引本质就是一种数据结构，来加快查询效率的。但是索引要怎么设计呢？这就是这一篇文章的目的。</p>
<p>网上有很多博客会讲到最佳实践，比如单表索引数不能超过5个，联合索引中的字段不能超过5个等等。我只能说这些都是扯淡，任何实践都要放在特定的场景才能生效，所以接下来我们来聊聊索引设计吧。</p>
<a id="more"></a>
<h2 id="索引设计的误区"><a href="#索引设计的误区" class="headerlink" title="索引设计的误区"></a>索引设计的误区</h2><h2 id="单表索引数不超过5个"><a href="#单表索引数不超过5个" class="headerlink" title="单表索引数不超过5个"></a>单表索引数不超过5个</h2><p>索引本质上就是一种数据结构，然而我们可以把索引映射到现实生活中，就好比是《深入浅出MySQL》这本书前面的目录。难不成我们说目录的章节不能超过5个吗？显然不可以的，在这么一个前提下，给一个索引增加一个上限值是不恰当的。所以涉及到慢查询的时候该加索引就加索引，不要给它们设置一个上限就好了。</p>
<p>但是我们也不能在设计索引的时候滥用索引，在数据库表增加太多无用的索引也是会带来一些副作用的，比如DML语句会变得很慢。</p>
<h2 id="给高频字段加索引"><a href="#给高频字段加索引" class="headerlink" title="给高频字段加索引"></a>给高频字段加索引</h2><p>这条在绝大部分情况下是对的，但是也不完全对。因为没有对应到场景上，所以不能说完全对，下面我们举例来说明一下。</p>
<p>假如你设计了一个APP用来发送消息的模块，由于发送的消息太多，表中已经有1亿的数据量。为了提高发送消息的速度，领导要求你开发一个功能，给发送消息未成功的用户再尝试发送一次消息。</p>
<p>这样我们就可以设计发送的状态status，这个status有三个值，0代表未发送，1代表已经发送，2代表发送失败。</p>
<p>相关的SQL语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> messages <span class="keyword">where</span> <span class="keyword">status</span> = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>正常情况下，大家都是发送成功的，发送失败的概率非常低。</p>
<p>然后我们从数据库表中做一个统计：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">status</span>, <span class="keyword">count</span>(*) <span class="keyword">from</span> messages <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">status</span>;</span><br><span class="line">| status | count(*) |</span><br><span class="line">|      0 |     1000 |</span><br><span class="line">|      1 | 99999000 |</span><br><span class="line">|      2 |       24 |</span><br></pre></td></tr></table></figure>
<p>这种情况称之为数据的倾斜度高。</p>
<p>在这种情况下，我们只需要查找status的值为2的情况即可，只要我们不统计status=1的情况，就不用在高频字段加上索引。所以在这个场景下，给高频字段加索引是不对的。</p>
<h2 id="SQL执行顺序"><a href="#SQL执行顺序" class="headerlink" title="SQL执行顺序"></a>SQL执行顺序</h2><p>我们已经知道了SQL的执行计划（explain），那么SQL的执行顺序呢？是不是跟Java代码一样，按照编码的顺序来执行的，让我们来看看吧。</p>
<p>在SQL语言中，执行顺序是按照一个固定的规则来执行的：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">8、 <span class="keyword">SELECT</span></span><br><span class="line"><span class="number">9</span>、 <span class="keyword">DISTINCT</span> &lt;select_list&gt;</span><br><span class="line"><span class="number">1</span>、 <span class="keyword">FROM</span> &lt;left_table&gt;</span><br><span class="line"><span class="number">3</span>、 &lt;join_type&gt; <span class="keyword">JOIN</span> &lt;right_table&gt;</span><br><span class="line"><span class="number">2</span>、 <span class="keyword">ON</span> &lt;join_condition&gt;</span><br><span class="line"><span class="number">4</span>、 <span class="keyword">WHERE</span> &lt;where_condition&gt;</span><br><span class="line"><span class="number">5</span>、 <span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;group_by_list&gt;</span><br><span class="line"><span class="number">6</span>、 <span class="keyword">WITH</span> &#123;<span class="keyword">CUBE</span>|<span class="keyword">ROLLUP</span>&#125;</span><br><span class="line"><span class="number">7</span>、 <span class="keyword">HAVING</span> &lt;having_condition&gt;</span><br><span class="line"><span class="number">10</span>、<span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;order_by_condition&gt;</span><br><span class="line"><span class="number">11</span>、<span class="keyword">LIMIT</span> &lt;limit_number&gt;</span><br></pre></td></tr></table></figure>
<p>从上面的规则得知，SQL执行顺序是11个步骤，最先执行的是FROM子句，最后执行的是LIMIT子句。</p>
<p>在SQL执行过程中，每一个步骤都会产生一个虚拟表（Virtual Table，简称VT），用来保存SQL的执行结果。下面分析一下SQL执行的整个过程：</p>
<ol>
<li>FROM。经过 FROM 语句得到一个虚拟表 VT1，如果有多表关联，会先执行笛卡尔积运算。</li>
<li>ON。对虚拟表 VT1 执行 ON 条件筛选，筛选出符合 &lt;join_condition&gt; 条件的行，结果放入虚拟表 VT2 中。</li>
<li>JOIN。如果是 OUTER JOIN 类型，上述表中未匹配到的行会作为外部行添加到虚拟表 VT2 中，生成虚拟表 VT3。</li>
<li>WHERE。对虚拟表 VT3 应用 WHERE 条件，将符合 &lt;where_condition&gt; 条件的行插入到虚拟表 VT4 中。</li>
<li>GROUP BY。根据 &lt;group_by_list&gt; 子句中的条件，对行记录进行分组处理，生成虚拟表 VT5。</li>
<li>WITH。对表 VT5 进行 CUBE 或 ROLLUP 操作，生成虚拟表 VT6。</li>
<li>HAVING。对虚拟表 VT6 的结果应用 HAVING 过滤，将符合 &lt;having_condition&gt; 条件的记录插入到虚拟表 VT7 中。</li>
<li>SELECT。根据 SELECT 中的条件，选出指定的列，生成虚拟表 VT8。</li>
<li>DISTINCT。对虚拟表 VT8 中的条件进行排重，产生虚拟表 VT9。</li>
<li>ORDER BY。对虚拟表 VT9 中的记录，按照 &lt;order_by_condition&gt; 的条件进行排序操作，生成虚拟表 VT10。</li>
<li>LIMIT。最后根据 LIMIT 的条件，取出指定的 LIMIT 区间的行，生成虚拟表 VT11，并将结果返回给用户。</li>
</ol>
<p>因此，我们在进行SQL调优时，要按照SQL语句执行的顺序进行优化，重点处理执行成本比较高的部分：</p>
<ul>
<li>多表JOIN，先看JOIN的条件是否有索引，避免笛卡尔积的产生。</li>
<li>检查WHERE条件的索引是否合理，尽可能缩小结果集的大小。</li>
<li>检查GROUP BY条件上是否有索引，如果没有索引，MySQL会通过临时表来完成GROUP BY操作</li>
<li>检查ORDER BY条件是否有索引，如果没有索引，MySQL会使用排序算法将结果集放入在临时表进行排序</li>
</ul>
<h2 id="查询优化器"><a href="#查询优化器" class="headerlink" title="查询优化器"></a>查询优化器</h2><p>现在的关系型数据库，基本都使用了基于成本的优化器。</p>
<p>现在估算成本的代价就是CPU代价+IO代价。在《数据库查询优化器的艺术》这本书讲到，MySQL数据库在有GROUP BY或者ORDER BY的操作下，没有索引的情况下会先走WHERE然后走GROUP BY和ORDER BY。反过来就是有索引的情况下，查询优化器会先走GROUP BY和ORDER BY再走WHERE。</p>
<p>因为数据库优化器会认为GROUP BY和ORDER BY不走索引的代价会大于WHERE不走索引的代价，所以在有索引的情况下，优化器会先优化给GROUP BY和ORDER BY走索引操作。</p>
<p>再深入的知识就要等你们自己去看书才能慢慢理解到了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>聊了网上的最佳实践有一些不完全对，并且举例说明了它们在某些情况下不正确的事实</li>
<li>SQL执行顺序还有索引优化部分</li>
<li>查询优化器的代价</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL索引</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL索引（一）介绍索引</title>
    <url>/2020/11/10/MySQL%E7%B4%A2%E5%BC%95%EF%BC%88%E4%B8%80-%E4%BB%8B%E7%BB%8D%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>想象一下，你去图书馆找到一本你喜欢看的书，然后你想要快速知道这本书讲了什么内容，有哪些章节，都是通过书开头的“索引”部分，如果想要在一本书中找到某个特定主题，一般会先看书的“索引”，找到对应的页码。</p>
<p>在MySQL中，存储引擎用类似的方法使用索引，其先在索引中找到对应值，然后根据匹配的索引记录找到对应的数据行。接下来就来讲讲MySQL的索引吧。</p>
<a id="more"></a>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p> 索引是应用程序设计和开发的一个重要方面。如果索引太多，应用程序的性能可能会受到影响。而索引太少，对查询性能又会产生影响。要找到一个平衡点，这对于应用程序的性能至关重要。</p>
<p>一些开发程序员总是在开发完之后才想起来添加索引，我一直认为这是一种错误的开发模式。如果知道数据的使用会面临查询的问题，从一开始就应该在需要的地方添加索引。开发人员往往对数据库的使用停留在应用的层面，比如编写SQL语句、存储过程等。他们甚至可能不知道索引的存在，或者认为事后让DBA加上即可。DBA往往不够深入了解业务，而添加索引需要通过监控大量的SQL语句进而从中找到问题，这个步骤所需的时间肯定是远大于初始添加索引所需要的时间，并且可能遗漏一部分的索引。当然索引也并不是越多越好，会占据不必要的磁盘使用率。由此可见添加索引也是非常有技术含量的。</p>
<h2 id="跟索引相关的数据结构"><a href="#跟索引相关的数据结构" class="headerlink" title="跟索引相关的数据结构"></a>跟索引相关的数据结构</h2><h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>二叉搜索树中，左子树的键值总是小于根的键值，右子树的键值总是大于根的键值，并且每个节点最多只有两颗子树，而且最大高度差不超过1。如数据（1，2，3，5，6，7，9）在二叉搜索树的形状：</p>
<p><img src="https://pic1.zhimg.com/80/v2-63bf52e7073fefef0a1a820176607070_1440w.jpg" alt="img"></p>
<p>二叉搜索树查找数据的平均次数：（1 + 2<em>2 + 3</em>4）/ 7=2.4次</p>
<p><strong>解释：查找次数是5只需要查找一次，2和7需要查找2次，1，3，6，9要查找3次。</strong></p>
<p>但是二叉搜索树有一个缺点，每个节点只有两个分支，如果数据量大，需要遍历多层节点才能在叶子节点找到数据。</p>
<h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p>B树可以理解为一个节点拥有多个分支的多叉搜索树。B树中同一个键值不会出现多次，要么在叶子节点上，要么在内节点上。如数据（1，2，3，5，6，7，9）在B树的形状：</p>
<p><img src="https://pic1.zhimg.com/80/v2-4698e656d59587767afb4dfb10aaac30_1440w.jpg" alt="img"></p>
<p>相对较于二叉搜索树，拥有了多分支，减少获取目标值所经历的节点数，提高了效率。</p>
<p>但是B树也是有缺点的。因为每个节点都会包含主键（key）和完整数据值（data），如果data比较大，每一页存储的key会变少；当数据比较多时，同样也会增加树的高度，需要遍历多层才能在叶子节点找到目标值的问题。</p>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>B+树是B树的变体，定义与B树基本一致，与B树不同点：</p>
<ol>
<li>所有叶子节点中包含了全部关键字信息</li>
<li>叶子节点都用指针进行连接</li>
<li>非叶子节点只能存储key信息</li>
</ol>
<p>B+树中的B不是代表二叉（binary）而是代表（balance），B+树不是一个二叉树，而是一颗多查树。</p>
<p><img src="https://pic2.zhimg.com/80/v2-865716cec3d1d80032c8ab30a33b9c81_1440w.jpg" alt="img"></p>
<p>B+树的键一定会出现在叶子节点上，同时也有可能在非叶子节点中重复出现。而B树中的同一键值不会出现多次。</p>
<h2 id="B-索引树"><a href="#B-索引树" class="headerlink" title="B+索引树"></a>B+索引树</h2><p>B+索引树的本质是B+树在数据库中的实现。B+树的高度一般都在2～4层，也就是说查找某一键值的行记录时最多只需要2到4次IO，这个效率就很高。因为当前一般的机械磁盘每秒至少可以做100次IO操作，2～4次的IO意味着查询时间只需要0.02～0.04秒。</p>
<p>数据库中的B+树可以分为聚集索引（clustered index）和辅助索引（secondary index）。但是不管时什么索引，其内部都是B+树，它们两个不同的是，叶子节点存放的是否是一整行的信息。</p>
<p>为了更加理解聚集索引和辅助索引，我们先建一张表。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t3`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"><span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`b`</span> <span class="built_in">char</span>(<span class="number">2</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line"><span class="keyword">KEY</span> <span class="string">`idx_a`</span> (<span class="string">`a`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>  <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br></pre></td></tr></table></figure>
<h2 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h2><p>InnoDB的数据是按照主键顺序存放的，而聚集索引就是按照每张表的主键构造一颗B+树。</p>
<p>InnoDB的主键一定是聚集索引。如果没有主键，聚集索引就可能是第一个不为NULL的唯一索引，也有可能是隐藏的row id。</p>
<p>一般MySQL的查询优化器比较倾向于采用聚集索引，因为聚集索引能够在B+树索引的叶子节点上直接找到数据。</p>
<p>在t3表上查询所有数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t3;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/80/v2-aed7b77f5630e5320b0ee75860d05968_1440w.jpg" alt="img"></p>
<p>这个时候的聚集索引树就是这个样子的：</p>
<p><img src="https://pic2.zhimg.com/80/v2-9e51c10e7e01d94c3568d12f83c179a1_1440w.jpg" alt="img"></p>
<p>根据主键创建了B+树索引；每个叶子节点包含了整行的数据。</p>
<h2 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h2><p>聚集索引的叶子节点存放的是整行数据，而InnoDB存储引擎的辅助索引的叶子节点并不会放整行数据，而是存放键值和主键ID。</p>
<p>当通过辅助索引来查询数据时，InnoDB存储引擎会遍历辅助索引树找到对应记录的主键，然后通过主键去聚集索引树上找到对应的数据。</p>
<p>比如一颗高度为3的辅助索引树查找数据，需要查找3次拿到主键，如果聚集索引树也是高度为3，那么还需要对聚集索引树查找3次才能拿到对应的数据，一共进行了6次IO操作。</p>
<p>辅助索引在t3表是长这个样子的：</p>
<p><img src="https://pic3.zhimg.com/80/v2-21a5b5e66835089855cddeba311a386a_1440w.jpg" alt="img"></p>
<p>根据a字段（idx_a）创建了B+树；每个叶子节点保存的是a字段和主键ID。</p>
<p>通过辅助索引来查找数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t3 <span class="keyword">where</span> a = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>它是先通过a字段的索引树得到主键id为3，然后再到聚集索引树查找对应的数据。</p>
<p>而下面这条SQL：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t3 <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>查询到的结果是一样的。但是它是直接搜索聚集索引树上的数据，比起辅助索引树减少了一次查询。所以，我们应该尽量使用主键作为条件来查询。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>MySQL使用最多的就是B+树索引，而B+树是由B树发展而来，我们需要了解二叉搜索树，B树的一些思想。而后面又解释了InnoDB中B+树索引的两种类型：聚集索引和辅助索引，并解释了它们在MySQL查询过程中的区别。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>《MySQL技术内幕》第2版 第5章 索引与算法</li>
<li>一线大厂的DBA大神经验</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL索引</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL怎么定位慢查询还有分析执行计划</title>
    <url>/2020/11/10/MySQL%E6%80%8E%E4%B9%88%E5%AE%9A%E4%BD%8D%E6%85%A2%E6%9F%A5%E8%AF%A2%E8%BF%98%E6%9C%89%E5%88%86%E6%9E%90%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>大学期间就自学了MySQL数据库，懂得了怎么写简单的SQL查询数据，怎么多表查询。我还一直认为MySQL也不难呀，直到工作了才知道，原来我还是太年轻了～～～</p>
<p>工作期间，写一个简单的CRUD就会碰到上千万的数据量，这个时候简单的select *就会花费大量的时间在查询上，这是不可容忍的。加上我公司的DBA会开启慢查询日志，还有连接接口报警，我才发现只会简单的MySQL是远远不够的，通过看书和学习总结，于是有了这篇博客。</p>
<a id="more"></a>
<h2 id="定位慢查询"><a href="#定位慢查询" class="headerlink" title="定位慢查询"></a>定位慢查询</h2><p>在我实际工作中，碰到某个功能或者接口需要等待很长的时间才响应的话，我们就应该去定位是不是由慢SQL导致的。一般定位慢SQL有两种解决方案：</p>
<ul>
<li>查看慢查询日志确定已经执行完的慢查询</li>
<li>show processlist查看正在执行的慢查询</li>
</ul>
<h2 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h2><p>MySQL的慢查询日志用来记录在MySQL中响应时间超过参数long_query_time（单位秒，默认值10）设置的值并且扫描记录数不小于min_examined_row_limit（默认值0）的语句，能够帮我们找到执行完的慢查询。</p>
<p>首先开启慢查询日志，由参数slow_query_log决定是否开启，开启命令如下：</p>
<p><img src="https://pic3.zhimg.com/80/v2-61a9d6793ab4d2cc187081e270675e3e_1440w.png" alt="img"></p>
<p>默认环境下，慢查询日志是关闭的。</p>
<p>设置慢查询时间阈值：</p>
<p><img src="https://pic3.zhimg.com/80/v2-6e7cb5a8138fd0630e39e20b81e3322e_1440w.png" alt="img"></p>
<p>确定慢查询日志路径，慢查询日志的路径默认是MySQL的数据目录：</p>
<p><img src="https://pic2.zhimg.com/80/v2-10f5cafcd6259cf682ba0649bd7c70a9_1440w.jpg" alt="img"></p>
<p>确定慢查询日志的文件名：</p>
<p><img src="https://pic3.zhimg.com/80/v2-09dfa6d497de29a27c60ad3965486842_1440w.jpg" alt="img"></p>
<p>根据以上查询到的结果可以去打开文件夹查看慢查询日志。</p>
<h2 id="show-processlist"><a href="#show-processlist" class="headerlink" title="show processlist"></a>show processlist</h2><p>有时候一些慢查询已经在执行中，导致数据库负载偏高了，然后这个时候慢查询还没有执行完，这个时候查看慢查询日志是看不到任何结果的。此时可以使用show processlist命令查看正在执行的慢查询。如果由PROCESS权限，则可以看到所有线程。否则，只能看到当前会话的线程。</p>
<p><img src="https://pic1.zhimg.com/80/v2-10b60ecafb7bb43156db935088711ad0_1440w.jpg" alt="img"></p>
<p>time表示时间，info表示正在执行的SQL。通过判断时间可以得知哪些SQL是慢查询。</p>
<h2 id="使用explain分析慢SQL"><a href="#使用explain分析慢SQL" class="headerlink" title="使用explain分析慢SQL"></a>使用explain分析慢SQL</h2><p>分析SQL执行计划是优化SQL的重要手段，通过以上两种方法定位出慢查询语句后，我们可以通过explain来分析慢查询。</p>
<p>explain可以获取到MySQL中SQL语句的执行计划，比如语句是简单查询还是复杂查询，是否使用了索引，扫描行数等等。可以帮我们选择更好的索引。</p>
<p>定位表t1的结构如下所示，并且已经插入了1000条数据在t1表里：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t1`</span> (             </span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> auto_increment,</span><br><span class="line">  <span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`b`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`create_time`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'记录创建时间'</span>,</span><br><span class="line">  <span class="string">`update_time`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'记录更新时间'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_a`</span> (<span class="string">`a`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_b`</span> (<span class="string">`b`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br></pre></td></tr></table></figure>
<p>我们试着用explain来分析一下SQL的执行计划，如下所示：</p>
<p><img src="https://pic4.zhimg.com/80/v2-ded799af1347c84d13998038a0a7bf4b_1440w.png" alt="img"></p>
<p>explain执行后的结果参数如下所示：</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>查询编号</td>
</tr>
<tr>
<td>select_type</td>
<td>查询类型：简单查询或者复杂查询</td>
</tr>
<tr>
<td>table</td>
<td>涉及到的表</td>
</tr>
<tr>
<td>partitions</td>
<td>匹配的分区，仅当使用partition关键字才显示该列</td>
</tr>
<tr>
<td>type</td>
<td>本次查询的表连接类型</td>
</tr>
<tr>
<td>possible_keys</td>
<td>可能用到的索引</td>
</tr>
<tr>
<td>key</td>
<td>实际用到的索引</td>
</tr>
<tr>
<td>key_len</td>
<td>被选择的索引长度</td>
</tr>
<tr>
<td>ref</td>
<td>与索引比较的列</td>
</tr>
<tr>
<td>rows</td>
<td>预计需要扫描的行数，对于InnoDB来说，这个值是一个估值，并不一定准确</td>
</tr>
<tr>
<td>filtered</td>
<td>按条件筛选的行的百分比</td>
</tr>
<tr>
<td>Extra</td>
<td>附加信息</td>
</tr>
</tbody>
</table>
<p>以上是explain对SQL生成的执行计划的参数，其中select_type,type和Extra是非常重要。</p>
<h2 id="select-type各个参数解释"><a href="#select-type各个参数解释" class="headerlink" title="select_type各个参数解释"></a>select_type各个参数解释</h2><table>
<thead>
<tr>
<th>select_type的值</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>SIMPLE</td>
<td>简单查询（不实用关联查询或子查询）</td>
</tr>
<tr>
<td>PRIMARY</td>
<td>如果包含关联查询或者子查询，则最外层的查询部分标记为primary</td>
</tr>
<tr>
<td>UNION</td>
<td>联合查询中第二个及以后的查询</td>
</tr>
<tr>
<td>DEPENDENT UNION</td>
<td>满足依赖外部的关联查询中第二个及以后的查询</td>
</tr>
<tr>
<td>UNION RESULT</td>
<td>联合查询的结果</td>
</tr>
<tr>
<td>SUBQUERY</td>
<td>子查询中的第一个查询</td>
</tr>
<tr>
<td>DEPENDENT SUBQUERY</td>
<td>子查询中的第一个查询，并且依赖外部查询</td>
</tr>
<tr>
<td>DERIVED</td>
<td>用到派生表的查询</td>
</tr>
<tr>
<td>MATERIALIZED</td>
<td>被物化的子查询</td>
</tr>
</tbody>
</table>
<h2 id="type各个参数解释"><a href="#type各个参数解释" class="headerlink" title="type各个参数解释"></a>type各个参数解释</h2><table>
<thead>
<tr>
<th>type的值</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>system</td>
<td>查询对象只有一行数据，且只能用户MyISAM和Memory引擎的表</td>
</tr>
<tr>
<td>const</td>
<td>基于主键或唯一索引查询，最多返回一条结果</td>
</tr>
<tr>
<td>eq_ref</td>
<td>表连接时基于主键或非NULL的唯一索引晚餐扫描</td>
</tr>
<tr>
<td>ref</td>
<td>基于普通索引的等值查询，或者表间等值连接</td>
</tr>
<tr>
<td>fulltest</td>
<td>全文检索</td>
</tr>
<tr>
<td>ref_or_null</td>
<td>表连接类型是ref，但进行扫描的索引列中可能包含NULL值</td>
</tr>
<tr>
<td>index_merge</td>
<td>利用多个索引</td>
</tr>
<tr>
<td>unique_subquery</td>
<td>子查询中使用唯一索引</td>
</tr>
<tr>
<td>index_subquery</td>
<td>子查询中使用普通索引</td>
</tr>
<tr>
<td>range</td>
<td>利用索引进行范围查询</td>
</tr>
<tr>
<td>index</td>
<td>全索引扫描</td>
</tr>
<tr>
<td>ALL</td>
<td>全表扫描</td>
</tr>
</tbody>
</table>
<p>查询性能由上到下越来越差。</p>
<h2 id="Extra各个参数的解释"><a href="#Extra各个参数的解释" class="headerlink" title="Extra各个参数的解释"></a>Extra各个参数的解释</h2><table>
<thead>
<tr>
<th>Extra常见的值</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>Using filesort</td>
<td>用外部排序而不是索引排序，数据较小时从内存排序，否则需要在磁盘排序</td>
</tr>
<tr>
<td>Using temporary</td>
<td>创建一个临时表来存储结构，通过发现对没有索引的列进行GROUP BY时</td>
</tr>
<tr>
<td>Using index</td>
<td>使用覆盖索引</td>
</tr>
<tr>
<td>Using where</td>
<td>使用where语句来处理结果</td>
</tr>
<tr>
<td>Impossible WHERE</td>
<td>对where字句判断的结果总是false而不能选择任何数据</td>
</tr>
<tr>
<td>Using join buffer(Block Nested Loop)</td>
<td>关联查询中，被驱动表的关联字段没索引</td>
</tr>
<tr>
<td>Using index condition</td>
<td>先条件过滤索引，再查数据</td>
</tr>
<tr>
<td>Select tables optimized away</td>
<td>使用某些聚合函数来访问存在索引的某个字段值</td>
</tr>
</tbody>
</table>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>分析了如何定位慢查询</li>
</ol>
<ul>
<li>查看慢查询日志</li>
<li>show process查看正在执行的SQL</li>
</ul>
<p>\2. explain分析慢SQL的参数信息</p>
<p>在工作和面试中，SQL性能优化是我们经常遇到的问题，要想做好性能优化，我们必须学会使用SQL优化时需要的工具，进行定位和分析。相信小伙伴们SQL性能优化时一定可以越来越熟练。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL定位慢SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM必会Java GC，助你过五关斩六将</title>
    <url>/2020/10/08/JVM%E5%BF%85%E4%BC%9AJava-GC%EF%BC%8C%E5%8A%A9%E4%BD%A0%E8%BF%87%E4%BA%94%E5%85%B3%E6%96%A9%E5%85%AD%E5%B0%86/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>都知道《深入理解Java虚拟机》这本书对Java开发是非常重要的，几乎达到了一个必读的重要性。但是在校期间一直看不深入，就停留在最表面的意思，无法深入理解。经历了几个月的码农生活，再次回过头来看这本书的时候，我发现了许多以前不懂的东西都慢慢看懂了，所以借此机会写下这一篇Java GC。</p>
</blockquote>
<a id="more"></a>
<h2 id="Java-GC的目标"><a href="#Java-GC的目标" class="headerlink" title="Java GC的目标"></a>Java GC的目标</h2><p>遇到一个问题或者一个知识点，我们首先要理解和思考为什么要解决这个问题。说到GC的目的是什么呢？显然是回收JVM的内存，因为JVM分配的内存是有限的，随着程序创建的对象越来越多，如果不进行GC的话就会导致内存垃圾越来越多，最后程序崩溃。既然目的是回收垃圾内存，那么新的问题就是，哪些对象可以被回收？什么时候进行回收？怎么回收？</p>
<h2 id="哪些对象可以被回收？"><a href="#哪些对象可以被回收？" class="headerlink" title="哪些对象可以被回收？"></a>哪些对象可以被回收？</h2><p>简单的说就是没有用的对象就可以被回收。那么什么是没有用的对象呢？《深入理解Java虚拟机》给出了两种方法，一种叫引用计数法，一种叫可达性分析法。</p>
<h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p>《深入理解Java虚拟机》中是这样讲的：在对象中添加一个引用计数器，每当有一个地方引用它的时候，计数器值就加一；当引用失效的时候，计数器值就减一；在任何时刻计数器为零的对象就是不可能再被使用的，这个时候会被GC回收。但是这个方法会出现一个问题，就是循环引用问题。比如对象A引用了对象B，但是对象B也引用了对象A，那么这个时候对象A和对象B的引用计数器都不会为0，但是这两个对象都没有被其他对象引用，理论上说是要被GC回收的。</p>
<h2 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a>可达性分析法</h2><p>可达性分析（Reachability Analysis）算法的基本思路就是通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的，这个时候会被GC回收。</p>
<p>一般作为GC Roots的对象包括以下几种：</p>
<ul>
<li>Java栈中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI引用的对象</li>
</ul>
<p>如下图所示，因为从CGRoots作为起点可以找到对象1和对象2，所以对象1和对象2是有用的。对象3和对象4和对象5都没有在GCRoots的链下面，所以此时的对象3，对象4和对象5都是没有用的，会被GC回收。</p>
<p><img src="https://pic3.zhimg.com/80/v2-eda47b7727cb3673ccc56328054bad2e_1440w.jpg" alt="img"></p>
<h2 id="谈谈引用"><a href="#谈谈引用" class="headerlink" title="谈谈引用"></a>谈谈引用</h2><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否引用链可 达，判定对象是否存活都和“引用”离不开关系。在JDK 1.2版之前，Java里面的引用是很传统的定义： 如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称该reference数据是代表 某块内存、某个对象的引用。这种定义并没有什么不对，只是现在看来有些过于狭隘了，一个对象在 这种定义下只有“被引用”或者“未被引用”两种状态，对于描述一些“食之无味，弃之可惜”的对象就显 得无能为力。譬如我们希望能描述一类对象：当内存空间还足够时，能保留在内存之中，如果内存空 间在进行垃圾收集后仍然非常紧张，那就可以抛弃这些对象——很多系统的缓存功能都符合这样的应 用场景。</p>
<p>在JDK 1.2版之后，Java对引用的概念进行了扩充，将引用分为强引用（Strongly Re-ference）、软 引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）4种，这4种引用强 度依次逐渐减弱。</p>
<ul>
<li>强引用是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object obj=new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回 收掉被引用的对象。</li>
<li>软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内 存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存， 才会抛出内存溢出异常。在JDK 1.2版之后提供了SoftReference类来实现软引用。</li>
<li>弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只 能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只 被弱引用关联的对象。在JDK 1.2版之后提供了WeakReference类来实现弱引用。</li>
<li>虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的 存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚 引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2版之后提供 了PhantomReference类来实现虚引用。</li>
</ul>
<h2 id="什么时候回收？"><a href="#什么时候回收？" class="headerlink" title="什么时候回收？"></a>什么时候回收？</h2><p>上面讲了哪些对象会被回收，接下来就来讲什么时候进行垃圾回收呢？在排除人为的调用，垃圾回收都是发现在对新生对象进行内存分配的时候，这个时候如果JVM内存空间不足就会触发GC进行垃圾回收。</p>
<h2 id="怎么回收？"><a href="#怎么回收？" class="headerlink" title="怎么回收？"></a>怎么回收？</h2><p>现在知道了哪些对象可以被回收，什么时候进行回收，现在要解决的就是怎么进行回收了。垃圾回收根据实现的方式不同有多种不同的算法实现。《深入理解Java虚拟机》讲了标记清除算法，复制算法，标记整理算法，分代回收算法等，下面分别一一介绍一下。</p>
<h2 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h2><p>标记清除算法主要分为两步，一步是标记出哪些是垃圾对象，另一步是清除这些被标记的对象。这个算法会出现一个问题就是内存碎片化严重。</p>
<p><img src="https://pic1.zhimg.com/80/v2-070134e55b0b4f1820242d0d771ad4b8_1440w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-b0f1299987720661b75b9265619660dd_1440w.jpg" alt="img"></p>
<p>由上图可以看出来，标记清除算法会导致内存碎片化，可利用率不高。</p>
<h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><p>复制算法就是把内存分为两部分，在平时使用的时候只用其中的固定一部分，在当需要进行GC的时候，把存活的对象复制到另一部分中，然后将已经使用的内存全部清理掉。</p>
<p><img src="https://pic4.zhimg.com/80/v2-272ab960faa3b13c6b7dc62629610f1f_1440w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-f3cad74204ef5ee5ceb48edb728bc4e7_1440w.jpg" alt="img"></p>
<p>复制算法解决了标记清除的碎片化问题，但是很明显的一个问题就是内存使用率大大降低，能使用的内存只有原来的一半。</p>
<h2 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h2><p>标记整理算法是结合了标记清除算法和复制算法。标记阶段和标记清除算法一样，先标记出需要回收的部分，然后把存活的对象往内存的一端进行移动，然后清除剩下的部分。</p>
<p><img src="https://pic4.zhimg.com/80/v2-36d9ed369a726adc55365323c476bc0f_1440w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-e6b42dcb7a40cd18b378cb1e2529376e_1440w.jpg" alt="img"></p>
<p>标记整理算法可以解决上面两个算法的问题，一般应用在老年代，但是整体的效率偏低。</p>
<h2 id="分代回收算法"><a href="#分代回收算法" class="headerlink" title="分代回收算法"></a>分代回收算法</h2><p>分代回收算法是目前使用较多的一种算法，这个不是一个新的算法，而是将内存进行划分，不同区域的内存使用不同的算法。根据对象的存活时间将内存的划分为新生代和老年代，其中新生代分为Eden区和From Survivor区，To Survivor区。在新生代使用的是复制算法，在进行对象内存分配的时候只会使用Eden区和From Survivor区，当发生GC的时候，会将存活的对象复制到To Survivor区，然后循环进行复制。当某个对象进行了15次GC后依旧存活，那么这个对象就会进入老年代。老年代因为每次回收的对象都会特别少，因此使用的是标记整理算法。</p>
<h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><p>讲完了垃圾回收算法，我们再熟悉一下垃圾回收器，这些垃圾回收器都不必全部弄懂，只需要重点关注CMS和G1就可以了。</p>
<ul>
<li>Serial垃圾收集器（单线程，复制算法）</li>
<li>ParNew垃圾收集器（Serial+多线程）</li>
<li>Parallel Scavenge收集器（多线程复制算法，高效）</li>
<li>SerialOld收集器（单线程标记整理算法）</li>
<li>ParallelOld收集器（多线程标记整理算法）</li>
<li>CMS收集器（多线程标记清除算法）</li>
<li>G1收集器</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-3c4c01aa0fa88b64d5dd6b81c07c0c98_1440w.jpg" alt="img"></p>
<p>上图展示了七种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用。上面的垃圾收集器我们只需要重点学习CMS和G1这两款相对复杂而广泛使用的收集器，深入了解它们的部分运作细节即可，感兴趣的可以自行学习。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li>《深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）》</li>
<li><a href="https://link.zhihu.com/?target=https%3A//www.cnblogs.com/jobbible/p/9800222.html" target="_blank" rel="noopener">Java GC机制详解</a></li>
</ol>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis分布式锁背后的原理</title>
    <url>/2020/10/04/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E8%83%8C%E5%90%8E%E7%9A%84%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="什么是分布式锁？"><a href="#什么是分布式锁？" class="headerlink" title="什么是分布式锁？"></a>什么是分布式锁？</h2><blockquote>
<p>分布式锁是控制分布式系统或不同系统之间共同访问共享资源的一种锁实现，如果不同的系统或同一个系统的不同主机之间共享了某个资源时，往往需要互斥来防止彼此干扰来保证一致性。</p>
</blockquote>
<h2 id="分布式锁需要具备哪些条件？"><a href="#分布式锁需要具备哪些条件？" class="headerlink" title="分布式锁需要具备哪些条件？"></a>分布式锁需要具备哪些条件？</h2><ul>
<li>互斥性：在任意一个时刻，只有一个客户端持有锁。</li>
<li>无死锁：即便持有锁的客户端崩溃或者其他意外事件，锁仍然可以被获取。</li>
<li>容错：只要大部分Redis节点都活着，客户端就可以获取和释放锁。</li>
</ul>
<a id="more"></a>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>以前大学照着网上的项目视频做商城的时候，用到Redis。不过基本上都是用来当缓存，但是实际上的应用远不止缓存，所以今天分享一个分布式锁的场景和应用。</p>
<p>在逛商城的时候进行购物支付，基本都是分布式系统，那么用户支付的时候就要上锁，保证不能多线程操作，Redis分布式锁就差不多是这么一个位置：</p>
<p><img src="https://pic1.zhimg.com/80/v2-42199ce58c9489eed7d591ed7e699d10_1440w.jpg" alt="img"></p>
<p>从业务的角度考虑是非常合理的，它保证了查询及插入数据整个流程的原子性，防止查到脏数据，使得支付流程是一个串行化操作。</p>
<p>接下来就来讲一个Redis分布式锁的一个知识点。</p>
<h2 id="为什么要使用分布式锁？"><a href="#为什么要使用分布式锁？" class="headerlink" title="为什么要使用分布式锁？"></a>为什么要使用分布式锁？</h2><p>在实际项目中见过分布式锁后，就不难理解为什么要用分布式锁了。总的来说就是分布式系统要访问共享资源，为了避免并发访问资源带来的错误，我们为共享资源添加一把锁，让各个访问互斥，保证并发访问的安全性，这就是使用分布式锁的原因。</p>
<h2 id="Redis中分布式锁的实现"><a href="#Redis中分布式锁的实现" class="headerlink" title="Redis中分布式锁的实现"></a>Redis中分布式锁的实现</h2><p><strong>命令格式：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SETNX key value</span><br></pre></td></tr></table></figure>
<p>将key的值设为value，当且仅当key不存在。若给定的key已经存在，则SETNX不做任何动作。SETNX是SET if Not eXists的简写。</p>
<p><strong>返回值：</strong></p>
<p>返回整数，具体为</p>
<ul>
<li>1，当key的值被设置</li>
<li>0，当key的值没被设置</li>
</ul>
<p>Redis中使用分布式锁很简单，只要使用setnx指令对某个key上锁就行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setnx lock test //上锁</span><br><span class="line">del lock test //解锁</span><br></pre></td></tr></table></figure>
<p>当然我们还可以在上锁之后使用expire指令给锁设置过期时间。</p>
<p>假如我们的程序不使用指令解锁，靠redis设置时间过期来解锁，貌似会出问题。假如我们的服务进程在执行setnx之后和执行expire指令之前挂掉了，那么这个锁岂不是永远都不会被释放？</p>
<p>没错，这确实是个问题，当时人们在Redis的开源社区提出一堆解决方案专门来解决这个问题，可实现方式都极为复杂。后来Redis的作者在Redis2.8版本中假如了set指令的扩展参数，使得setnx指令和expire指令能够同时执行，具体使用像下面一样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set lock test ex 5 nx</span><br><span class="line">ex：设置键的过期时间</span><br><span class="line">nx：只在键不存在的时候，才对键进行设置操作</span><br></pre></td></tr></table></figure>
<p>从此以后，Redis成为了分布式锁的宠儿。</p>
<h2 id="集群Redis的分布式锁"><a href="#集群Redis的分布式锁" class="headerlink" title="集群Redis的分布式锁"></a>集群Redis的分布式锁</h2><blockquote>
<p>在Redis的分布式环境中，Redis 的作者提供了RedLock 的算法来实现一个分布式锁。</p>
</blockquote>
<p><strong>加锁</strong></p>
<ul>
<li>获取当前Unix时间，以毫秒为单位。</li>
<li>依次尝试从N个实例，使用相同的key和随机值获取锁。在步骤2，当向Redis设置锁时,客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间。例如你的锁自动失效时间为10秒，则超时时间应该在5-50毫秒之间。这样可以避免服务器端Redis已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试另外一个Redis实例。</li>
<li>客户端使用当前时间减去开始获取锁时间（步骤1记录的时间）就得到获取锁使用的时间。当且仅当从大多数（这里是3个节点）的Redis节点都取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功。</li>
<li>如果取到了锁，key的真正有效时间等于有效时间减去获取锁所使用的时间（步骤3计算的结果）。</li>
<li>如果因为某些原因，获取锁失败（没有在至少N/2+1个Redis实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的Redis实例上进行解锁（即便某些Redis实例根本就没有加锁成功）。</li>
</ul>
<p><strong>解锁</strong></p>
<blockquote>
<p>向所有的Redis实例发送释放锁命令即可，不用关心之前有没有从Redis实例成功获取到锁.</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>这次对Redis分布式锁的探索算是加深了自己对Redis的理解，但是Redis的用处远远不止缓存和分布式锁，后面慢慢摸索吧。</p>
</blockquote>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p>1、<a href="https://mp.weixin.qq.com/s/4lvhRIlLsuPw5FEKEt8Fvw" target="_blank" rel="noopener">还不知道 Redis 分布式锁的背后原理？还不赶快学习一下</a></p>
<p>2、<a href="https://blog.csdn.net/oqkdws/article/details/81985699?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param" target="_blank" rel="noopener">基于Redis（setnx）实现分布式锁</a></p>
<p>3、<a href="https://blog.csdn.net/lihao21/article/details/49104695?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.channel_param" target="_blank" rel="noopener">使用Redis SETNX 命令实现分布式锁</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis分布式锁</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis必会知识点总结</title>
    <url>/2020/09/18/Redis%E5%BF%85%E4%BC%9A%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h2><blockquote>
<p>Redis是完全开源的，遵守BSD协议，是一个高性能的key-value数据库。</p>
</blockquote>
<p>Redis与其他key-value缓存产品有以下三个特点：</p>
<ul>
<li>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li>
<li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</li>
<li>Redis支持数据的备份，即master-slave模式的数据备份。</li>
</ul>
<a id="more"></a>
<h2 id="Redis优势"><a href="#Redis优势" class="headerlink" title="Redis优势"></a>Redis优势</h2><ul>
<li>性能极高。Redis读的速度是110000次/s，写的速度是81000次 /s。</li>
<li>丰富的数据类型。Redis支持二进制案例的Strings，Lists，Hashes，Sets及Ordered Sets数据类型操作。</li>
<li>原子。Redis的所有操作都是原子性，意思就是要么成功执行要么失败完成不执行。单个操作是原子性。多个操作也支持事务，即原子性。</li>
<li>丰富的特性。Redis还支持phblish/subscribe，通知，key过期等等特性。</li>
</ul>
<h2 id="Redis与其他key-value存储有什么不同"><a href="#Redis与其他key-value存储有什么不同" class="headerlink" title="Redis与其他key-value存储有什么不同"></a>Redis与其他key-value存储有什么不同</h2><ul>
<li>Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。</li>
<li>Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。</li>
</ul>
<h2 id="Redis常问面试题"><a href="#Redis常问面试题" class="headerlink" title="Redis常问面试题"></a>Redis常问面试题</h2><ol>
<li>Redis支持的数据类型？</li>
<li>什么是Redis持久化？Redis有哪几种持久化方式？优缺点是什么？</li>
<li>Redis有哪些架构模式？讲讲各自的特点</li>
<li>使用过Redis分布式锁吗？它是怎么实现的？</li>
<li>使用过Redis做异步队列吗，你是怎么用的？有什么缺点？</li>
<li>什么是缓存穿透？如何避免？什么是缓存雪崩？如何避免？</li>
<li>Redis常用命令？</li>
<li>为什么Redis单线程却能支撑高并发？</li>
<li>说说Redis的内存淘汰策略？</li>
<li>Redis的并发竞争问题如何解决？</li>
</ol>
<h2 id="答案总结"><a href="#答案总结" class="headerlink" title="答案总结"></a>答案总结</h2><p>答案我做成了xmind图，你们可以保存然后慢慢看。（里面有两个面试题我没有写答案，你们可以多多查阅资料然后补充上去～～～）</p>
<p><a href="https://link.zhihu.com/?target=http%3A//note.youdao.com/s/9fgK9q6X" target="_blank" rel="noopener">有道云笔记note.youdao.com</a></p>
<p>如果阅读完对你有所帮助，给个赞 ～～～</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL的隔离级别</title>
    <url>/2020/08/15/MySQL%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>从校园到企业工作也有一个多月的时间了，经常也是跟MySQL打交道，正好梳理一下MySQL的隔离级别。这个也是面试的时候经常问到的一个知识点，我就来分享一下我的理解。</p>
</blockquote>
<p><strong>PS：MySQL事务都是指在InnoDB引擎下，MyISAM引擎不支持事务。</strong></p>
<a id="more"></a>
<h2 id="事务的ACID特性"><a href="#事务的ACID特性" class="headerlink" title="事务的ACID特性"></a>事务的ACID特性</h2><p>事务都会具有这四种特性：原子性（Atomicity），一致性（Consistency），隔离性（Isolation），持久性（Durability）。简称为ACID特性。</p>
<ol>
<li>原子性。事务是数据库的逻辑工作单位，事务的各操作要么都完成，要么都不完成。</li>
<li>一致性。事务执行的结果必须是使数据库从一个一致性状态变成另一个一致性状态。</li>
<li>隔离性。一个事务的执行不能被其他事务干扰，并发执行的各个事务之间不能互相干扰。</li>
<li>持久性。指一个事务一旦提交，它对数据库中的数据的改变是永久性的。即使机器故障也不会对其执行结果有任何影响。</li>
</ol>
<h2 id="MySQL的四种隔离级别"><a href="#MySQL的四种隔离级别" class="headerlink" title="MySQL的四种隔离级别"></a>MySQL的四种隔离级别</h2><p>SQL标准定义了4种隔离级别，包括了一些具体规则， 用来限定事务内外的哪些改变是可见的，哪些是不可见的。隔离级别低的一般支持更高的并发处理，并且拥有更低的系统开销。</p>
<ol>
<li>读未提交（READ UNCOMMITTED）。在该隔离级别种，所有的事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，容易产生脏读。</li>
<li>读已提交（READ COMMITTED）。这是Oracle数据库默认的隔离级别。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别容易产生不可重复读。</li>
<li>不可重复读（REPEATABLE READ）。这是MySQL的默认隔离级别。它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。但是该隔离级别会产生幻读。</li>
<li>可串行化（SERIALIZABLE）。这是最高的隔离级别，它通过强制事务排序，使之不可能发生冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象。</li>
</ol>
<h2 id="隔离级别产生的问题"><a href="#隔离级别产生的问题" class="headerlink" title="隔离级别产生的问题"></a>隔离级别产生的问题</h2><ul>
<li>脏读。就是某个事务更新了一份数据，但是没有提交事务，在另一个事务就已经看到更新的结果了。比如A事务新增了一条数据没有提交事务，B事务就已经看到A事务新增的数据了。</li>
<li>不可重复读。在一个事务的两次查询中数据不一致。比如A事务新增了一条数据并且提交事务，B事务看到了，然后A事务修改了这条数据，B事务再次查询就看到不一样的结果。</li>
<li>幻读。在一个事务两次查询中数据量不一致。A事务新增了两条数据并且提交事务，B事务查询到两条，这个时候A事务再次新增一条数据并且提交事务，B事务就会看到三条数据。</li>
</ul>
<p><strong>MySQL不同隔离级别有可能产生的问题：</strong></p>
<p><img src="https://pic1.zhimg.com/80/v2-2b657f1362149d0572a2a0730ecc0aa8_720w.jpg" alt="img"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>不同的场景有不同的选择，在选择事务隔离级别上要在效率和问题之间做一个有效的平衡，这一步是要有舍有得。希望这篇事务隔离级别对你们有所帮助。</p>
</blockquote>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL隔离级别</tag>
      </tags>
  </entry>
  <entry>
    <title>Java程序员校招面试——操作系统</title>
    <url>/2020/07/22/Java%E7%A8%8B%E5%BA%8F%E5%91%98%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>现在是2020年7月下旬，应该很多互联网大厂开始了他们的秋招提前批吧。然而很多大四学生要参加提前批的话需要有扎实的数据结构基础和刷算法题的能力之外，到了面试环节，面试官比较喜欢考察计算机网络和操作系统的原理，今天就让我来分享我当初校招遇到的常见操作系统的面试题。</p>
</blockquote>
<a id="more"></a>
<h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><p><strong>1、简单介绍进程和线程以及它们的区别</strong></p>
<ul>
<li>进程是具有一定功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源调度和分配的一个独立单位。</li>
<li>线程是进程的实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。</li>
<li>一个进程可以有多个线程，多个线程也可以并发执行</li>
</ul>
<p>拓展阅读： <a href="https://zhuanlan.zhihu.com/p/106238630" target="_blank" rel="noopener">god-jiang：进程与线程的一个简单解释</a></p>
<p><strong>2、进程有哪几种状态？</strong></p>
<ul>
<li>就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源</li>
<li>运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数</li>
<li>阻塞状态： 进程等待某种条件，在条件满足之前无法执行</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-274d5d5152a725d80599298c103da0e9_720w.jpg" alt="img"></p>
<p><strong>3、进程的通信方式有哪些？</strong></p>
<ul>
<li>管道是一种半双工的通信方式，数据只能单项流动，并且只能在具有亲缘关系的进程间流动，进程的亲缘关系通常是父子进程</li>
<li>命名管道也是半双工的通信方式，它允许无亲缘关系的进程间进行通信</li>
<li>信号量是一个计数器，用来控制多个进程对资源的访问，它通常作为一种锁机制。</li>
<li>消息队列是消息的链表，存放在内核中并由消息队列标识符标识。</li>
<li>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</li>
<li>共享内存就是映射一段能被其它进程访问的内存，这段共享内存由一个进程创建，但是多个进程可以访问。</li>
</ul>
<p><strong>4、线程同步的方式有哪些？</strong></p>
<ul>
<li>互斥量：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。</li>
<li>信号量：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。</li>
<li>事件（信号）：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</li>
</ul>
<p><strong>5、操作系统中进程调度策略有哪几种？</strong></p>
<ul>
<li><strong>先来先服务调度算法：</strong>先来先服务(FCFS)调度算法是一种最简单的调度算法，该算法既可用于作业调度，也可用于进程调度。当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。在进程调度中采用FCFS算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机。</li>
<li><strong>短作业(进程)优先调度算法：</strong>短作业(进程)优先调度算法SJ(P)F，是指对短作业或短进程优先调度的算法。它们可以分别用于作业调度和进程调度。短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先(SPF)调度算法则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。</li>
<li><strong>高优先权优先调度算法</strong>：为了照顾紧迫型作业，使之在进入系统后便获得优先处理，引入了最高优先权优先(FPF)调度算法。此算法常被用于批处理系统中，作为作业调度算法，也作为多种操作系统中的进程调度算法，还可用于实时系统中。当把该算法用于作业调度时，系统将从后备队列中选择若干个优先权最高的作业装入内存</li>
<li><strong>高响应比优先调度算法：</strong>在批处理系统中，短作业优先算法是一种比较好的算法，其主要的不足之处是长作业的运行得不到保证。如果我们能为每个作业引入前面所述的动态优先权，并使作业的优先级随着等待时间的增加而以速率a 提高，则长作业在等待一定的时间后，必然有机会分配到处理机。</li>
<li><strong>时间片轮转法：</strong>在早期的时间片轮转法中，系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把CPU 分配给队首进程，并令其执行一个时间片。时间片的大小从几ms 到几百ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。</li>
<li><strong>多级反馈队列调度算法：</strong>前面介绍的各种用作进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程，而且如果并未指明进程的长度，则短进程优先和基于进程长度的抢占式调度算法都将无法使用。而多级反馈队列调度算法则不必事先知道各种进程所需的执行时间，而且还可以满足各种类型进程的需要，因而它是目前被公认的一种较好的进程调度算法。</li>
</ul>
<p><strong>6、什么是死锁？死锁产生的条件？</strong></p>
<p><strong>什么是死锁：</strong></p>
<p>在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲就是两个或多个进程无限期的阻塞、相互等待的一种状态。</p>
<p><strong>死锁产生的四个必要条件：</strong>（有一个条件不成立，则不会产生死锁）</p>
<ul>
<li>互斥条件：一个资源一次只能被一个进程使用</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放</li>
<li>不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺</li>
<li>循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系</li>
</ul>
<p><strong>7、说一说死锁的处理基本策略和常用方法</strong></p>
<p><strong>预防死锁：</strong></p>
<p><strong>资源一次性分配：</strong>（破坏请求和保持条件）</p>
<p><strong>可剥夺资源：</strong>即当某进程新的资源未满足时，释放已占有的资源（破坏不可剥夺条件）</p>
<p><strong>资源有序分配法：</strong>系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）</p>
<p><strong>避免死锁:</strong></p>
<p>预防死锁的几种策略，会严重地损害系统性能。因此在避免死锁时，要施加较弱的限制，从而获得 较满意的系统性能。由于在避免死锁的策略中，允许进程动态地申请资源。因而，系统在进行资源分配之前预先计算资源分配的安全性。若此次分配不会导致系统进入<a href="https://link.zhihu.com/?target=http%3A//metc.gdut.edu.cn/os/oscai/chapter2/pages/ch29.htm%23%E6%A6%82%E5%BF%B5" target="_blank" rel="noopener">不安全状态</a>，则将资源分配给进程；否则，进程等待。其中最具有代表性的避免死锁算法是银行家算法。</p>
<p><strong>8、分页和分段有什么区别？</strong></p>
<ul>
<li>段是信息的逻辑单位，它是根据用户的需要划分的，因此段对用户是可见的 ；页是信息的物理单位，是为了管理主存的方便而划分的，对用户是透明的。</li>
<li>段的大小不固定，有它所完成的功能决定；页大大小固定，由系统决定</li>
<li>段向用户提供二维地址空间；页向用户提供的是一维地址空间</li>
<li>段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制。</li>
</ul>
<p><strong>9、什么是缓冲区溢出？有什么危害？</strong></p>
<p>缓冲区溢出是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上。</p>
<p>危害有以下两点：</p>
<ul>
<li>程序崩溃，导致拒绝额服务</li>
<li>跳转并且执行一段恶意代码</li>
</ul>
<p>造成缓冲区溢出的主要原因是程序中没有仔细检查用户输入。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>基本上校招操作系统就问这些了，但是大厂问的肯定会更深入，所以这些简单的操作系统面经得全部背熟，然后多看其他相关的书籍或者博客，拓展自己的知识，才能在面试中立于不败之地。</p>
</blockquote>
]]></content>
      <categories>
        <category>校招面试总结</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Java程序员校招面试——计算机网络</title>
    <url>/2020/07/10/Java%E7%A8%8B%E5%BA%8F%E5%91%98%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>现在是2020年7月中旬，应该很多互联网大厂开始了他们的秋招提前批吧。然而很多大四学生要参加提前批的话需要有扎实的数据结构基础和刷算法题的能力之外，到了面试环节，面试官比较喜欢考察计算机网络和操作系统的原理，今天就让我来分享我当初校招遇到的常见计算机网络的面试题。</p>
</blockquote>
<a id="more"></a>
<h2 id="常见的面试题"><a href="#常见的面试题" class="headerlink" title="常见的面试题"></a>常见的面试题</h2><p><strong>1、讲一下TCP的三次握手过程？</strong></p>
<p><img src="https://picb.zhimg.com/80/v2-6d5c8fd979f77dbd6ec54b2d51f90721_720w.jpg" alt="img"></p>
<p>第一次握手：建立连接时，客户端发送syn包（syn=x）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）；</p>
<p>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；</p>
<p>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</p>
<p><strong>2、讲一下TCP的四次挥手？</strong></p>
<p><img src="https://pic4.zhimg.com/80/v2-0cc92c48a269adf565e57e7ecfc1b67d_720w.jpg" alt="img"></p>
<p>1）客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</p>
<p>2）服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</p>
<p>3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</p>
<p>4）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</p>
<p>5）客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</p>
<p>6）服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</p>
<p><strong>3、为什么不能用两次握手进行连接？</strong></p>
<p>3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。</p>
<p>现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。</p>
<p><strong>4、为什么四次挥手的TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</strong></p>
<p>虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。</p>
<p><strong>5、TCP协议如何来保证传输的可靠性？</strong></p>
<p>数据包校验：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据端超时后会重发数据；</p>
<p>对失序数据包重排序：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层；</p>
<p>丢弃重复数据：对于重复数据，能够丢弃重复数据；</p>
<p>应答机制：当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；</p>
<p>超时重发：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；</p>
<p>流量控制：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。</p>
<p><strong>6、TCP的流量控制和拥塞控制。（主要讲拥塞控制）</strong></p>
<p>TCP协议有两个比较重要的控制算法，一个是<strong>流量控制</strong>，另一个是<strong>拥塞控制</strong>。</p>
<p>TCP协议通过滑动窗口来进行流量控制，它是控制发送方的发送速度从而使接收者来得及接收并处理。而拥塞控制是作用于网络，它是防止过多的包被发送到网络中，避免出现网络负载过大、网络拥塞的情况。</p>
<p>拥塞控制主要有四个算法，分别为<strong>慢启动</strong>、<strong>拥塞避免</strong>、<strong>快重传</strong>和<strong>快恢复算法</strong>。</p>
<p><img src="https://pic4.zhimg.com/80/v2-8bc172528b2b57de2677d6260d8b7de3_720w.jpg" alt="img"></p>
<p><strong>慢开始：</strong>当发送方每收到一个ACK，拥塞窗口cwnd的大小就会翻倍，就是2的n次幂递增。可以看到指数级增长。一般遵循以下判定：</p>
<ul>
<li>cwnd &lt; ssthresh，继续使用慢开始算法；</li>
<li>cwnd &lt; ssthresh，停止使用慢开始算法，改用拥塞避免算法；</li>
<li>cwnd = ssthresh，即可使用慢开始算法，也可以使用拥塞避免算法。</li>
</ul>
<p><strong>拥塞避免：</strong>当拥塞窗口cwnd超过慢启动门限ssthresh就会进入拥塞避免算法。</p>
<ul>
<li>加法增大：每经过一个往返时间RTT（Round-TripTime），拥塞窗口+1，让拥塞窗口缓慢增大，按照线性规律增长。</li>
<li>乘法减小：当出现网络拥塞，比如丢包时，将慢开始门限（ssthresh）设为原先的一半，然后将cwnd设为1，执行慢开始算法（较低的起点，指数级增长）。</li>
</ul>
<p><strong>快重传和快恢复：</strong>为了减少因为拥塞导致的数据包丢失带来的重传时间，快重传的机制是：</p>
<ul>
<li>接收方如果一个包丢失，则对后续的包继续发送针对该包的重传请求；</li>
<li>一旦发送方接收到三个一样的确认，就知道该包之后出现了错误，立刻重传该包；</li>
<li>此时发送方开始执行“快恢复”算法；</li>
<li>慢开始门限减半；</li>
<li>cwnd设为慢开始门限减半后的数量；</li>
<li>执行拥塞避免算法（高起点，线性增长）；</li>
</ul>
<p><strong>7、简述计算机网络中的七层模型。</strong></p>
<p><img src="https://pic1.zhimg.com/80/v2-cb4fc1b384f9b2b14fee4db42360fcfd_720w.jpg" alt="img"></p>
<p>物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）</p>
<p>数据链路层：将比特组装成帧和点到点的传递（帧Frame）</p>
<p>网络层：负责数据包从源到宿的传递和网际互连（包PackeT）</p>
<p>传输层：提供端到端的可靠报文传递和错误恢复（段Segment）</p>
<p>会话层：建立、管理和终止会话（会话协议数据单元SPDU）</p>
<p>表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）</p>
<p>应用层：允许访问OSI环境的手段（应用协议数据单元APDU）</p>
<p><strong>8、网络层的ARP协议工作原理。</strong></p>
<p>网络层的ARP协议完成了IP地址与物理地址的映射。首先，每台主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址的对应关系。当源主机需要将一个数据包要发送到目的主机时，会首先检查自己ARP列表中是否存在该IP地址对应的MAC地址：如果有，就直接将数据包发送到这个MAC地址；如果没有，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的MAC地址。此ARP请求数据包里包括源主机的IP地址、硬件地址、以及目的主机的IP地址。网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个ARP响应数据包，告诉对方自己是它需要查找的MAC地址；源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。</p>
<p><strong>9、简单介绍一下HTTP的长连接和短连接。</strong></p>
<p>HTTP的长连接和短连接本质上是TCP长连接和短连接。HTTP属于应用层协议。</p>
<p><strong>短连接:</strong></p>
<p>浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。</p>
<p><strong>长连接:</strong></p>
<p>当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的 TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接要客户端和服务端都支持长连接。</p>
<p><strong>10、TCP和UDP有什么区别？</strong></p>
<p>（1）TCP提供的是面向连接的、可靠的数据流传输；UDP提供的是非面向连接的、不可靠的数据流传输。</p>
<p>（2）TCP提供可靠的服务，通过TCP连接传送的数据，无差错、不丢失，不重复，按序到达；UDP尽最大努力交付，即不保证可靠交付。</p>
<p>（3）TCP面向字节流；UDP面向报文。</p>
<p>（4）TCP连接只能是点到点的；UDP支持一对一、一对多、多对一和多对多的交互通信。</p>
<p>（5）TCP首部开销20字节；UDP的首部开销小，只有8个字节。</p>
<p>（6）TCP的逻辑通信信道是全双工的可靠信道；UDP的逻辑通信信道是不可靠信道。</p>
<p><strong>11、常见的HTTP状态码有哪些？</strong></p>
<p><strong>2开头 （请求成功）表示成功处理了请求的状态代码。</strong></p>
<p>200 （成功） 服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。 201 （已创建） 请求成功并且服务器创建了新的资源。 202 （已接受） 服务器已接受请求，但尚未处理。 203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。 204 （无内容） 服务器成功处理了请求，但没有返回任何内容。 205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。 206 （部分内容） 服务器成功处理了部分 GET 请求。</p>
<p><strong>3开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。</strong></p>
<p>300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。 302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。 304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。 307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</p>
<p><strong>4开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。</strong></p>
<p>400 （错误请求） 服务器不理解请求的语法。 401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 403 （禁止） 服务器拒绝请求。 404 （未找到） 服务器找不到请求的网页。 405 （方法禁用） 禁用请求中指定的方法。 406 （不接受） 无法使用请求的内容特性响应请求的网页。 407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。 408 （请求超时） 服务器等候请求时发生超时。 409 （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。 411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。 412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。 413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。 415 （不支持的媒体类型） 请求的格式不受请求页面的支持。 416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。 417 （未满足期望值） 服务器未满足”期望”请求标头字段的要求。</p>
<p><strong>5开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。</strong></p>
<p>500 （服务器内部错误） 服务器遇到错误，无法完成请求。 501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。 502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。 503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。 504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。 505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。</p>
<p><strong>12、Post和Get有什么区别？</strong></p>
<p>GET主要用于从服务器查询数据，POST用于向服务器提交数据；</p>
<p>GET通过URL传递数据，POST通过http请求体传递数据；</p>
<p>GET传输数据量有限制，不能大于2kb，POST传递的数据量较大，一般大量的数据提交都是通过POST方式；</p>
<p>GET安全性较低，容易在URL中暴漏数据，POST安全性较高。</p>
<p><strong>13、在浏览器中输入<a href="https://link.zhihu.com/?target=http%3A//www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a>后执行的全部过程。</strong></p>
<p>该答案有多种版本，建议自己百度选择一个适合自己的版本记下来就可以了。</p>
<p><strong>14、cookie 和session 有什么区别？</strong></p>
<p>cookie数据存放在客户的浏览器上，session数据放在服务器上；</p>
<p>cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当使用session；</p>
<p>session会在一定时间内保存在服务器上。当访问增多，会比较占用服务器的性能考虑到减轻服务器性能方面，应当使用COOKIE；</p>
<p>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie；</p>
<p>建议：将登陆信息等重要信息存放为SESSION；其他信息如果需要保留，可以放在COOKIE中。</p>
<p><strong>15、HTTP和HTTPS的区别。</strong></p>
<ul>
<li><strong>工作层：</strong>在OSI网络模型中，HTTP工作于<strong>应用层</strong>，而HTTPS工作在<strong>传输层</strong>。</li>
<li><strong>连接端口：</strong>HTTP标准端口为80，而HTTPS标准端口为443。</li>
<li><strong>传输方式：</strong>HTTP是超文本传输协议，信息是明文传输，而HTTPS是SSL加密传输协议。</li>
<li><strong>工作耗时：</strong>HTTP耗时=TCP握手，而HTTPS耗时=TCP握手+SSL握手。</li>
<li><strong>显示形式：</strong>HTTP的URL以http://开头，而HTTPS的URL以https://开头。</li>
<li><strong>费用：</strong>HTTP无需费用，而HTTPS需要到CA申请证书，一般免费证书较少，需要一定费用。</li>
<li><strong>安全性：</strong>HTTP的连接简单，是无状态的；而HTTPS是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP协议安全。</li>
</ul>
<p><strong>16、列举几种常见的协议，并简述他们的作用。</strong></p>
<p>ICMP协议：因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。</p>
<p>TFTP协议：是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。</p>
<p>HTTP协议：超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。</p>
<p>DHCP协议：动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段。</p>
<p>NAT协议：网络地址转换属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术，</p>
<p>DHCP协议：一个局域网的网络协议，使用UDP协议工作，用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>基本上校招常见的一些计算机网络的面试题就是这些了，但是有一些大厂会问得比较深入，比如DDOS攻击，网站的安全性问题怎么解决，TCP粘包拆包问题等等。这些常见面试题可以熟记，但是也要多看看相关的书籍和博客巩固自己的基础，才能让自己在面试中立于不败之地。</p>
</blockquote>
<p><strong>PS：大概常见的面试题我就记住这么多，以后有别的我再补充。</strong></p>
<p><strong>（version1.1）更新于2020年7月11日上午11点13分。</strong></p>
]]></content>
      <categories>
        <category>校招面试总结</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring（二）</title>
    <url>/2020/05/05/Spring%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>我相信只要是学Java的，都有接触到Spring框架。然后Spring框架最核心的就是IOC（控制反转）和AOP（面向切面编程）。出去找工作，面试官看到你简历上写着熟悉Spring，基本都会问IOC和AOP，今天就来记录一下这两个东西吧。</p>
</blockquote>
<a id="more"></a>
<h2 id="IOC介绍"><a href="#IOC介绍" class="headerlink" title="IOC介绍"></a>IOC介绍</h2><p><strong>IOC容器：</strong>它是一个具有依赖注入功能的容器，可以创建对象。IOC容器负责在应用程序中实例化、定位和配置对象，并在这些对象之间建立依赖关系。通常，new实例的控制由程序员控制，“控制反转”意味着new实例的工作不是由程序员完成的，而是由spring容器完成的。在Spring中，beanfactory是IOC容器的实际代表。</p>
<p><strong>DI（依赖注入Dependency injection）：</strong>依赖注入和控制反转是同一个概念，具体的讲：当某个角色需要另一个角色协助的时候，在传统的程序设计过程中，通常由调用者来创建被调用者的实例。但在spring中创建被调用者得工作不再由调用者来完成，因此称为控制翻转。创建被调用者的工作由spring来完成，然后注入调用者。</p>
<p><strong>依赖注入的四种方式：</strong></p>
<ol>
<li>接口注入</li>
<li>setter注入</li>
<li>构造方法注入</li>
<li>注解注入</li>
</ol>
<p><strong>ps：有兴趣可以自己学习一下，这里就一笔带过了。</strong></p>
<h2 id="AOP介绍"><a href="#AOP介绍" class="headerlink" title="AOP介绍"></a>AOP介绍</h2><p>​    面向切面编程（AOP）是对面向对象编程（OOP）的补充，面向对象编程将程序分解成各个层次的对象，面向切面编程将程序运行过程分解成各个切面。AOP从程序运行角度考虑程序的结构，提取业务处理过程的切面，OOP是静态的抽象，AOP是动态的抽象，是对应用执行过程中的步骤进行抽象，从而获得步骤之间的逻辑划分。</p>
<p>​    Spring框架的AOP机制可以让开发者把业务流程中的通用功能抽取出来，单独编写功能代码。在业务流程执行过程中，Spring框架会根据业务流程要求，自动把独立编写的功能代码切入到流程的合适位置。</p>
<h2 id="AOP底层实现"><a href="#AOP底层实现" class="headerlink" title="AOP底层实现"></a>AOP底层实现</h2><p>​    首先，我们知道Spring AOP的底层实现有两种方式：一种是JDK动态代理，另一种是CGLib的方式。</p>
<p>​    JDK动态代理主要涉及到java.lang.reflect包下边的两个类：Proxy和InvocationHandler。其中，InvocationHandler是一个接口，可以通过实现该接口定义横切逻辑，并通过反射机制条用目标类的代码，动态地将横切逻辑和业务逻辑连接在一起。</p>
<p>​    CGLib采用底层的字节码技术，全称是：Code Generation Libarary，CGLib可以为一个类创建一个子类，在子类中采用方法拦截的技术拦截所有父类方法的调用并顺势织入横切逻辑。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>IOC就是控制反转，把new对象的控制权交给了Spring容器。而AOP就是把通用的业务逻辑抽取出来，然后根据业务流程动态插入到流程的合适位置。</p>
</blockquote>
]]></content>
      <categories>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring（一）</title>
    <url>/2020/04/27/Spring%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="1、Spring的历史简介"><a href="#1、Spring的历史简介" class="headerlink" title="1、Spring的历史简介"></a>1、Spring的历史简介</h2><ul>
<li>Spring：翻译成春天，代表给软件行业带来了春天~</li>
<li>2002年，首次推出了Spring框架的雏形：interface21框架~</li>
<li>Spring框架即以interface21框架为基础，经过重新设计，并不断丰富其内涵，于2004年3月24日发布了1.0正式版~</li>
<li><strong>Rod Johnson</strong>，Spring Framework创始人，著名作者。很难想象Rod Johnson的学历，真的让好多人大吃一惊，他是悉尼大学的博士，然而他的专业不是计算机，而是音乐学~</li>
<li>Spring理念：使现有的技术更加容易使用，本身是一个大杂烩，整合了现有的技术框架~</li>
</ul>
<a id="more"></a>
<p><strong>从以前的SSH到现在的SSM都需要Spring来整合，因为Spring框架就是一个大杂烩，用来解放程序员的。</strong></p>
<ul>
<li>SSH：Struct2 + Spring + Hibernate</li>
<li>SSM：SpringMVC + Spring + Mybatis</li>
</ul>
<h2 id="2、Spring的优点"><a href="#2、Spring的优点" class="headerlink" title="2、Spring的优点"></a>2、Spring的优点</h2><ul>
<li>Spring是一个开源免费的框架（容器）~</li>
<li>Spring是一个轻量级的、非侵入式的框架~</li>
<li>控制反转（IOC），面向切面编程（AOP）~</li>
<li>支持事务的处理，对框架整合的支持~</li>
</ul>
<p><strong>总结一句话：Spring就是一个轻量级的控制反转（IOC）和面向切面编程（AOP）的框架~</strong></p>
<h2 id="3、Spring的七大模块"><a href="#3、Spring的七大模块" class="headerlink" title="3、Spring的七大模块"></a>3、Spring的七大模块</h2><p><img src="https://pic2.zhimg.com/80/v2-6219164646cd5a15e162d8ff1debf3fd_720w.jpg" alt="img"></p>
<p><strong>核心容器(Spring core)</strong></p>
<p>核心容器提供Spring框架的基本功能。Spring以bean的方式组织和管理Java应用中的各个组件及其关系。Spring使用BeanFactory来产生和管理Bean，它是工厂模式的实现。BeanFactory使用控制反转(IoC)模式将应用的配置和依赖性规范与实际的应用程序代码分开。BeanFactory使用依赖注入的方式提供给组件依赖。</p>
<p><strong>Spring上下文(Spring context)</strong></p>
<p>Spring上下文是一个配置文件，向Spring框架提供上下文信息。Spring上下文包括企业服务，如JNDI、EJB、电子邮件、国际化、校验和调度功能。</p>
<p><strong>Spring面向切面编程(Spring AOP)</strong></p>
<p>通过配置管理特性，Spring AOP 模块直接将面向方面的编程功能集成到了 Spring框架中。所以，可以很容易地使 Spring框架管理的任何对象支持 AOP。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。</p>
<p><strong>Spring DAO模块</strong></p>
<p>DAO模式主要目的是将持久层相关问题与一般的的业务规则和工作流隔离开来。Spring 中的DAO提供一致的方式访问数据库，不管采用何种持久化技术，Spring都提供一直的编程模型。Spring还对不同的持久层技术提供一致的DAO方式的异常层次结构。</p>
<p><strong>Spring ORM模块</strong></p>
<p>Spring 与所有的主要的ORM映射框架都集成的很好，包括Hibernate、JDO实现、TopLink和IBatis SQL Map等。Spring为所有的这些框架提供了模板之类的辅助类，达成了一致的编程风格。</p>
<p><strong>Spring Web模块</strong></p>
<p>Web上下文模块建立在应用程序上下文模块之上，为基于Web的应用程序提供了上下文。Web层使用Web层框架，可选的，可以是Spring自己的MVC框架，或者提供的Web框架，如Struts、Webwork、tapestry和jsf。</p>
<p><strong>Spring MVC框架(Spring WebMVC)</strong></p>
<p>MVC框架是一个全功能的构建Web应用程序的MVC实现。通过策略接口，MVC框架变成为高度可配置的。Spring的MVC框架提供清晰的角色划分：控制器、验证器、命令对象、表单对象和模型对象、分发器、处理器映射和视图解析器。Spring支持多种视图技术。</p>
<h2 id="4、Spring的拓展"><a href="#4、Spring的拓展" class="headerlink" title="4、Spring的拓展"></a>4、Spring的拓展</h2><p>在Spring的官网介绍：现代化的Java开发！说白了就是基于Spring的开发！</p>
<p><img src="https://pic2.zhimg.com/80/v2-f79ce65e11b0d34113369ae8d7ca1f71_720w.jpg" alt="img"></p>
<ul>
<li><p>Spring Boot</p>
</li>
<li><ul>
<li>一个快速开发的脚手架。</li>
<li>基于SpringBoot可以快速的开发单个微服务。</li>
<li>约定大于配置。</li>
</ul>
</li>
<li><p>Spring Cloud</p>
</li>
<li><ul>
<li>SpringCloud是基于SpringBoot实现的。</li>
</ul>
</li>
</ul>
<p><strong>今天的Spring就介绍到这里，下次来详细讲一下控制反转（IOC）和面向切面编程（AOP）。</strong></p>
]]></content>
      <categories>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>String源码粗略解读</title>
    <url>/2020/04/15/String%E6%BA%90%E7%A0%81%E7%B2%97%E7%95%A5%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>基本上只要是Java程序员，就肯定会接触过String类。博主我是大三参加蓝桥杯比赛才学会用String类的charAt（），length（），toString（）等等常用函数。所以今天有时间来看看String的源码，分析一下我们常用的方法在源码层面是什么样子的。</p>
</blockquote>
<a id="more"></a>
<h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><p><img src="https://pic1.zhimg.com/80/v2-c4d5017b5eeeda1d234b33e3da017b04_720w.jpg" alt="img"></p>
<p>源码中String类是用final关键字修饰的，表示String类是一个不可变的类。然后String类实现了Serializable、Comparable、CharSequence接口。它们分别有什么作用呢？</p>
<ol>
<li><strong>Serializable接口，表示这个类是能够被序列化的，便于在网络中传输和保存。</strong></li>
<li><strong>Comparable接口，里面只有一个compareTo方法，这个是用来进行排序的，如果返回-1，则当前对象排在前面；如果返回1，则当前对象排在后面；返回0，则表示相等。</strong></li>
<li><strong>CharSequence接口，里面就是定义一些常用的方法，如charAt（int），length（），toString（）等。</strong></li>
</ol>
<h2 id="String的定义变量"><a href="#String的定义变量" class="headerlink" title="String的定义变量"></a>String的定义变量</h2><p><img src="https://pic4.zhimg.com/80/v2-9f45b43bb6fd1e60e16ee6fb6d27c0db_720w.jpg" alt="img"></p>
<p>从构造函数可以看出来，其实String类的底层是char类型的数组。然后String类还会把对应的hash值记录下来。这就是为什么HashMap比较喜欢用String类做为key的原因。因为String类会hashcode缓存下来，不用多一步计算它的hash值。</p>
<ol>
<li><strong>value[]表示是String的底层用的是char类型的数组。</strong></li>
<li><strong>hash表示变量的hash值，用hash来记录下来。</strong></li>
<li><strong>serialVersionUID表示序列化机制，用来验证版本的一致性。</strong></li>
</ol>
<h2 id="equal（Object）方法"><a href="#equal（Object）方法" class="headerlink" title="equal（Object）方法"></a>equal（Object）方法</h2><p><img src="https://pic3.zhimg.com/v2-5d66762b148bb1439243be8b7f72998e_r.jpg" alt="preview"></p>
<p>String类重写了equal（）方法，因为Object类原始的equal（）方法是“==”。String类的equal（）方法就是判断是不是同一个类型，如果是，则对比它们的长度，如果相等，则对比它们的字符。<strong>简单来说，就是判断两个字符串的值是否一样。</strong></p>
<h2 id="hashCode（）方法"><a href="#hashCode（）方法" class="headerlink" title="hashCode（）方法"></a>hashCode（）方法</h2><p><img src="https://pic2.zhimg.com/80/v2-2feee68934700e449dbb4ca937f344d1_720w.jpg" alt="img"></p>
<p>String类的hashCode（）方法就是hash值乘以31然后加每位的值。然而即使你的hash函数设计得再好，也是会产生hash碰撞。<strong>所以一般两个字符串的hashcode相等并不代表它们相等，还需要判断它们是否equal（）相等才可以。</strong></p>
<h2 id="toString（）方法"><a href="#toString（）方法" class="headerlink" title="toString（）方法"></a>toString（）方法</h2><p><img src="https://pic1.zhimg.com/80/v2-79f25f4860dfea33718aace9245b04c4_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/v2-0de4c1c509999dbe8fcdc415187164ea_r.jpg" alt="preview"></p>
<p>toString（）用的就是Object类的toString（）方法。<strong>就是返回一个类名+@+hashCode的16进制的数字的字符串。</strong></p>
<h2 id="intern（）方法"><a href="#intern（）方法" class="headerlink" title="intern（）方法"></a>intern（）方法</h2><p><img src="https://pic1.zhimg.com/80/v2-7706884725439c846330a7f0e9203b84_720w.jpg" alt="img"></p>
<p>String类的intern（）方法是native的。就是本地方法，<strong>该方法的实现由非Java语言实现，比如C、C++。这个特征并非Java所持有，很多其它的编程语言都有这一个机制。</strong></p>
<p><strong>intern（）方法的用途是当前的字符对象（通过new出来的对象）可以使用intern方法从常量池中获取，如果常量池中不存在该字符串，那么就会新建一个新的字符串放到常量池中。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/15  14:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">"god-jiang"</span>;</span><br><span class="line">        String str2 = <span class="keyword">new</span> String(<span class="string">"god-jiang"</span>);</span><br><span class="line">        String str3 = <span class="keyword">new</span> String(<span class="string">"god-jiang"</span>).intern();</span><br><span class="line"></span><br><span class="line">        System.out.println(str1 == str2); <span class="comment">//false</span></span><br><span class="line">        System.out.println(str1 == str3); <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>String类还是有很多常用的函数我没有全部说到，比如isEmpty（），indexOf（），substring（），concat（）等等。我就写了一些比较浅的源码解读，其他的方法也写得很不错，如果你们感兴趣可以多去看看源码，这样可以增加你的知识。</p>
</blockquote>
]]></content>
      <categories>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>String源码</tag>
      </tags>
  </entry>
  <entry>
    <title>ArrayList源码粗略解读（面试必问）</title>
    <url>/2020/04/03/ArrayList%E6%BA%90%E7%A0%81%E7%B2%97%E7%95%A5%E8%A7%A3%E8%AF%BB%EF%BC%88%E9%9D%A2%E8%AF%95%E5%BF%85%E9%97%AE%EF%BC%89/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>现如今的Java程序员越来越多，学习者也越来越多。基本上使用Java的都会使用过HashSet、HashMap、ArrayList、LinkedList等集合，今天god-jiang就从源码层面上粗略解读一下ArrayList这个常用集合。</p>
</blockquote>
<a id="more"></a>
<p><strong>若是有写得不好的地方或者有错误，请读者提出，毕竟我也是一名菜鸡。</strong></p>
<h2 id="1、ArrayList的介绍"><a href="#1、ArrayList的介绍" class="headerlink" title="1、ArrayList的介绍"></a><strong>1、ArrayList的介绍</strong></h2><blockquote>
<p>ArrayList是一个容量能够动态增长的动态数组。但是它和数组又不一样，它继承了AbstractList，实现了List、RandomAccess（随机访问）、Cloneable、Serializable接口。</p>
</blockquote>
<h2 id="2、ArrayList的构造函数"><a href="#2、ArrayList的构造函数" class="headerlink" title="2、ArrayList的构造函数"></a><strong>2、ArrayList的构造函数</strong></h2><p>在JDK1.8的版本下，ArrayList有三个构造函数。分别是：</p>
<ul>
<li><strong>ArrayList()：构造一个初始容量为10的空数组列表</strong></li>
<li><strong>ArrayList(int initialCapacity)：构造一个具有初始容量值的空数组列表</strong></li>
<li><strong>ArrayList(Collection c)：构造一个包含指定元素的数组列表</strong></li>
</ul>
<p>源码如下：</p>
<p><img src="https://pic3.zhimg.com/80/v2-cd48d01d46cf3a8ce129171ee05b00aa_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-42b7ac5482c43ead09737c876d7734d0_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-34ef99c6f234e0110c254409a8382fd9_720w.jpg" alt="img"></p>
<h2 id="3、ArrayList的add操作"><a href="#3、ArrayList的add操作" class="headerlink" title="3、ArrayList的add操作"></a>3、ArrayList的add操作</h2><p>在JDK1.8的版本里，add操作有两种，一种是按顺序一直添加，另一种是给定一个位置再添加。源码如下：</p>
<p><img src="https://pic1.zhimg.com/80/v2-c961c7f58cf634a486a60381836a241c_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-b0a808405c6ac2a81171ddc0aed854ab_720w.jpg" alt="img"></p>
<p><strong>就是进行add操作的时候，需要先进行ensureCapacityInternal操作，就是size+1判断是否需要扩容了，如果不需要，则直接插入，然后size++。如果需要扩容，就会扩容到原来的1.5倍，源码如下：</strong></p>
<p><img src="https://pic1.zhimg.com/80/v2-ae2bc676b0d1b2eadaa08c8bb9082128_720w.jpg" alt="img"></p>
<h2 id="4、ArrayList的遍历方式"><a href="#4、ArrayList的遍历方式" class="headerlink" title="4、ArrayList的遍历方式"></a>4、ArrayList的遍历方式</h2><p>给出ArrayList遍历常用的三种方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/3  14:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList_Resource</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">"李白"</span>);</span><br><span class="line">        list.add(<span class="string">"露娜"</span>);</span><br><span class="line">        list.add(<span class="string">"韩信"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、迭代器</span></span><br><span class="line">        Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"================"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、for</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"================"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、for-each</span></span><br><span class="line">        <span class="keyword">for</span> (String str : list) &#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>肯定会有人问用哪个比较好，这里我只能说<strong>博主经常使用的是第二种遍历方式，因为效率最高</strong>。为啥效率最高，可以自己加入系统时间算时间差来比较得出。</p>
<h2 id="5、ArrayList和LinkedList的区别（面试常问）"><a href="#5、ArrayList和LinkedList的区别（面试常问）" class="headerlink" title="5、ArrayList和LinkedList的区别（面试常问）"></a>5、ArrayList和LinkedList的区别（面试常问）</h2><ol>
<li><strong>是否保证线程安全</strong>：ArrayList和LinkedList都是不同步的，也就是不保证线程安全；</li>
<li><strong>底层数据结构</strong>：ArrayList底层使用的是Object数组；LinkedList底层使用的是双向链表；</li>
<li><strong>插入和删除是否受元素位置影响</strong>：ArrayList采用数组存储，所以插入和删除元素的时间复杂度受元素的位置影响，为O(N)。LinkedList采用链表存储，所以插入和删除元素的时间复杂度不受元素位置的影响，为O(1)；</li>
<li><strong>是否支持快速随机访问</strong>：LinkedList不支持高速的随机元素访问，而ArrayList支持；</li>
<li><strong>内存空间占用</strong>：ArrayList的空间浪费主要体现在List列表的结尾会预留一定的容量空间，而LinkedList得空间花费体现在它得每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接前驱和后继以及数据等）。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>今天的ArrayList源码就讲这么多，还有一些remove操作和contains操作我就没有写出来，不是说它们不重要，而是我把相对重要和常问的点拿出来讲一下。对ArrayList其他操作感兴趣可以自己看看源码，这个东西对你只会有好处而不会有坏处。</p>
</blockquote>
<p><strong>谢谢大家，有错误或者写得不好的欢迎评论区评论或者私聊。</strong></p>
]]></content>
      <categories>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>ArrayList源码</tag>
      </tags>
  </entry>
  <entry>
    <title>排列组合的模板算法</title>
    <url>/2020/03/23/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E7%9A%84%E6%A8%A1%E6%9D%BF%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="排列组合（百度百科）"><a href="#排列组合（百度百科）" class="headerlink" title="排列组合（百度百科）"></a>排列组合（百度百科）</h2><blockquote>
<p>排列组合是组合学最基本的概念。所谓排列，就是指从给定个数的元素中取出指定个数的元素进行排序。组合则是指从给定个数的元素仅仅取出指定个数的元素，不考虑排序。排列组合的中心问题是研究给定要求的排列和组合可能出现的情况总数。排列组合与古典概率论关系密切。</p>
</blockquote>
<a id="more"></a>
<h2 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//abc的排列</span><br><span class="line">abc  acb  bac  bca  cba  cab</span><br><span class="line">共有6种排序</span><br><span class="line"></span><br><span class="line">//abc的组合</span><br><span class="line">3取3的可能：abc</span><br><span class="line">3取2的可能：ab  ac  bc</span><br><span class="line">3取1的可能：a  b  c</span><br></pre></td></tr></table></figure>
<h2 id="排列模板代码"><a href="#排列模板代码" class="headerlink" title="排列模板代码"></a>排列模板代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/3/23  14:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Permutation</span> </span>&#123;</span><br><span class="line">    <span class="comment">//全排列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">perm</span><span class="params">(<span class="keyword">char</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == len - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                System.out.print(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; len; i++) &#123;</span><br><span class="line">                swap(arr, start, i);</span><br><span class="line">                perm(arr, start + <span class="number">1</span>, len);</span><br><span class="line">                swap(arr, start, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换两个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] arr = <span class="string">"abc"</span>.toCharArray();</span><br><span class="line">        perm(arr, <span class="number">0</span>, arr.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/80/v2-77719ddaedea6854ac906cbaaa7b4454_720w.jpg" alt="img"></p>
<hr>
<h2 id="组合模板代码"><a href="#组合模板代码" class="headerlink" title="组合模板代码"></a>组合模板代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/3/23  14:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Combination</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[] input, <span class="keyword">char</span>[] output, <span class="keyword">int</span> index, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == output.length) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(output));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = start; j &lt; input.length; j++) &#123;</span><br><span class="line">                output[index] = input[j];</span><br><span class="line">                dfs(input, output, index + <span class="number">1</span>, j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] input = <span class="string">"abc"</span>.toCharArray();</span><br><span class="line">        <span class="comment">//N表示组合中取几位数</span></span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">char</span>[] output = <span class="keyword">new</span> <span class="keyword">char</span>[N];</span><br><span class="line">        dfs(input, output, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic4.zhimg.com/80/v2-67b0531fd3bc3ae3a125ddc897ad65a3_720w.jpg" alt="img"></p>
<p><strong>PS：一般比赛或者笔试都可以直接当作模板来使用。就好比，蓝桥杯比赛和牛客网笔试要带输入输出模板一样。然后就是希望对你们有所帮助。</strong></p>
]]></content>
      <categories>
        <category>算法积累ing</category>
      </categories>
      <tags>
        <tag>算法基础</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap1.8源码粗略解读</title>
    <url>/2020/03/18/HashMap1-8%E6%BA%90%E7%A0%81%E7%B2%97%E7%95%A5%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<p><strong>本文主要以几个方面来讲解一下HashMap：</strong></p>
<ol>
<li><strong>HashMap默认容量</strong></li>
<li><strong>HashMap如何扩容</strong></li>
<li><strong>HashMap的数组大小为什么一定要是2的幂</strong></li>
<li><strong>HashMap为什么是线程不安全的</strong></li>
<li><strong>Java7到Java8做了哪些改进</strong></li>
</ol>
<a id="more"></a>
<h2 id="1、HashMap的默认容量"><a href="#1、HashMap的默认容量" class="headerlink" title="1、HashMap的默认容量"></a><strong>1、HashMap的默认容量</strong></h2><p>从HashMap的构造函数说起。</p>
<p><img src="https://pic3.zhimg.com/80/v2-cd9cd946ef255eb972ecc93e3d95e27e_720w.jpg" alt="img"></p>
<p>initialCapacity表示的是初始化的容量，默认是1&lt;&lt;4（也就是16）；</p>
<p>loadFactor表示的是扩容因子，默认是0.75f（也就是面试常问的3/4）</p>
<p><strong>为啥扩容因子默认是0.75f？（HashMap的源码翻译）</strong></p>
<p><img src="https://pic3.zhimg.com/80/v2-cd921529a13691f02a7d117735e8fc9e_720w.jpg" alt="img"></p>
<p>假如你创建HashMap的时候传入一个不是2的幂的初始值，HashMap会把它转换为离它最近的2的幂的值。假设你输入7，HashMap会默认把他转换为8；输入29，会默认帮你转换为32</p>
<h2 id="2、HashMap如何扩容？"><a href="#2、HashMap如何扩容？" class="headerlink" title="2、HashMap如何扩容？"></a>2、HashMap如何扩容？</h2><p>当put进去的容量大于初始容量*扩容因子时，进行resize操作，就是把初始容量&lt;&lt;1(就是乘以2)进行扩容。</p>
<p><img src="https://pic2.zhimg.com/80/v2-67d62d00b77ca71b81974abefb929475_720w.jpg" alt="img"></p>
<p>源码太长，只截图一部分。1.7的resize操作和transfer操作在1.8合并为resize操作。</p>
<p><img src="https://pic3.zhimg.com/80/v2-e15ae1ecddb070e728a33485a3f79efa_720w.jpg" alt="img"></p>
<h2 id="3、HashMap的数组大小为什么一定要是2的幂？"><a href="#3、HashMap的数组大小为什么一定要是2的幂？" class="headerlink" title="3、HashMap的数组大小为什么一定要是2的幂？"></a>3、HashMap的数组大小为什么一定要是2的幂？</h2><p>首先先说明数组的大小开辟是在put操作而不是在构造函数阶段，这样为了防止创建HashMap的时候就开辟桶的空间，导致浪费，所以在进行put操作的时候才会开辟空间。</p>
<p><img src="https://pic4.zhimg.com/80/v2-93c2baa6af235b15554ca778c057649f_720w.jpg" alt="img"></p>
<p>因为hashcode(key)运算完将近有42亿个值，需要均匀的分布在16个桶里面，所以采用的是<strong>与运算</strong>。</p>
<p><strong>为啥不能用取余操作呢？</strong></p>
<ol>
<li>因为hash%n的话，假设hash算出来是负数，任何负数进行%运算都是负数</li>
<li>因为%运算的本质就是不停的使用除法，没有位运算（&amp;）来的效率高</li>
</ol>
<p>然后就是因为需要用到与运算，假如数组长度不是2的幂会导致与运算完的结果有一部分是0，导致HashMap的不均匀分布。<strong>所以数组大小一定要是2的幂</strong>。为了使HashMap均匀分布，同时还要提高计算机的运行效率，还要把<strong>hash%数组长度</strong>改为<strong>hash&amp;(数组长度-1)。</strong></p>
<h2 id="4、HashMap为什么是线程不安全的？"><a href="#4、HashMap为什么是线程不安全的？" class="headerlink" title="4、HashMap为什么是线程不安全的？"></a>4、HashMap为什么是线程不安全的？</h2><p>HashMap的官方源码用加粗的<strong></strong>标签表明了是该实现是不同步的，也就是线程不安全的。要是有大量并发还用HashMap的话，肯定由你们开发者自己背锅。</p>
<p><img src="https://pic4.zhimg.com/80/v2-527264ea48ef4a23521f4ce961fe2027_720w.jpg" alt="img"></p>
<p>线程不安全的注释翻译如下：</p>
<p><img src="https://pic1.zhimg.com/80/v2-fb3d6ff1d17653b5356cb7fa3c9b9d08_720w.jpg" alt="img"></p>
<h2 id="5、Java7到Java8做了哪些改进？"><a href="#5、Java7到Java8做了哪些改进？" class="headerlink" title="5、Java7到Java8做了哪些改进？"></a>5、Java7到Java8做了哪些改进？</h2><p><strong>1、hash算法的计算方式不同。</strong></p>
<p><img src="https://pic3.zhimg.com/80/v2-5cb81b69c8525d3ff1cb8660e8ca7cb2_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-2df62649ed3b28c84d7055e85c1522a8_720w.jpg" alt="img"></p>
<p><strong>2、jdk1.7的扩容操作在并发场景下会发送死锁现象，在jdk1.8就改进了。</strong>对于怎样产生死锁感兴趣的可以去搜“<strong>codeshell hashmap</strong>”（需要翻墙然后在google上搜索）。其实就rehash的重新插入直接把按照链表的顺序拿下来插入新的链表中。感兴趣的可以google。</p>
<p><strong>3、jdk1.7经典的数组+链表变成了jdk1.8的数组+链表+红黑树</strong></p>
<p>链表的长度阈值到达8就会转换成红黑树。为啥阈值是8？官方给出的源码翻译如下：</p>
<p><img src="https://pic1.zhimg.com/80/v2-101f3effa60096b1ed59ced6d5e4c518_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-0b4d2bde34bfdeaa3e5cafb06ca2becc_720w.jpg" alt="img"></p>
<p>就是到达8的几率已经非常非常接近0了，所以认为几乎不可能达到9，所以阈值设置为8。</p>
<p><strong>PS：以上就是我对HashMap1.7和1.8源码解读所得出来的结论。假如有哪里写得不对的可以指出批评和修改，也可以一起探讨HashMap的学习。</strong></p>
]]></content>
      <categories>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>HashMap源码</tag>
      </tags>
  </entry>
  <entry>
    <title>数值的整数次方</title>
    <url>/2020/03/10/%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>实现函数double Power（double base, int exponent），求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。</p>
</blockquote>
<a id="more"></a>
<h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例1：</span><br><span class="line">输入：2.00000 10</span><br><span class="line">输出：1024.00000</span><br><span class="line"></span><br><span class="line">示例2：</span><br><span class="line">输入：2.10000 3</span><br><span class="line">输出：9.26100</span><br><span class="line"></span><br><span class="line">示例3：</span><br><span class="line">输入：2.00000 -2</span><br><span class="line">输出：0.25000</span><br><span class="line">解释：2^-2 = 1/2^2 = 1/4 = 0.25</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ul>
<li>-100.0&lt; x &lt;100.0</li>
<li>n是32位有符号整数，其数值范围是[-2^31，2^31 -1]。</li>
</ul>
<h2 id="算法思路-二分法"><a href="#算法思路-二分法" class="headerlink" title="算法思路(二分法)"></a>算法思路(二分法)</h2><ul>
<li>当n是偶数时，x^n = (x^2)^(n/2)</li>
<li>当n是奇数时，x^n = x(x^2)^(n/2)，相比偶数多出了一项x</li>
</ul>
<p><img src="https://pic4.zhimg.com/v2-ad6d8dbd563f157d699939c0e84b122f_b.png" alt="img"></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/3/10  19:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Power</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//避免当n为最大值时，进行n=-n时数据越界出错</span></span><br><span class="line">        <span class="keyword">long</span> exponent = n;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">            exponent = -exponent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">while</span> (exponent != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//奇数多出了一项x</span></span><br><span class="line">            <span class="keyword">if</span> ((exponent &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                res = res * x;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//二分操作</span></span><br><span class="line">            x = x * x;</span><br><span class="line">            exponent = exponent &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过截图"><a href="#通过截图" class="headerlink" title="通过截图"></a>通过截图</h2><p><img src="https://pic4.zhimg.com/v2-38ea3404723a97ddbb4ceda3cecb19bb_b.png" alt="img"></p>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(logN)。跟二分操作的时间复杂度一样</li>
<li>空间复杂度：O(1)。没有引入额外的变量</li>
</ul>
<p>ps：参考leetcode大佬<strong>Krahets</strong>的解答。</p>
]]></content>
      <categories>
        <category>LeetCode&amp;牛客题解</category>
      </categories>
      <tags>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title>桶排序</title>
    <url>/2020/03/07/%E6%A1%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="桶排序（百度百科）"><a href="#桶排序（百度百科）" class="headerlink" title="桶排序（百度百科）"></a>桶排序（百度百科）</h2><blockquote>
<p><strong>桶排序 (Bucket sort)</strong>或所谓的<strong>箱排序</strong>，是一个<a href="https://baike.baidu.com/item/排序算法/5399605" target="_blank" rel="noopener">排序算法</a>，工作的原理是将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的<a href="https://baike.baidu.com/item/排序算法/5399605" target="_blank" rel="noopener">排序算法</a>或是以递归方式继续使用桶排序进行排序）。桶排序是<a href="https://baike.baidu.com/item/鸽巢排序/8010555" target="_blank" rel="noopener">鸽巢排序</a>的一种<a href="https://baike.baidu.com/item/归纳/7118703" target="_blank" rel="noopener">归纳</a>结果。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间（<a href="https://baike.baidu.com/item/Θ" target="_blank" rel="noopener">Θ</a>（<em>n</em>））。但桶排序并不是 比较排序，他不受到 O(n*log n) <a href="https://baike.baidu.com/item/下限/10215216" target="_blank" rel="noopener">下限</a>的影响。</p>
</blockquote>
<a id="more"></a>
<h2 id="排序思路（图片来自小灰）"><a href="#排序思路（图片来自小灰）" class="headerlink" title="排序思路（图片来自小灰）"></a>排序思路（图片来自小灰）</h2><p>桶排序是计数排序的升级版，可以不用局限于整数。思路大致相似。首先要确定桶的区间范围。计算方式是（Max - Min）/ （length -1）。length表示桶的数量，然后最后一个桶表示最大值，其他的桶就分范围来存储数据。</p>
<p><img src="https://pic2.zhimg.com/v2-6cb81bf81992229d25c70293260b68b1_b.png" alt="img"></p>
<p>然后遍历数据把数据填入桶中。</p>
<p><img src="https://pic4.zhimg.com/v2-1001a68ce35c57d3cb34aab6be128a47_b.png" alt="img"></p>
<p>桶内进行排序。</p>
<p><img src="https://pic2.zhimg.com/v2-d55444f6d924d1772a614e66199e8bc1_b.png" alt="img"></p>
<p>最后遍历所有桶，把数据以此输出0.5、0.84、2.18、3.25、4.5。然后排序结束。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/3/7  13:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BucketSort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span>[] bucketSort(<span class="keyword">double</span>[] array) &#123;</span><br><span class="line">        <span class="keyword">double</span> max = Double.MIN_VALUE;</span><br><span class="line">        <span class="keyword">double</span> min = Double.MAX_EXPONENT;</span><br><span class="line">        <span class="comment">//求出array数组的最大值和最小值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] &gt; max) &#123;</span><br><span class="line">                max = array[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[i] &lt; min) &#123;</span><br><span class="line">                min = array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算出差值</span></span><br><span class="line">        <span class="keyword">double</span> d = max - min;</span><br><span class="line">        <span class="comment">//初始化桶</span></span><br><span class="line">        <span class="keyword">int</span> bucketNum = array.length;</span><br><span class="line">        ArrayList&lt;LinkedList&lt;Double&gt;&gt; bucketList = <span class="keyword">new</span> ArrayList&lt;&gt;(bucketNum);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketNum; i++) &#123;</span><br><span class="line">            bucketList.add(<span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = (<span class="keyword">int</span>) ((array[i] - min) * (bucketNum - <span class="number">1</span>) / d);</span><br><span class="line">            bucketList.get(num).add(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//JDK底层采用了归并排序或归并的优化版本进行排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketList.size(); i++) &#123;</span><br><span class="line">            Collections.sort(bucketList.get(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出结果</span></span><br><span class="line">        <span class="keyword">double</span>[] sortedArray = <span class="keyword">new</span> <span class="keyword">double</span>[array.length];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (LinkedList&lt;Double&gt; list : bucketList) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">double</span> element : list) &#123;</span><br><span class="line">                sortedArray[index++] = element;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sortedArray;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//主函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span>[] array = <span class="keyword">new</span> <span class="keyword">double</span>[]&#123;<span class="number">3.14</span>, <span class="number">0.002</span>, <span class="number">6.6</span>, <span class="number">3.0</span>, <span class="number">10.01</span>, <span class="number">8.8</span>, <span class="number">4.55</span>, <span class="number">7.89</span>&#125;;</span><br><span class="line">        <span class="keyword">double</span>[] sortedArray = bucketSort(array);</span><br><span class="line">        System.out.println(Arrays.toString(sortedArray));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="https://pic4.zhimg.com/v2-57ad2676a56f7e4aad1acf752a54f99b_b.png" alt="img"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>这个桶排序也是一种线性时间的排序算法。因为它不是通过比较来进行排序，而是通过桶来排序。理论上时间复杂度为O(N)。对桶排序感兴趣的可以深入学习一下。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法积累ing</category>
      </categories>
      <tags>
        <tag>基础排序</tag>
      </tags>
  </entry>
  <entry>
    <title>计数排序</title>
    <url>/2020/03/06/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="计数排序（百度百科）"><a href="#计数排序（百度百科）" class="headerlink" title="计数排序（百度百科）"></a>计数排序（百度百科）</h2><blockquote>
<p>计数排序是一个非基于比较的<a href="https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/5399605" target="_blank" rel="noopener">排序算法</a>，该算法于1954年由 Harold H. Seward  提出。它的优势在于在对一定范围内的整数排序时，它的复杂度为Ο(n+k)（其中k是整数的范围），快于任何比较排序算法。 [1]   当然这是一种牺牲空间换取时间的做法，而且当O(k)&gt;O(n*log(n))的时候其效率反而不如基于比较的排序（基于比较的排序的时间复杂度在理论上的下限是O(n*log(n)), 如归并排序，堆排序）</p>
</blockquote>
<a id="more"></a>
<h2 id="排序思路"><a href="#排序思路" class="headerlink" title="排序思路"></a>排序思路</h2><ol>
<li>假设有N个数的数组Array，取值范围在（0~9）之间，所以初始化一个数组countArray大小为10（即最大值+1），然后全部初始化为0</li>
<li>遍历Array数组填充countArray数组。就是把Array数组的值作为countArray数组的下标然后加1</li>
<li>遍历countArray数组，把值按照顺序填回Array数组，最终输出结果即可</li>
</ol>
<h2 id="图示过程（菜鸟教程）"><a href="#图示过程（菜鸟教程）" class="headerlink" title="图示过程（菜鸟教程）"></a>图示过程（菜鸟教程）</h2><p><img src="https://pic1.zhimg.com/v2-827d96b8ca3682e8775f4916f22b45ac_b.webp" alt="img"></p>
<h2 id="算法局限性"><a href="#算法局限性" class="headerlink" title="算法局限性"></a>算法局限性</h2><ul>
<li>当数列中的元素不是整数的时候，不适合用计数排序</li>
<li>当数列中的元素最大值和最小值差距过大时，不适合用计数排序</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/3/6  19:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountSort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] countSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">        <span class="comment">//求Array数组的最大值</span></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] &gt; max) &#123;</span><br><span class="line">                max = array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个长度为max+1的countArray数组</span></span><br><span class="line">        <span class="keyword">int</span>[] countArray = <span class="keyword">new</span> <span class="keyword">int</span>[max + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//计数排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            countArray[array[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] sortedArray = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; countArray.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; countArray[i]; j++) &#123;</span><br><span class="line">                sortedArray[index++] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sortedArray;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//主函数入口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] sortedArray = countSort(array);</span><br><span class="line">        System.out.println(Arrays.toString(sortedArray));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行截图"><a href="#运行截图" class="headerlink" title="运行截图"></a>运行截图</h2><p><img src="https://pic1.zhimg.com/80/v2-df64e7422e1dce874e910dcda9d8d710_720w.jpg" alt="img"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>计数排序的时间复杂度可以做到O(N)，因为它的原理不是比较，而是计数。而通过比较达到排序效果的最快也要O(N*logN)。所以计数排序能达到线性排序的效果，但是这个算法有着局限性（max和min的差距不能过大；必须是整数）。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法积累ing</category>
      </categories>
      <tags>
        <tag>基础排序</tag>
      </tags>
  </entry>
  <entry>
    <title>基础排序（冒泡、选择、插入）</title>
    <url>/2020/02/27/%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%EF%BC%88%E5%86%92%E6%B3%A1%E3%80%81%E9%80%89%E6%8B%A9%E3%80%81%E6%8F%92%E5%85%A5%EF%BC%89/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>基本每个人入门数据结构和算法都是先经历过排序，今天就来讲解一下最基础的三个入门排序算法。分别是<strong>冒泡排序</strong>、<strong>选择排序</strong>和<strong>插入排序</strong>。</p>
</blockquote>
<a id="more"></a>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p><strong>思路：两两交换，小的往左边，大的往右边。</strong></p>
<p><img src="https://pic2.zhimg.com/80/v2-49710083e8808348f2867ea1f23482c1_720w.png" alt="img"></p>
<p>就是每趟过程把最大的数往右边靠，然后从剩下的数继续刚才的过程。</p>
<h2 id="代码（冒泡排序）"><a href="#代码（冒泡排序）" class="headerlink" title="代码（冒泡排序）"></a>代码（冒泡排序）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/2/27  14:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">//冒泡排序，两两比较，小的往左边，大的往右边</span></span><br><span class="line">    <span class="comment">//时间复杂度O(n^2)  稳定排序  空间复杂度O(1)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="comment">//避免已经排好序了还要继续循环下次</span></span><br><span class="line">            <span class="keyword">boolean</span> isSorded = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    swap(array, j, j + <span class="number">1</span>);</span><br><span class="line">                    isSorded = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isSorded) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换两数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        sort(array);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结果（冒泡排序）"><a href="#结果（冒泡排序）" class="headerlink" title="结果（冒泡排序）"></a>结果（冒泡排序）</h2><p><img src="https://pic2.zhimg.com/80/v2-14cde89a7007b96da781b099c68ccc08_720w.png" alt="img"></p>
<hr>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p><strong>思路：每一次从待排序的数据元素种选出最小的元素，存放在数组的起始位置，知道全部排序完成</strong></p>
<p><img src="https://pic2.zhimg.com/80/v2-a5fd3982db5b81c77a7923d4c1a6c713_720w.png" alt="img"></p>
<p>每次都选出最小的，然后跟待排序的第一个数交换位置，直到全部排序完成。</p>
<h2 id="代码（选择排序）"><a href="#代码（选择排序）" class="headerlink" title="代码（选择排序）"></a><strong>代码（选择排序）</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/2/27  14:18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">//选择排序</span></span><br><span class="line">    <span class="comment">//思路：从数组第一个数开始跟后面的数比较，最小和第一个交换，循环进行</span></span><br><span class="line">    <span class="comment">//时间复杂度：O(n^2)  空间复杂度O(1)  不稳定排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> minIndex = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; array.length; j++) &#123;</span><br><span class="line">                minIndex = array[minIndex] &gt; array[j] ? j : minIndex;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(array, i, minIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换两数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        selectionSort(array);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结果（选择排序）"><a href="#结果（选择排序）" class="headerlink" title="结果（选择排序）"></a>结果（选择排序）</h2><p><img src="https://pic4.zhimg.com/80/v2-be00344af30c21e0c9dfcdac24291c4e_720w.png" alt="img"></p>
<hr>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>思路：跟打扑克牌一样。维持一个有序区，然后后面进来的数跟有序区比较，然后插入</p>
<p><img src="https://pic2.zhimg.com/80/v2-374ecbfdc56e0b350358584056363738_720w.png" alt="img"></p>
<h2 id="代码（插入排序）"><a href="#代码（插入排序）" class="headerlink" title="代码（插入排序）"></a>代码（插入排序）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/2/27  14:32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChaRuSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">//插入排序，跟打扑克牌一样</span></span><br><span class="line">    <span class="comment">//时间复杂度O(n^2) 空间复杂度O(1)  稳定排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; array[j] &gt; array[j + <span class="number">1</span>]; j--) &#123;</span><br><span class="line">                swap(array, j, j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换两数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        sort(array);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结果（插入排序）"><a href="#结果（插入排序）" class="headerlink" title="结果（插入排序）"></a>结果（插入排序）</h2><p><img src="https://pic2.zhimg.com/80/v2-e0f96e22cefa5145ef35bb29e7fae6c8_720w.png" alt="img"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>这三个基础入门排序的时间复杂度都为O(N^2)，空间复杂度都为O(1)。</li>
<li>冒泡排序和插入排序都是稳定性排序，选择排序不是稳定性排序。</li>
<li>本质上，冒泡排序的进阶是快速排序。</li>
<li>本质上，插入排序的进阶是希尔排序。</li>
</ul>
]]></content>
      <categories>
        <category>算法积累ing</category>
      </categories>
      <tags>
        <tag>基础排序</tag>
      </tags>
  </entry>
  <entry>
    <title>编辑距离（困难）</title>
    <url>/2020/02/19/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h2 id="LeetCode72编辑距离"><a href="#LeetCode72编辑距离" class="headerlink" title="LeetCode72编辑距离"></a>LeetCode72编辑距离</h2><blockquote>
<p>给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数。你可以对一个单词进行如下三个操作：1，插入一个字符 2，删除一个字符 3，替换一个字符</p>
</blockquote>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">示例<span class="number">1</span>：</span><br><span class="line">输入：word1 = <span class="string">"horse"</span>, word2 = <span class="string">"ros"</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释:</span><br><span class="line">horse -&gt; rorse(将<span class="string">'h'</span>替换成<span class="string">'r'</span>)</span><br><span class="line">rorse -&gt; rose(删除<span class="string">'r'</span>)</span><br><span class="line">rose -&gt; ros(删除<span class="string">'e'</span>)</span><br><span class="line"></span><br><span class="line">示例<span class="number">2</span>：</span><br><span class="line">输入：word1 = <span class="string">"intention"</span>, word2 = <span class="string">"execution"</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：</span><br><span class="line">intention -&gt; inention(删除<span class="string">'t'</span>)</span><br><span class="line">inention -&gt; enention(将<span class="string">'i'</span>替换为<span class="string">'e'</span>)</span><br><span class="line">enention -&gt; exention(将<span class="string">'n'</span>替换为<span class="string">'x'</span>)</span><br><span class="line">exention -&gt; exection(将<span class="string">'n'</span>替换为<span class="string">'c'</span>)</span><br><span class="line">exection -&gt; execution(插入<span class="string">'u'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul>
<li>dp[i][j] 表示 word1 到 i 位置 转换成 word2 到 j 位置需要最少的步数。</li>
<li>当 word1[i] == word2[j]，dp[i][j] = dp[i-1][j-1]；</li>
<li>当 word1[i] != word2[j]，dp[i][j] = min(dp[i-1][j-1]，dp[i-1][j]，dp[i][j-1])+1；</li>
</ul>
<p>其中的dp[i-1][j-1]表示代替操作，dp[i-1][j]表示删除操作，dp[i][j-1]表示插入操作。</p>
<p>以上的替换、删除、插入操作都是对 word1 来说的。</p>
<h2 id="代码（自顶向下）暴力递归"><a href="#代码（自顶向下）暴力递归" class="headerlink" title="代码（自顶向下）暴力递归"></a>代码（自顶向下）暴力递归</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/2/19  17:08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinDistance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length1 = word1.length();</span><br><span class="line">        <span class="keyword">int</span> length2 = word2.length();</span><br><span class="line">        <span class="keyword">return</span> min(word1, word2, length1, length2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(String word1, String word2, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> j;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> min(word1, word2, i - <span class="number">1</span>, j - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> len1 = min(word1, word2, i - <span class="number">1</span>, j - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> len2 = min(word1, word2, i - <span class="number">1</span>, j) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> len3 = min(word1, word2, i, j - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> Math.min(Math.min(len1, len2), len3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>因为有重复计算的过程，而且无后效性。即一个函数f(n)一旦确定，那么之后就可以直接调用它的值，不用再关心f(n)的计算过程了，这个就是无后效性。</strong></p>
<h2 id="代码（自底向上）动态规划"><a href="#代码（自底向上）动态规划" class="headerlink" title="代码（自底向上）动态规划"></a><strong>代码（自底向上）动态规划</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/2/19  17:08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinDistance</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> length1 = word1.length();</span><br><span class="line">            <span class="keyword">int</span> length2 = word2.length();</span><br><span class="line">            <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[length1 + <span class="number">1</span>][length2 + <span class="number">1</span>];</span><br><span class="line">            <span class="comment">//初始化base case</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= length1; i++) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= length2; j++) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//填充二维数组dp表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= length1; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= length2; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                        dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = Math.min(Math.min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]), dp[i][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> dp[length1][length2];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>基本上动态规划都是暴力递归改过来的。最长公共子序列、凑硬币等都是通过这种方法写出动态规划的状态转移方程。没有必要去背状态转移方程式，也不用一直想着最优子结构等名词。最需要写出暴力递归，观察能不能改动态规划即可。</strong></p>
<p><strong>递归就是“暴力的枚举”，期间可能包括一大堆重复计算，而且一般时间复杂度都是O(2^N)。改成动态规划就是“聪明的枚举”，可以省掉重复的计算。</strong></p>
]]></content>
      <categories>
        <category>LeetCode&amp;牛客题解</category>
      </categories>
      <tags>
        <tag>困难</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划的高度套路</title>
    <url>/2020/02/18/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E9%AB%98%E5%BA%A6%E5%A5%97%E8%B7%AF/</url>
    <content><![CDATA[<h2 id="动态规划（百度百科）"><a href="#动态规划（百度百科）" class="headerlink" title="动态规划（百度百科）"></a>动态规划（百度百科）</h2><blockquote>
<p>动态规划(dynamic programming)是<a href="https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E8%BF%90%E7%AD%B9%E5%AD%A6/1559" target="_blank" rel="noopener">运筹学</a>的一个分支，是求解决策过程(decision process)最优化的数学方法。20世纪50年代初<a href="https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E7%BE%8E%E5%9B%BD" target="_blank" rel="noopener">美国</a>数学家R.E.Bellman等人在研究多阶段决策过程(multistep  decision process)的优化问题时，提出了著名的最优化原理(principle of   optimality)，把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解，创立了解决这类过程优化问题的新方法——动态规划。1957年出版了他的名著《Dynamic  Programming》，这是该领域的第一本著作。</p>
</blockquote>
<a id="more"></a>
<h2 id="我对动态规划这个算法的理解"><a href="#我对动态规划这个算法的理解" class="headerlink" title="我对动态规划这个算法的理解"></a>我对动态规划这个算法的理解</h2><blockquote>
<p>当初大二接触到数据结构这门课，学习了动态规划这种算法，老师一直说很难。加上自己当初上网查都是状态转移方程、重叠子问题、最优子结构。真的是让我无能为力，无从下手。每次解动态规划老想着状态转移方程怎么得到的，所以让我望而止步。最后知道了动态规划都是高度套路的之后，其实也是挺好理解的了。</p>
</blockquote>
<h2 id="动态规划的高度套路"><a href="#动态规划的高度套路" class="headerlink" title="动态规划的高度套路"></a>动态规划的高度套路</h2><blockquote>
<p><strong>动态规划统一都是由暴力递归–&gt;找到有重复计算的子问题–&gt;动态规划。</strong></p>
</blockquote>
<p>要是你要问，状态转移方程怎么来的，改暴力递归来的。动态规划就是这个一个高度套路。</p>
<h2 id="示例1（斐波那契数列）"><a href="#示例1（斐波那契数列）" class="headerlink" title="示例1（斐波那契数列）"></a>示例1（斐波那契数列）</h2><p>大家应该都知道这个数列，f(1)=1，f(2)=1，f(n)=f(n-1)+f(n-2)。</p>
<p><strong>暴力递归写法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(N==<span class="number">1</span> || N==<span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> fib(N-<span class="number">1</span>) + fib(N-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个解法的递归展开图是这样的（以N=10举例）：</p>
<p><img src="https://pic2.zhimg.com/80/v2-12205e947e061454d2ee064010431059_hd.jpg" alt="img"></p>
<p>这个时候发现<strong>自顶向下</strong>的递归展开图有一些计算过程都是重复的，比如fib(8)，fib(7)等，所以这样的暴力递归是可以改成动态规划的。就是改成<strong>自底向上</strong>的解法</p>
<h2 id="改动态规划的步骤"><a href="#改动态规划的步骤" class="headerlink" title="改动态规划的步骤"></a>改动态规划的步骤</h2><ul>
<li>首先找到暴力递归的base case。就是fib(1)=1，fib(2)=1</li>
<li>然后任意一个N都可以由fib(N)=fib(N-1)+fib(N-2)求出</li>
</ul>
<h2 id="代码（动态规划）"><a href="#代码（动态规划）" class="headerlink" title="代码（动态规划）"></a>代码（动态规划）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">1</span> || N == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i++) &#123;</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[N - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然这个还可以优化成空间复杂度为O(1)的解法，但不在本文的讨论范围内。我们只讲暴力递归能改动态规划的套路。</p>
<h2 id="示例2（最小路径和）"><a href="#示例2（最小路径和）" class="headerlink" title="示例2（最小路径和）"></a>示例2（最小路径和）</h2><blockquote>
<p>给定一个包含非负整数的M*N的矩阵，从左上角走到右下角的过程，使路径上的数字总和为最小。每次只能向下或者向右移动一步。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[</span><br><span class="line">  [1, 3, 1],</span><br><span class="line">  [1, 5, 1],</span><br><span class="line">  [4, 2, 1]</span><br><span class="line">]</span><br><span class="line">输出：7</span><br><span class="line">解释：因为路径1-&gt;3-&gt;1-&gt;1-&gt;1的总和最小。</span><br></pre></td></tr></table></figure>
<p><strong>先写暴力递归解法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case走到最后一格了</span></span><br><span class="line">    <span class="keyword">if</span> (i == matrix.length - <span class="number">1</span> &amp;&amp; j == matrix[<span class="number">0</span>].length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> matrix[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后一行，只能向右走</span></span><br><span class="line">    <span class="keyword">if</span> (i == matrix.length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> matrix[i][j] + minPathSum(matrix, i, j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后一列，只能向下走</span></span><br><span class="line">    <span class="keyword">if</span> (j == matrix[<span class="number">0</span>].length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> matrix[i][j] + minPathSum(matrix, i + <span class="number">1</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其他情况</span></span><br><span class="line">    <span class="keyword">int</span> right = minPathSum(matrix, i, j + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> down = minPathSum(matrix, i + <span class="number">1</span>, j);</span><br><span class="line">    <span class="keyword">return</span> matrix[i][j] + Math.min(right, down);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候的<strong>自顶向下</strong>的递归展开图是这样的（以3*3为例）：</p>
<p><img src="https://pic4.zhimg.com/80/v2-7f85813abd6940c548e5bbba057e1ddb_hd.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">此时f(0,0)=Math.min（f(0,1), f(1,0)），</span><br><span class="line">然后f(0,1)=Math.min（f(0,2), f(1,1)），</span><br><span class="line">然后f(1,0)=Math.min（f(1,1）,f(2,0)）。此时f(1,1)就重复计算了，一直递归下去就会一直重复计算</span><br></pre></td></tr></table></figure>
<p>这个时候发现<strong>自顶向下</strong>的递归展开图又有一些计算过程使重复的，可以改成非递归的动态规划<strong>自底向上</strong>的解法</p>
<h2 id="改动态规划的步骤-1"><a href="#改动态规划的步骤-1" class="headerlink" title="改动态规划的步骤"></a>改动态规划的步骤</h2><ul>
<li>先找到base case，就是最右角的值，matrix[i][j]。就是你不管用什么方法走，最后都是走到matrix[i][j]，即右下角那个地方，所以那个地方就是最小值</li>
<li>然后确定了右下角的值，就可以求出最后一行和最后一列的值</li>
<li>接下来就是matrix[i][j]的值会等于它右边和下边的值的最小值</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-2a8a7c532ce4ede4e2e80932c1128794_hd.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-3f7b681ee9198a5ca0390f82fb964c93_hd.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-83fb6ea19527107cf15ba4706b8fcbce_hd.jpg" alt="img"></p>
<p><strong>这就相当于你知道了它的base case（右下角的值），填一张二维数组的dp表，然后dp[0][0]就是左上角到右下角的最短路径</strong></p>
<h2 id="代码（动态规划）-1"><a href="#代码（动态规划）-1" class="headerlink" title="代码（动态规划）"></a>代码（动态规划）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[grid.length][grid[<span class="number">0</span>].length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = dp.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = dp[<span class="number">0</span>].length - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == dp.length - <span class="number">1</span> &amp;&amp; j == dp[<span class="number">0</span>].length - <span class="number">1</span>) &#123;</span><br><span class="line">                dp[i][j] = grid[i][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == dp.length - <span class="number">1</span> &amp;&amp; j != dp[<span class="number">0</span>].length - <span class="number">1</span>) &#123;</span><br><span class="line">                dp[i][j] = grid[i][j] + dp[i][j + <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == dp[<span class="number">0</span>].length - <span class="number">1</span> &amp;&amp; i != dp.length - <span class="number">1</span>) &#123;</span><br><span class="line">                dp[i][j] = grid[i][j] + dp[i + <span class="number">1</span>][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i + <span class="number">1</span>][j], dp[i][j + <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的这道题改成动态规划后可以优化成空间复杂度为O(1)的解法，但是本文就不讨论后续的优化，只讨论怎么把暴力递归改成动态规划解法。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>其实递归的本质就是“穷举”，然后它不知道怎么优化，它只会自顶向下无限展开，直到base  case停下。然后动态规划相比于它就是自底向上计算，不会重复计算，相当于“聪明的穷举”。然后就是暴力递归改动态规划是需要有计算重复过程的时候，并且此时的状态只与以后的状态有关，和之前的状态无光，这种称为无后效性。这种可以改为动态规划。</p>
</blockquote>
<p>PS：递归算法如汉诺塔问题、N皇后问题都不能改为动态规划，因为它们此时的状态与之前的状态是有联系的。因为汉诺塔需要打印出每一步的过程，而且没有重复计算，所以不能改动态规划。然后N皇后每一步下的棋都会影响到下一步，所以也不能改动态规划。</p>
<p>在leetcode看到大神的一个比喻：你的原问题是考出最高的成绩，那么你的子问题就是把语文考最高分，数学考最高分……为了每门课考到最高，你要把每门课相对应的选择题分数拿到最高，填空题分数拿到最高……当然，最终你的每门课都是满分，这就是最高的总成绩。</p>
<p>得到了正确的结果：最高的总成绩就是总分。因为整个过程符合最优子结构，”每门科目考到最高“这些子问题互相独立，互不干扰。</p>
<p>但是，如果加一个条件：你的语文成绩和数学成绩会互相制约，此消彼长。这样的话你能考到的最高总成绩就达不到总分了，按照刚才的思路就得不到正确的结果。因为子问题不独立，所以最优子结构会被破坏。</p>
<p><strong>最后就是如果有写不对的地方可以评论或者私信我，想和我一起讨论数据结构的也可以评论和私聊我，本人非常乐意学习和进步</strong></p>
]]></content>
      <categories>
        <category>算法积累ing</category>
      </categories>
      <tags>
        <tag>算法进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>数组中的逆序对（困难）</title>
    <url>/2020/02/16/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>最近一直在家刷面经，因为疫情也出不去。所以没事就会在知乎回答别人提出的问题，还有就是刷题。最近<strong>leetcode</strong>授权了<strong>剑指offer</strong>的题，然后就当作我是复习吧。目前还在刷，今晚吃饱刷到这道<strong>归并排序</strong>的进阶题目——<strong>数组中的逆序对</strong>，所以写一篇关于它的题解吧。</p>
</blockquote>
<a id="more"></a>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p>
</blockquote>
<p><strong>实例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[7, 5, 6, 4]</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>
<p><strong>限制：0&lt;=数组长度&lt;=50000</strong></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a><strong>思路</strong></h2><p>其实这道题的本质就是<strong>归并排序</strong>。我就当你已经会<strong>归并排序</strong>了。当进行<strong>合并操作</strong>的时候，如果<strong>nums[p1]&gt;nums[p2]</strong>的话，那么这个时候就组成逆序对。然后就是<strong>nums[p1]~nums[mid]</strong>都大于<strong>nums[p2]</strong>，所以此时的逆序对数就是<strong>mid-p1+1</strong>。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/2/16  19:49</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReversePairs</span> </span>&#123;</span><br><span class="line">    <span class="comment">//统计逆序对的总数</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        mergeSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//归并排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = start + ((end - start) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            mergeSort(nums, start, mid);</span><br><span class="line">            mergeSort(nums, mid + <span class="number">1</span>, end);</span><br><span class="line">            <span class="comment">//合并操作</span></span><br><span class="line">            merge(nums, start, mid, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> mid, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[end - start + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> p1 = start;</span><br><span class="line">        <span class="keyword">int</span> p2 = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= end) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[p1] &lt;= nums[p2]) &#123;</span><br><span class="line">                temp[p++] = nums[p1++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//此时就是nums[p1]&gt;nums[p2]的时候，组成逆序对</span></span><br><span class="line">                <span class="comment">//数量是mid-p1+1</span></span><br><span class="line">                count = count + mid - p1 + <span class="number">1</span>;</span><br><span class="line">                temp[p++] = nums[p2++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= mid) &#123;</span><br><span class="line">            temp[p++] = nums[p1++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p2 &lt;= end) &#123;</span><br><span class="line">            temp[p++] = nums[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">            nums[i + start] = temp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度为：O(N<em>logN)。因为是归并排序，所以时间复杂度为O(N</em>logN)。</li>
<li>空间复杂度为：O(N)。因为借助了辅助数组temp</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode&amp;牛客题解</category>
      </categories>
      <tags>
        <tag>困难</tag>
      </tags>
  </entry>
  <entry>
    <title>K个一组翻转链表</title>
    <url>/2020/02/14/K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>给你一个链表，每k个节点一组进行翻转，请你返回翻转后得链表。</p>
<p>k是一个正整数，它的值小于或等于链表的长度。</p>
<p>如果节点总数不是k的整数倍，那么请将最后剩余的节点保持原有顺寻。</p>
</blockquote>
<a id="more"></a>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><blockquote>
<p>给定这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5</p>
<p>当k=2时，应当返回：2-&gt;1-&gt;4-&gt;3-&gt;5</p>
<p>当k=3时，应当返回：3-&gt;2-&gt;1-&gt;4-&gt;5</p>
</blockquote>
<h2 id="思路（看图看代码）"><a href="#思路（看图看代码）" class="headerlink" title="思路（看图看代码）"></a>思路（看图看代码）</h2><p>用4个指针（pre, end, start, next）来记录完成整个过程。</p>
<p><img src="https://pic4.zhimg.com/v2-7f54e75544b77687679355112c275ca3_b.png" alt="img"></p>
<p><img src="https://pic1.zhimg.com/v2-b3bb4db2076ec2ce1b12ecd2ba96f170_b.png" alt="img"></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/2/14  11:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseKGroup</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        ListNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//K个一组翻转链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dummy是虚拟节点</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode pre = dummy;</span><br><span class="line">        ListNode end = dummy;</span><br><span class="line">        <span class="keyword">while</span> (end != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k &amp;&amp; end != <span class="keyword">null</span>; i++) &#123;</span><br><span class="line">                end = end.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (end == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode start = pre.next;</span><br><span class="line">            ListNode next = end.next;</span><br><span class="line">            end.next = <span class="keyword">null</span>;</span><br><span class="line">            pre.next = reverse(start);</span><br><span class="line">            start.next = next;</span><br><span class="line">            pre = start;</span><br><span class="line">            end = start;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反转链表并返回头节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode p1 = head;</span><br><span class="line">        ListNode p2 = head.next;</span><br><span class="line">        ListNode p3 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (p2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            p3 = p2.next;</span><br><span class="line">            p2.next = p1;</span><br><span class="line">            p1 = p2;</span><br><span class="line">            p2 = p3;</span><br><span class="line">        &#125;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        head = p1;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度为O(N*K)。最好的情况是O(N)，最坏的情况是O(N^2)</li>
<li>空间复杂度为O(1)</li>
</ul>
<p><strong>PS：这道题确实挺有难度，然后leetcode上我参考了王小二大佬的图和思路，然后自己写的代码。</strong></p>
]]></content>
      <categories>
        <category>LeetCode&amp;牛客题解</category>
      </categories>
      <tags>
        <tag>困难</tag>
      </tags>
  </entry>
  <entry>
    <title>（经典）求两个单链表相交结点</title>
    <url>/2020/02/12/%EF%BC%88%E7%BB%8F%E5%85%B8%EF%BC%89%E6%B1%82%E4%B8%A4%E4%B8%AA%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>在本题中，单链表可能有环，也可能无环。给定两个单链表的头节点head1和head2，这两个链表可能相交，也可能不相交。请实现一个函数，如果两个链表相交，请返回相交的第一个节点；如果不相交，返回null即可。 要求：如果链表1的长度为N，链表2的长度为M，时间复杂度请达到O(N+M)，额外空间复杂度请达到O(1)。</p>
</blockquote>
<a id="more"></a>
<h2 id="考察点"><a href="#考察点" class="headerlink" title="考察点"></a>考察点</h2><ul>
<li>判断链表是否有环</li>
<li>如果链表有环，则找到入环结点</li>
<li>两个链表各种情况的分析</li>
</ul>
<h2 id="情况分析"><a href="#情况分析" class="headerlink" title="情况分析"></a>情况分析</h2><p>这道题总共有6种情况要分析。分别是</p>
<ul>
<li>两个链表无环</li>
<li>两个链表有环</li>
<li>一个链表有环，一个链表无环</li>
</ul>
<p><img src="https://pic4.zhimg.com/v2-9353fd155db887b0b4296543c5ac9f4b_b.png" alt="img"></p>
<p>1、如果两个链表都无环，那就直接判断是否相交即可。</p>
<p>2、如果两个链表都有环，求出入口节点。</p>
<p>求出入口节点，如果入口节点是同一个的话，把相同的入口结点当作是<strong>尾结点</strong>，这个问题就退化成<strong>两个链表都无环</strong>，直接判断是否相交即可。</p>
<p>如果入口节点不是同一个的话，从第一个入口节点开始next下去，如果<strong>遇到第二个入口节点返回</strong>即可；如果<strong>回到了本身的入口节点</strong>则表示没有相交，直接返回null</p>
<p>3、如果<strong>一个链表有环</strong>，<strong>一个链表无环</strong>，那么这<strong>两个链表必不可能相交</strong></p>
<p><strong>所有的情况就都已经分析完了，接下来就是上代码了</strong></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> zuoshen;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/2/12  11:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindFirstIntersectNode</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Java版．左老师给出的代码，很赞</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getIntersectNode</span><span class="params">(Node head1, Node head2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head1 == <span class="keyword">null</span> || head2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//求head1和head2的入环结点</span></span><br><span class="line">        Node loop1 = getLoopNode(head1);</span><br><span class="line">        Node loop2 = getLoopNode(head2);</span><br><span class="line">        <span class="comment">//head1和head2都没有环</span></span><br><span class="line">        <span class="keyword">if</span> (loop1 == <span class="keyword">null</span> &amp;&amp; loop2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> noLoop(head1, head2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//head1和head2都有环</span></span><br><span class="line">        <span class="keyword">if</span> (loop1 != <span class="keyword">null</span> &amp;&amp; loop2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> bothLoop(head1, loop1, head2, loop2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当一个有环一个无环则不存在相交结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getLoopNode</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node n1 = head.next; <span class="comment">// n1 -&gt; slow</span></span><br><span class="line">        Node n2 = head.next.next; <span class="comment">// n2 -&gt; fast</span></span><br><span class="line">        <span class="keyword">while</span> (n1 != n2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n2.next == <span class="keyword">null</span> || n2.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            n2 = n2.next.next;</span><br><span class="line">            n1 = n1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        n2 = head; <span class="comment">// n2 -&gt; walk again from head</span></span><br><span class="line">        <span class="keyword">while</span> (n1 != n2) &#123;</span><br><span class="line">            n1 = n1.next;</span><br><span class="line">            n2 = n2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">noLoop</span><span class="params">(Node head1, Node head2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head1 == <span class="keyword">null</span> || head2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node cur1 = head1;</span><br><span class="line">        Node cur2 = head2;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur1.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            n++;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (cur2.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            n--;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur1 != cur2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur1 = n &gt; <span class="number">0</span> ? head1 : head2;</span><br><span class="line">        cur2 = cur1 == head1 ? head2 : head1;</span><br><span class="line">        n = Math.abs(n);</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            n--;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (cur1 != cur2) &#123;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">bothLoop</span><span class="params">(Node head1, Node loop1, Node head2, Node loop2)</span> </span>&#123;</span><br><span class="line">        Node cur1 = <span class="keyword">null</span>;</span><br><span class="line">        Node cur2 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (loop1 == loop2) &#123;</span><br><span class="line">            cur1 = head1;</span><br><span class="line">            cur2 = head2;</span><br><span class="line">            <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (cur1 != loop1) &#123;</span><br><span class="line">                n++;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (cur2 != loop2) &#123;</span><br><span class="line">                n--;</span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur1 = n &gt; <span class="number">0</span> ? head1 : head2;</span><br><span class="line">            cur2 = cur1 == head1 ? head2 : head1;</span><br><span class="line">            n = Math.abs(n);</span><br><span class="line">            <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">                n--;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (cur1 != cur2) &#123;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cur1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur1 = loop1.next;</span><br><span class="line">            <span class="keyword">while</span> (cur1 != loop1) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur1 == loop2) &#123;</span><br><span class="line">                    <span class="keyword">return</span> loop1;</span><br><span class="line">                &#125;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;null</span></span><br><span class="line">        Node head1 = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">        head1.next = <span class="keyword">new</span> Node(<span class="number">2</span>);</span><br><span class="line">        head1.next.next = <span class="keyword">new</span> Node(<span class="number">3</span>);</span><br><span class="line">        head1.next.next.next = <span class="keyword">new</span> Node(<span class="number">4</span>);</span><br><span class="line">        head1.next.next.next.next = <span class="keyword">new</span> Node(<span class="number">5</span>);</span><br><span class="line">        head1.next.next.next.next.next = <span class="keyword">new</span> Node(<span class="number">6</span>);</span><br><span class="line">        head1.next.next.next.next.next.next = <span class="keyword">new</span> Node(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 0-&gt;9-&gt;8-&gt;6-&gt;7-&gt;null</span></span><br><span class="line">        Node head2 = <span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">        head2.next = <span class="keyword">new</span> Node(<span class="number">9</span>);</span><br><span class="line">        head2.next.next = <span class="keyword">new</span> Node(<span class="number">8</span>);</span><br><span class="line">        head2.next.next.next = head1.next.next.next.next.next; <span class="comment">// 8-&gt;6</span></span><br><span class="line">        System.out.println(getIntersectNode(head1, head2).value);<span class="comment">//output:6</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;4...</span></span><br><span class="line">        head1 = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">        head1.next = <span class="keyword">new</span> Node(<span class="number">2</span>);</span><br><span class="line">        head1.next.next = <span class="keyword">new</span> Node(<span class="number">3</span>);</span><br><span class="line">        head1.next.next.next = <span class="keyword">new</span> Node(<span class="number">4</span>);</span><br><span class="line">        head1.next.next.next.next = <span class="keyword">new</span> Node(<span class="number">5</span>);</span><br><span class="line">        head1.next.next.next.next.next = <span class="keyword">new</span> Node(<span class="number">6</span>);</span><br><span class="line">        head1.next.next.next.next.next.next = <span class="keyword">new</span> Node(<span class="number">7</span>);</span><br><span class="line">        head1.next.next.next.next.next.next.next = head1.next.next.next; <span class="comment">// 7-&gt;4</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 0-&gt;9-&gt;8-&gt;2...</span></span><br><span class="line">        head2 = <span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">        head2.next = <span class="keyword">new</span> Node(<span class="number">9</span>);</span><br><span class="line">        head2.next.next = <span class="keyword">new</span> Node(<span class="number">8</span>);</span><br><span class="line">        head2.next.next.next = head1.next; <span class="comment">// 8-&gt;2</span></span><br><span class="line">        System.out.println(getIntersectNode(head1, head2).value);<span class="comment">//output:2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 0-&gt;9-&gt;8-&gt;6-&gt;4-&gt;5-&gt;6..</span></span><br><span class="line">        head2 = <span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">        head2.next = <span class="keyword">new</span> Node(<span class="number">9</span>);</span><br><span class="line">        head2.next.next = <span class="keyword">new</span> Node(<span class="number">8</span>);</span><br><span class="line">        head2.next.next.next = head1.next.next.next.next.next; <span class="comment">// 8-&gt;6</span></span><br><span class="line">        System.out.println(getIntersectNode(head1, head2).value);<span class="comment">//output:4</span></span><br><span class="line">        System.out.println(getIntersectNode(head2, head1).value);<span class="comment">//note the order //output:6</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>这道题其实是挺难的，但是听了左神老师讲完之后发现也就那样。由此可见，一道难的题目都是由一些简单的题目组合起来的。这道题就是<strong>两个无环链表判断相交并且返回相交节点，有环链表求它的入环节点，</strong>这两道题目的组合就是今天这道题的由来，所以情况更加的复杂。</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode&amp;牛客题解</category>
      </categories>
      <tags>
        <tag>困难</tag>
      </tags>
  </entry>
  <entry>
    <title>进程与线程的一个简单解释</title>
    <url>/2020/02/11/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E8%A7%A3%E9%87%8A/</url>
    <content><![CDATA[<p><strong>转载自阮一峰大佬的网络日志</strong></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><blockquote>
<p><strong>进程（process）</strong>和<strong>线程（thread）</strong>是操作系统的基本概念，但是它们比较抽象，不容易掌握。接下来有一个很好的类比，可以把它们解释地清晰易懂。</p>
</blockquote>
<a id="more"></a>
<p><strong>1、</strong></p>
<p><img src="https://pic3.zhimg.com/80/v2-27079449e58afd118e7664b04578f344_hd.png" alt="img"></p>
<p>计算机的核心是CPU，它承担了所有的计算任务。它就像一座工厂，时刻在运行。</p>
<p><strong>2、</strong></p>
<p><img src="https://pic4.zhimg.com/80/v2-ad028c112f0d18a0b17979c47fb6cb5c_hd.png" alt="img"></p>
<p>假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，<strong>单个CPU一次只能运行一个任务</strong>。</p>
<p><strong>3、</strong></p>
<p><img src="https://pic3.zhimg.com/80/v2-b46a4028e69a4db9b5db845d3762f2a9_hd.png" alt="img"></p>
<p>进程就好比工厂的车间，它代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程，其他进程处于非运行状态。</p>
<p><strong>4、</strong></p>
<p><img src="https://pic3.zhimg.com/80/v2-127be934737e47c25f5caa7629ebb0aa_hd.png" alt="img"></p>
<p>一个车间里，可以有很多工人，他们协同完成一个任务。</p>
<p><strong>5、</strong></p>
<p><img src="https://pic3.zhimg.com/80/v2-9d51b60a7bccb5ad86cdf7634d9817da_hd.png" alt="img"></p>
<p>线程就好比车间里的工人。<strong>一个进程可以包括多个线程</strong>。</p>
<p><strong>6、</strong></p>
<p><img src="https://pic2.zhimg.com/80/v2-ac91aec51f0cc56897a114facae2a2de_hd.png" alt="img"></p>
<p>车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征<strong>一个进程的内存空间是共享的，每个线程都可以使用这些共享内存</strong>。</p>
<p><strong>7、</strong></p>
<p><img src="https://pic2.zhimg.com/80/v2-e376f83761880cc244e801bb150ba72f_hd.png" alt="img"></p>
<p>可是，每间房间的大小不同，有些房间最多只能容纳一个人，比如厕所。里面有人的时候，其他人就不能进去了。这代表一个线程使用某些共享内存时。其他线程必须等它结束，才能使用这一块内存。</p>
<p><strong>8、</strong></p>
<p><img src="https://pic2.zhimg.com/80/v2-66b20a499d48d96194dfc8b5394ab5f0_hd.png" alt="img"></p>
<p>一个防止他人进入的简单方法，就是在门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫<strong>“互斥锁”（Mutual exclusion，缩写Mutex）</strong>，防止多个线程同时读写某一块内存区域。</p>
<p><strong>9、</strong></p>
<p><img src="https://pic2.zhimg.com/80/v2-afe37d379c07f39e6136bc9d7f69b6c3_hd.png" alt="img"></p>
<p>还有些房间，可以同时容纳N个人，比如厨房。也就是说，如果人数大于N，多出来的人只能在外面等着。这好比某些内存区域，只能供给给固定数目的线程使用。</p>
<p><strong>10、</strong></p>
<p><img src="https://pic4.zhimg.com/80/v2-6b371e1c71a5accc82e95013a86453d7_hd.png" alt="img"></p>
<p>这时的解决方法，就是在门口挂N把钥匙，进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做<strong>“信号量”（Semaphore）</strong>，用来保证多个线程不会互相冲突。</p>
<p>不难看出，<strong>mutex是semaphore的一种特殊情况（N=1时）</strong>。也就是说，完全可以用后者替代前者。但是，因为mutex较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。</p>
<p><strong>11、</strong></p>
<p><img src="https://pic2.zhimg.com/80/v2-f18600f73561954968b058e118fe3877_hd.png" alt="img"></p>
<p>操作系统的设计，因此可以归结为三点：</p>
<ol>
<li>以多进程形式，允许多个任务同时运行；</li>
<li>以多线程形式，允许单个任务分成不同的部分运行；</li>
<li>提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。</li>
</ol>
<p>（完）</p>
<p><strong>转载自阮一峰大佬的网络日志</strong></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>进程和线程</tag>
      </tags>
  </entry>
  <entry>
    <title>两个链表的第一个公共结点</title>
    <url>/2020/02/10/%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>输入两个链表，找出它们的第一个公共结点。如果有公共结点，则输出它们的第一个公共结点；如果没有公共结点，则输出null即可。</p>
</blockquote>
<a id="more"></a>
<h2 id="链表的定义"><a href="#链表的定义" class="headerlink" title="链表的定义"></a>链表的定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>有公共结点的情况：</strong></p>
<p><img src="https://pic1.zhimg.com/v2-be177b90f6a447df5df70ae5a8c1d8a4_b.png" alt="img"></p>
<p>这个时候就计算出pHead1链表的长度，pHead2链表的长度，然后让长的链表先走它们之间长度的差值，然后pHead1和pHead2同时走，必定同时遇到（此时就是公共结点）。</p>
<p><strong>无公共结点的情况：</strong></p>
<p><img src="https://pic3.zhimg.com/v2-a741ce3ff09c9febd3e30230222d5132_b.png" alt="img"></p>
<p>这个时候也是采取跟有公共结点一样的思路，让链表长的先走它们长度的差值步数，然后让他们同时走，这个时候同时走到null，返回null即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> nowcoder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/2/10  11:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindFirstCommonNode</span> </span>&#123;</span><br><span class="line">    <span class="comment">//链表的定义</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        ListNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">findFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead1 == <span class="keyword">null</span> || pHead2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> length2 = <span class="number">0</span>;</span><br><span class="line">        ListNode node1 = pHead1;</span><br><span class="line">        ListNode node2 = pHead2;</span><br><span class="line">        <span class="comment">//计算出链表pHead1和pHead2的长度</span></span><br><span class="line">        <span class="keyword">while</span> (node1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            length1++;</span><br><span class="line">            node1 = node1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (node2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            length2++;</span><br><span class="line">            node2 = node2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//让长的链表先走N步（N=Math.abs(length1-length2)）</span></span><br><span class="line">        <span class="keyword">if</span> (length1 &gt; length2) &#123;</span><br><span class="line">            <span class="keyword">int</span> go = length1 - length2;</span><br><span class="line">            <span class="keyword">while</span> (go &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                go--;</span><br><span class="line">                pHead1 = pHead1.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> go = length2 - length1;</span><br><span class="line">            <span class="keyword">while</span> (go &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                go--;</span><br><span class="line">                pHead2 = pHead2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//同时走，只要有公共结点就会遇到，没有公共结点就返回null</span></span><br><span class="line">        <span class="keyword">while</span> (pHead1 != pHead2) &#123;</span><br><span class="line">            pHead1 = pHead1.next;</span><br><span class="line">            pHead2 = pHead2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pHead1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过"><a href="#通过" class="headerlink" title="通过"></a>通过</h2><p><img src="https://pic1.zhimg.com/v2-e0e3f6d5761b3b1dae9549e3cffe1444_b.png" alt="img"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>这道题也是中规中矩，现在已经写完了两个链表的相交情况。以前也写过环形链表的入口结点。这两个东西结合起来也是一道非常经典的题目，等下次我来分享给大家。</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode&amp;牛客题解</category>
      </categories>
      <tags>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈单例模式的几种实现</title>
    <url>/2020/02/08/%E6%B5%85%E8%B0%88%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="单例模式（来自菜鸟教程）"><a href="#单例模式（来自菜鸟教程）" class="headerlink" title="单例模式（来自菜鸟教程）"></a>单例模式（来自菜鸟教程）</h2><blockquote>
<p>单例模式（Singleton  Pattern）是Java中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
</blockquote>
<a id="more"></a>
<h2 id="单例模式的要求"><a href="#单例模式的要求" class="headerlink" title="单例模式的要求"></a>单例模式的要求</h2><ul>
<li>构造方法必须私有化（确保只有自己能创建）</li>
<li>以静态方法返回实例（外界不能通过new来获取到对象）</li>
<li>确保对象实例只有一个（只对类进行一次实例化，以后都直接获取第一次实例化的对象）</li>
</ul>
<h2 id="单例模式的实现"><a href="#单例模式的实现" class="headerlink" title="单例模式的实现"></a>单例模式的实现</h2><p><strong>1、懒汉式（线程不安全）</strong></p>
<p>描述：这种方式是最基本的实现方式，但是不支持多线程。因为没有加锁，在多线程不能正常工作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//懒汉式（线程不安全）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2、懒汉式（线程安全）</strong></p>
<p>描述：能够在多线程下正常工作，但是，效率极低</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//懒汉式（线程安全）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3、双重校验锁（DCL，即double-checked locking）（线程安全）</strong></p>
<p>描述：对懒汉式（线程安全）的优化，采用双锁的机制，安全且在多线程情况下能保持高性能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双重校验锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4、饿汉式（线程安全）</strong></p>
<p>描述：这种方式比较常用，但容易产生垃圾对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//饿汉式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>5、静态内部类（线程安全）</strong></p>
<p>描述：这种方式达到跟<strong>双重校验锁</strong>一样的效果，这种方式只适用于静态域的情况，双重校验锁可在实例域需要延迟初始化时使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态内部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>6、枚举（线程安全）</strong></p>
<p>描述：这种方式还没有被广泛采用，但是这种实现是单例模式的最佳方法。更简洁、自动支持序列化机制、绝对防止多次实例化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//枚举</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whateverMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>一般情况下，不建议使用第1种和第2种<strong>懒汉</strong>方式，建议使用第4种<strong>饿汉</strong>方式。只有在明确实现lazy loading时，才会使用第5种<strong>静态内部类</strong>方式。如果涉及到反序列化创建对象时，可以使用第6种<strong>枚举</strong>方式。如果有其他需求，可以考虑使用第3种<strong>双重校验锁</strong>方式。</p>
</blockquote>
<p><strong>PS：开始面临着春招，好多面经都有说到设计模式。最常见的面试题就是讲一讲单例模式的实现和理解，所以我写一下，加深我对单例模式的理解和印象。觉得对你有帮助的话可以点点赞，谢谢啦~~~</strong></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title>删除链表中重复的结点</title>
    <url>/2020/02/06/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。例如：1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5处理后为1-&gt;2-&gt;5</p>
</blockquote>
<a id="more"></a>
<h2 id="链表的定义"><a href="#链表的定义" class="headerlink" title="链表的定义"></a>链表的定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//链表的定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>PS：本文主要的解法以非递归解法为主，一切可以以递归解的题目都可以变成非递归解法。</strong></p>
<h2 id="递归代码（加注释）"><a href="#递归代码（加注释）" class="headerlink" title="递归代码（加注释）"></a>递归代码（加注释）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> nowcoder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/2/6  11:33</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeleteDuplication</span> </span>&#123;</span><br><span class="line">    <span class="comment">//链表定义</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        ListNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归解法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (pHead.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> pHead;</span><br><span class="line">        ListNode cur;</span><br><span class="line">        <span class="comment">//对重复结点的处理</span></span><br><span class="line">        <span class="keyword">if</span> (pHead.val == pHead.next.val) &#123;</span><br><span class="line">            cur = pHead.next.next;</span><br><span class="line">            <span class="comment">//遍历到没有重复结点的位置</span></span><br><span class="line">            <span class="keyword">while</span> (cur != <span class="keyword">null</span> &amp;&amp; cur.val == pHead.val) &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> deleteDuplication(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有重复结点</span></span><br><span class="line">        cur = pHead.next;</span><br><span class="line">        pHead.next = deleteDuplication(cur);</span><br><span class="line">        <span class="keyword">return</span> pHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过截图"><a href="#通过截图" class="headerlink" title="通过截图"></a>通过截图</h2><p><img src="https://pic2.zhimg.com/v2-c07487589b965bd412665d3de446a161_b.png" alt="img"></p>
<p><strong>PS：递归解法的题目都是需要你自己弄懂他的过程，就好比我当初学习递归的第一个例子就是汉诺塔，我也很懵逼，这究竟是什么东西！！！然后花了一个晚上在图书馆一直看课本上的例子和代码，然后就会恍然大悟，原来递归就是这样的。所以递归的思路我水平有限，不知道怎么解释，希望你们自己好好弄懂。</strong></p>
<hr>
<h2 id="非递归思路"><a href="#非递归思路" class="headerlink" title="非递归思路"></a>非递归思路</h2><ul>
<li>首先new一个头节点初始化为0，防止第一个结点和第二个结点相同的情况</li>
<li>设置pre和last指针，pre指针指向当前确定不重复的结点，last指针就一直向后搜索</li>
</ul>
<h2 id="代码（加注释）"><a href="#代码（加注释）" class="headerlink" title="代码（加注释）"></a>代码（加注释）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> nowcoder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/2/6  11:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeleteDuplication</span> </span>&#123;</span><br><span class="line">    <span class="comment">//链表定义</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        ListNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非递归解法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="keyword">null</span> || pHead.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> pHead;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化一个0为头结点，防止pHead的第一个结点和第二个结点相同的情况</span></span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        head.next = pHead;</span><br><span class="line">        <span class="comment">//pre指向确定不重复的结点</span></span><br><span class="line">        ListNode pre = head;</span><br><span class="line">        ListNode last = head.next;</span><br><span class="line">        <span class="keyword">while</span> (last != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果last和后面的指针相同</span></span><br><span class="line">            <span class="keyword">if</span> (last.next != <span class="keyword">null</span> &amp;&amp; last.val == last.next.val) &#123;</span><br><span class="line">                <span class="comment">//找到last往后不重复的结点的位置</span></span><br><span class="line">                <span class="keyword">while</span> (last.next != <span class="keyword">null</span> &amp;&amp; last.val == last.next.val) &#123;</span><br><span class="line">                    last = last.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//相当于删除重复的结点</span></span><br><span class="line">                pre.next = last.next;</span><br><span class="line">                last = last.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果不重复，pre和last分别往后移动</span></span><br><span class="line">                pre = pre.next;</span><br><span class="line">                last = last.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过截图-1"><a href="#通过截图-1" class="headerlink" title="通过截图"></a>通过截图</h2><p><img src="https://pic4.zhimg.com/80/v2-26f436cace283cebaa85ff50914e84df_hd.jpg" alt="img"></p>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(N)。遍历一遍就可以删除重复结点</li>
<li>空间复杂度：O(1)。因为整个过程利用有限的几个变量pre和last，所以空间复杂度为O(1)</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode&amp;牛客题解</category>
      </categories>
      <tags>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title>和为S的连续正数序列</title>
    <url>/2020/02/04/%E5%92%8C%E4%B8%BAS%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>小明很喜欢数学，有一天他在做数学作业时，要求计算出9~16的和，他马上就写出了正确答案是100。但是他并不满足于此，他在想究竟有多少种连续的正数序列的和为100（至少包括两个数）。没多久，他就得到另一组连续正数和为100的序列：18，19，20，21，22。现在把问题交给你，你能不能也很快的找到所有和为S的连续正数序列？Good Luck！</p>
</blockquote>
<a id="more"></a>
<h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h2><blockquote>
<p>输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序</p>
</blockquote>
<h2 id="暴力思路"><a href="#暴力思路" class="headerlink" title="暴力思路"></a>暴力思路</h2><p>就是正常的暴力解法，穷举所有可能相加等于S，本文章不讲这个解法。</p>
<h2 id="双指针思路"><a href="#双指针思路" class="headerlink" title="双指针思路"></a>双指针思路</h2><p>设置两个指针left和right，然后根据等差数列的求和公式（a0+an）* n / 2求出对应的和与S比较，等于的话直接返回；小于S的话就right++；大于S的话就left++。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> nowcoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/2/4  11:35</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindContinuousSequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; findContinuousSequence(<span class="keyword">int</span> sum) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//设置两个指针left和right</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">//因为都是连续的，差值为1的等差数列。</span></span><br><span class="line">            <span class="comment">//求和公式为(a0+an)*n/2</span></span><br><span class="line">            <span class="keyword">int</span> curSum = (left + right) * (right - left + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//判断curSum和sum的大小关系调整对应的left和right</span></span><br><span class="line">            <span class="keyword">if</span> (curSum == sum) &#123;</span><br><span class="line">                ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">                    list.add(i);</span><br><span class="line">                &#125;</span><br><span class="line">                res.add(list);</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curSum &lt; sum) &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过截图"><a href="#通过截图" class="headerlink" title="通过截图"></a>通过截图</h2><p><img src="https://pic4.zhimg.com/80/v2-a97efb8af8961a1eae45f96044881e87_hd.jpg" alt="img"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>其实这道题我半年前就做过了，然后当时根本对算法没多少认识，基本都是一个思路“暴力破万法”，“一切皆可暴”。所以慢慢接触到一些面经，基本就是算法题你只要是暴力解的基本都是不通过，这就给我提了个醒，不能一直依靠暴力，暴力就当作入门，后面要多学习算法达到一道题有多种解法思路。</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode&amp;牛客题解</category>
      </categories>
      <tags>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title>寻找两个有序数组的中位数</title>
    <url>/2020/02/01/%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>最近在家闲着无聊看爱情公寓5，看上瘾了发现两天没刷题了，不好，所以去leetcode看了一下，找到一道比较有意思的题目（<strong>寻找两个有序数组的中位数</strong>），尝试做了一下，暴力解法还是挺简单的，二分法也比较有意思。所以来试着讲解一下（哈哈哈）</p>
</blockquote>
<a id="more"></a>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="https://pic1.zhimg.com/80/v2-8acb38186be01f55f0b494f34e80a3e8_hd.jpg" alt="img"></p>
<h2 id="暴力思路"><a href="#暴力思路" class="headerlink" title="暴力思路"></a>暴力思路</h2><p>先申请一个长度为nums1.length+nums2.length的辅助数组，然后利用<strong>归并排序</strong>的合并算法将两个数组合并成一个数组，并且是有序的数组。若长度为奇数，则中位数就是<strong>数组长度/2</strong>；若长度为偶数，则中位数就是<strong>数组长度/2和数组长度/2 - 1之和除以2。</strong></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/2/2  10:19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindMedianSortedArrays</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length1 = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> length2 = nums2.length;</span><br><span class="line">        <span class="comment">//申请一个长度为length1+length2的辅助数组res</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[length1 + length2];</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> p2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//利用归并排序的merge操作进行两个数组合并，并且合并后的数组有序</span></span><br><span class="line">        <span class="keyword">while</span> (p1 &lt; nums1.length &amp;&amp; p2 &lt; nums2.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[p1] &lt; nums2[p2]) &#123;</span><br><span class="line">                res[p++] = nums1[p1++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res[p++] = nums2[p2++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt; nums1.length) &#123;</span><br><span class="line">            res[p++] = nums1[p1++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p2 &lt; nums2.length) &#123;</span><br><span class="line">            res[p++] = nums2[p2++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((res.length &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//合并后的数组长度为奇数</span></span><br><span class="line">            <span class="keyword">return</span> res[(res.length) / <span class="number">2</span>] / <span class="number">1.0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//为偶数</span></span><br><span class="line">            <span class="keyword">return</span> (res[(res.length) / <span class="number">2</span> - <span class="number">1</span>] + res[(res.length) / <span class="number">2</span>]) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过截图"><a href="#通过截图" class="headerlink" title="通过截图"></a>通过截图</h2><p><img src="https://pic4.zhimg.com/80/v2-ec8761b9932e712f78fede788af6222f_hd.jpg" alt="img"></p>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(M+N)，M是第一个数组的长度，N是第二个数组的长度</li>
<li>空间复杂度：O(M+N)，因为申请了一个辅助数组长度为M+N</li>
</ul>
<hr>
<h2 id="二分解法代码（加注释）"><a href="#二分解法代码（加注释）" class="headerlink" title="二分解法代码（加注释）"></a>二分解法代码（加注释）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/2/2  10:59</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindMedianSortedArrays</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 1.首先，让我们在任一位置 i 将 A(长度为m) 划分成两个部分：</span></span><br><span class="line"><span class="comment">         *            leftA            |                rightA</span></span><br><span class="line"><span class="comment">         *   A[0],A[1],...      A[i-1] |  A[i],A[i+1],...A[m - 1]</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 由于A有m个元素，所以有m + 1中划分方式(i = 0 ~ m)</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 我们知道len(leftA) = i, len(rightA) = m - i;</span></span><br><span class="line"><span class="comment">         * 注意：当i = 0时，leftA是空集，而当i = m时，rightA为空集。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 2.采用同样的方式，将B也划分为两部分：</span></span><br><span class="line"><span class="comment">         *            leftB            |                rightB</span></span><br><span class="line"><span class="comment">         *   B[0],B[1],...      B[j-1] |   B[j],B[j+1],...B[n - 1]</span></span><br><span class="line"><span class="comment">         *  我们知道len(leftA) = j, len(rightA) = n - j;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *  将leftA和leftB放入一个集合，将rightA和rightB放入一个集合。再把这两个集合分别命名为leftPart和rightPart。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *            leftPart         |                rightPart</span></span><br><span class="line"><span class="comment">         *   A[0],A[1],...      A[i-1] |  A[i],A[i+1],...A[m - 1]</span></span><br><span class="line"><span class="comment">         *   B[0],B[1],...      B[j-1] |  B[j],B[j+1],...B[n - 1]</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *   如果我们可以确认：</span></span><br><span class="line"><span class="comment">         *   1.len(leftPart) = len(rightPart); =====&gt; 该条件在m+n为奇数时，该推理不成立</span></span><br><span class="line"><span class="comment">         *   2.max(leftPart) &lt;= min(rightPart);</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *   median = (max(leftPart) + min(rightPart)) / 2;  目标结果</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *   要确保这两个条件满足：</span></span><br><span class="line"><span class="comment">         *   1.i + j = m - i + n - j(或m - i + n - j + 1)  如果n &gt;= m。只需要使i = 0 ~ m，j = (m+n+1)/2-i =====&gt; 该条件在m+n为奇数/偶数时，该推理都成立</span></span><br><span class="line"><span class="comment">         *   2.B[j] &gt;= A[i-1] 并且 A[i] &gt;= B[j-1]</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *   注意:</span></span><br><span class="line"><span class="comment">         *   1.临界条件：i=0,j=0,i=m,j=n。需要考虑</span></span><br><span class="line"><span class="comment">         *   2.为什么n &gt;= m ? 由于0 &lt;= i &lt;= m且j = (m+n+1)/2-i,必须确保j不能为负数。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *   按照以下步骤进行二叉树搜索</span></span><br><span class="line"><span class="comment">         *   1.设imin = 0,imax = m，然后开始在[imin,imax]中进行搜索</span></span><br><span class="line"><span class="comment">         *   2.令i = (imin+imax) / 2, j = (m+n+1)/2-i</span></span><br><span class="line"><span class="comment">         *   3.现在我们有len(leftPart) = len(rightPart)。而我们只会遇到三种情况：</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *      ①.B[j] &gt;= A[i-1] 并且 A[i] &gt;= B[j-1]  满足条件</span></span><br><span class="line"><span class="comment">         *      ②.B[j-1] &gt; A[i]。此时应该把i增大。 即imin = i + 1;</span></span><br><span class="line"><span class="comment">         *      ③.A[i-1] &gt; B[j]。此时应该把i减小。 即imax = i - 1;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="keyword">int</span> m = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> n = nums2.length;</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n) &#123; <span class="comment">// to ensure m&lt;=n</span></span><br><span class="line">            <span class="keyword">int</span>[] temp = nums1;</span><br><span class="line">            nums1 = nums2;</span><br><span class="line">            nums2 = temp;</span><br><span class="line">            <span class="keyword">int</span> tmp = m;</span><br><span class="line">            m = n;</span><br><span class="line">            n = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> iMin = <span class="number">0</span>, iMax = m, halfLen = (m + n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (iMin &lt;= iMax) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = (iMin + iMax) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> j = halfLen - i;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; iMax &amp;&amp; nums2[j - <span class="number">1</span>] &gt; nums1[i]) &#123;</span><br><span class="line">                iMin = i + <span class="number">1</span>; <span class="comment">// i is too small</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; iMin &amp;&amp; nums1[i - <span class="number">1</span>] &gt; nums2[j]) &#123;</span><br><span class="line">                iMax = i - <span class="number">1</span>; <span class="comment">// i is too big</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// i is perfect</span></span><br><span class="line">                <span class="keyword">int</span> maxLeft;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;<span class="comment">//A分成的leftA(空集) 和 rightA(A的全部)  所以leftPart = leftA(空集) + leftB,故maxLeft = B[j-1]。</span></span><br><span class="line">                    maxLeft = nums2[j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) &#123; <span class="comment">//B分成的leftB(空集) 和 rightB(B的全部)  所以leftPart = leftA + leftB(空集),故maxLeft = A[i-1]。</span></span><br><span class="line">                    maxLeft = nums1[i - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">//排除上述两种特殊情况，正常比较</span></span><br><span class="line">                    maxLeft = Math.max(nums1[i - <span class="number">1</span>], nums2[j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ((m + n) % <span class="number">2</span> == <span class="number">1</span>) &#123; <span class="comment">//奇数，中位数正好是maxLeft</span></span><br><span class="line">                    <span class="keyword">return</span> maxLeft;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//偶数</span></span><br><span class="line">                <span class="keyword">int</span> minRight;</span><br><span class="line">                <span class="keyword">if</span> (i == m) &#123;<span class="comment">//A分成的leftA(A的全部) 和 rightA(空集)  所以rightPart = rightA(空集) + rightB,故minRight = B[j]。</span></span><br><span class="line">                    minRight = nums2[j];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == n) &#123;<span class="comment">//B分成的leftB(B的全部) 和 rightB(空集)  所以rightPart = rightA + rightB(空集),故minRight = A[i]。</span></span><br><span class="line">                    minRight = nums1[i];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//排除上述两种特殊情况，正常比较</span></span><br><span class="line">                    minRight = Math.min(nums2[j], nums1[i]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> (maxLeft + minRight) / <span class="number">2.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过截图-1"><a href="#通过截图-1" class="headerlink" title="通过截图"></a>通过截图</h2><p><img src="https://pic2.zhimg.com/80/v2-06696895ca0a55632e8edf8cb526c161_hd.jpg" alt="img"></p>
<h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(log(M,N))</li>
<li>空间复杂度：O(1)</li>
</ul>
<p><strong>PS：该解法参考leetcode上的官方解法加上一些注释。</strong></p>
]]></content>
      <categories>
        <category>LeetCode&amp;牛客题解</category>
      </categories>
      <tags>
        <tag>困难</tag>
      </tags>
  </entry>
  <entry>
    <title>最长有效括号</title>
    <url>/2020/01/30/%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>最近被新型冠状病毒搞得人心惶惶，大家都不太敢出门，我也不敢出门（哈哈哈），索性就在家里刷了一道leetcode的简单题——有效的括号（leetcode20题），说简单也不简单，说难也不难，刷完之后觉得意犹未尽。然后再刷了一道leetcode的困难题——最长有效括号（leetcode32题）。今天就来讲一下这两道相似题目的题解。</p>
</blockquote>
<a id="more"></a>
<h2 id="第一题（leetcode20-有效的括号）"><a href="#第一题（leetcode20-有效的括号）" class="headerlink" title="第一题（leetcode20_有效的括号）"></a>第一题（leetcode20_有效的括号）</h2><p><img src="https://pic1.zhimg.com/80/v2-3009c2ec8800e2dce79bb44decad3e8c_hd.jpg" alt="img"></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote>
<p>先列出括号的类型把他存在HashMap中，然后利用栈先进后出的特性来解决。<strong>如果是左括号就直接进栈，如果是右括号就出栈，然后判断出栈的左括号是否对应着对应的右括号即可。</strong></p>
</blockquote>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/1/30  11:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackIsValid</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//把括号的类型存进HashMap中</span></span><br><span class="line">        HashMap&lt;Character,Character&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">')'</span>,<span class="string">'('</span>);</span><br><span class="line">        map.put(<span class="string">'&#125;'</span>,<span class="string">'&#123;'</span>);</span><br><span class="line">        map.put(<span class="string">']'</span>,<span class="string">'['</span>);</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="comment">//如果是左括号，直接进栈</span></span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(s.charAt(i))) &#123;</span><br><span class="line">                stack.push(s.charAt(i));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果是右括号，出栈然后判断出栈左括号对应HashMap的左括号是否一致</span></span><br><span class="line">                <span class="keyword">char</span> top = stack.isEmpty() ? <span class="string">'#'</span> : stack.pop();</span><br><span class="line">                <span class="keyword">if</span> (top != map.get(s.charAt(i))) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(N)。因为整个过程遍历一遍就可以处理完</li>
<li>空间复杂度：O(N)。借助了大小为N的栈来辅助完成</li>
</ul>
<hr>
<h2 id="第二题（leetcode32-最长有效括号）"><a href="#第二题（leetcode32-最长有效括号）" class="headerlink" title="第二题（leetcode32_最长有效括号）"></a>第二题（leetcode32_最长有效括号）</h2><p><img src="https://pic1.zhimg.com/v2-3db2f1101e338975b5dab286d6e443a4_b.png" alt="img"></p>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><blockquote>
<p>对于每个’(‘，我们将它的下标进栈。对于每个’)’，我们弹出栈顶的元素并将当前元素的下标于当前栈顶下标作差，得出当前有效括号的长度。</p>
</blockquote>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/1/30  11:59</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongestValidParentheses</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="comment">//如果匹配到左括号就直接进栈</span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">'('</span>) &#123;</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 右括号出栈，并且判断栈是否为空，</span></span><br><span class="line">                <span class="comment">// 如果为空，把当前下标进栈，</span></span><br><span class="line">                <span class="comment">// 如果不为空，计算出当前有效的长度，记录下来</span></span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">                    stack.push(i);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    max = Math.max(max, i - stack.peek());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(N)。因为遍历一次就能得出最长的有效括号</li>
<li>空间复杂度：O(N)。因为借助了大小为N的辅助栈处理</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode&amp;牛客题解</category>
      </categories>
      <tags>
        <tag>困难</tag>
      </tags>
  </entry>
  <entry>
    <title>数组中只出现一次的数字</title>
    <url>/2020/01/29/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p>
</blockquote>
<a id="more"></a>
<h2 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h2><p>利用HashMap来做这道题，时间复杂度为O(N)，空间复杂度为O(N)</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> nowcoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/1/28  16:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</span></span><br><span class="line"><span class="comment">//num1,num2分别为长度为1的数组。传出参数</span></span><br><span class="line"><span class="comment">//将num1[0],num2[0]设置为返回结果</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindNumsAppearOnce</span> </span>&#123;</span><br><span class="line">    <span class="comment">//HashMap解法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findNumsAppearOnce</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> num1[], <span class="keyword">int</span> num2[])</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(array[i])) &#123;</span><br><span class="line">                map.put(array[i], <span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(array[i], <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//标识这两个数的顺序</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.get(array[i]) == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                    num1[<span class="number">0</span>] = array[i];</span><br><span class="line">                    count++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    num2[<span class="number">0</span>] = array[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="解法2（重点）"><a href="#解法2（重点）" class="headerlink" title="解法2（重点）"></a>解法2（重点）</h2><p>利用位运算中的异或运算来解这道题。异或的性质就是两个相同的数字异或为0，一个数和0异或还是它本身。要是对位运算不熟悉的话可以先看这一篇文章：</p>
<p><a href="https://zhuanlan.zhihu.com/p/102277869" target="_blank" rel="noopener">god-jiang：神级运算——位运算</a></p>
<p>用位运算可以达到时间复杂度为O(N)，空间复杂度为O(1)</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>如果一个数组只有A和B是出现一次的数，我们把所有的数都异或了之后的结果就是A和B异或的结果。因为相同的数异或都等于0。异或的结果的二进制中至少会出现一个1，因为A和B不同，异或至少会出现一个1，我们取第一个1的位置，假设这个位置是第3位，我们把第3位为0的分成一组，把第3位为1的分成一组，各自异或，最后的结果就是出现一次的数。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> nowcoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/1/28  17:32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</span></span><br><span class="line"><span class="comment">//num1,num2分别为长度为1的数组。传出参数</span></span><br><span class="line"><span class="comment">//将num1[0],num2[0]设置为返回结果</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindNumsAppearOnce</span> </span>&#123;</span><br><span class="line">    <span class="comment">//异或解法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findNumsAppearOnce1</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> num1[], <span class="keyword">int</span> num2[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//异或的结果就是A和B的异或结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            temp = temp ^ array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//找到异或结果第一位为1的位置为index</span></span><br><span class="line">        <span class="keyword">while</span> ((index &amp; temp) == <span class="number">0</span>) &#123;</span><br><span class="line">            index = index &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> result2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((index &amp; array[i]) == <span class="number">0</span>) &#123;</span><br><span class="line">                result1 = result1 ^ array[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result2 = result2 ^ array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        num1[<span class="number">0</span>] = result1;</span><br><span class="line">        num2[<span class="number">0</span>] = result2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="https://pic2.zhimg.com/80/v2-615ae0b9de94c99c18081411de09086d_hd.jpg" alt="img"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>这道题目在牛客网上还是比较经典的一道题目，可以看出你对HashMap熟不熟悉，也可以看出你对位运算的理解程度。</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode&amp;牛客题解</category>
      </categories>
      <tags>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title>过年之抢红包算法</title>
    <url>/2020/01/26/%E8%BF%87%E5%B9%B4%E4%B9%8B%E6%8A%A2%E7%BA%A2%E5%8C%85%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>昨天是大年初一，怎么说呢，因为在读大学， 没有出来工作，所以昨晚也是陆陆续续有收到一些红包。然后想起自己对算法感兴趣，以前也看过一些公众号有讲过<strong>抢红包算法，</strong>今天就更新一遍关于<strong>抢红包的算法</strong>，对学过数据结构或者对抢红包感兴趣的可以看一看。本文就讲两个抢红包算法。</p>
</blockquote>
<a id="more"></a>
<p><strong>PS：关于抢红包算法我是参看公众号“程序员小灰”。这个公众号是引领我学数据结构的公众号，通过漫画的形式讲得很通俗易懂。</strong></p>
<hr>
<h2 id="抢红包算法的要求"><a href="#抢红包算法的要求" class="headerlink" title="抢红包算法的要求"></a><strong>抢红包算法的要求</strong></h2><p>假设有10元钱，10个人分：</p>
<ul>
<li><strong>每个人至少分到0.01元，不可以分到0元</strong></li>
<li><strong>每个人分到的金额加起来要等于10元，不可以多于10元，也不可以少于10元</strong></li>
<li><strong>每个人分的金额要尽可能随机，不能差距太大</strong></li>
</ul>
<h2 id="抢红包一"><a href="#抢红包一" class="headerlink" title="抢红包一"></a><strong>抢红包一</strong></h2><blockquote>
<p>当初大二学习数据结构的时候老师就有布置一道作业题说叫我们回去写一个类似于微信的抢红包算法，然后下个星期看哪位同学写得好。所以第一个抢红包算法应该大家很容易理解。</p>
</blockquote>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>每个人每次抢到的金额范围是：（0，剩余金额）。</strong></p>
<p>不过这个算法思路会违背“<strong>每个人分的金额随机，不能差距太大</strong>”。</p>
<p>为什么会这样，举个例子：</p>
<p>假设有10元钱，10个人分。</p>
<p>第一个人的随机范围是（0，10），平均分到5元。</p>
<p>假设第一个人随机分到5元，剩余金额为10-5=5元。</p>
<p>第二个人的随机范围是（0，5），平均分到2.5元。</p>
<p>假设第二个人随机分到2.5元，剩余金额为5-2.5=2.5元。</p>
<p>第三个人的随机范围是（0，2.5），平均分到1.25元</p>
<p>以此类推，每一次随机范围越来越小，违背了“<strong>每个人分的金额随机，不能差距太大</strong>”。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> zhihu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/1/26  16:49</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Algorithm</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">divideRedPackage</span><span class="params">(Integer totalAmount, Integer totalPeopleNum)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; amountList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Integer restAmount = totalAmount;</span><br><span class="line">        Integer restPeopleNum = totalPeopleNum;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalPeopleNum - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> amount = random.nextInt(restAmount - restPeopleNum - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            restAmount -= amount;</span><br><span class="line">            restPeopleNum--;</span><br><span class="line">            amountList.add(amount);</span><br><span class="line">        &#125;</span><br><span class="line">        amountList.add(restAmount);</span><br><span class="line">        <span class="keyword">return</span> amountList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; amountList = divideRedPackage(<span class="number">1000</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (Integer amount : amountList</span><br><span class="line">        ) &#123;</span><br><span class="line">            System.out.println(<span class="string">"抢到金额"</span> + <span class="keyword">new</span> BigDecimal(amount).divide(<span class="keyword">new</span> BigDecimal(<span class="number">100</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="https://pic2.zhimg.com/80/v2-15d72ce41de42df15c8f392da0c7921d_hd.jpg" alt="img"></p>
<hr>
<h2 id="抢红包二"><a href="#抢红包二" class="headerlink" title="抢红包二"></a>抢红包二</h2><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p><strong>每次抢到的金额=随机范围（0，M/N *2）</strong></p>
<p><strong>M表示剩余红包金额，N表示剩余人数。这个公式保证了每次随机金额的平均值是相等的。</strong></p>
<p>举个例子：</p>
<p>假设有10元钱，10个人分：</p>
<p>10/10 *2=2，所以第一个人分到的范围是（0，2），平均可以分到1元。</p>
<p>假设第一个人随机分到1元，那么剩余金额是10-1=9元。</p>
<p>9/9 *2=2，所以第二个人分到的范围是（0，2），平均可以分到1元。</p>
<p>假设第二个人随机分到1元，那么剩余金额是9-1=8元。</p>
<p>8/8 *2=2，所以第三个人的随机范围也是（0，2），平均可以分到1元。</p>
<p>以此类推，每一次随机范围都是相等的。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> zhihu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/1/26  15:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Algorithm</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">divideRedPackage</span><span class="params">(Integer totalAmount, Integer totalPeopleNum)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; amountList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Integer restAmount = totalAmount;</span><br><span class="line">        Integer restPeopleNum = totalPeopleNum;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalPeopleNum - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//保证金额范围是[1，剩余金额2倍），左闭右开</span></span><br><span class="line">            <span class="keyword">int</span> amount = random.nextInt(restAmount / restPeopleNum * <span class="number">2</span> - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            restAmount -= amount;</span><br><span class="line">            restPeopleNum--;</span><br><span class="line">            amountList.add(amount);</span><br><span class="line">        &#125;</span><br><span class="line">        amountList.add(restAmount);</span><br><span class="line">        <span class="keyword">return</span> amountList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; amountList = divideRedPackage(<span class="number">1000</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (Integer amount : amountList</span><br><span class="line">        ) &#123;</span><br><span class="line">            System.out.println(<span class="string">"抢到金额"</span> + <span class="keyword">new</span> BigDecimal(amount).divide(<span class="keyword">new</span> BigDecimal(<span class="number">100</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h2><p><img src="https://pic1.zhimg.com/80/v2-865c5937786868dcd6f08730a594c898_hd.jpg" alt="img"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>抢红包算法就只写了两个，第一个就是以前大二学习数据结构的时候老师布置作业，我的想法就是大概这样，分的不均。第二个算法就是看公众号“程序员小灰”学习到的，很厉害，挺佩服这些大佬的，哈哈。</p>
</blockquote>
<p><strong>PS：本文提供的代码红包金额都是以分为单位，因为抢红包最低都是0.01元。</strong></p>
]]></content>
      <categories>
        <category>算法积累ing</category>
      </categories>
      <tags>
        <tag>抢红包</tag>
      </tags>
  </entry>
  <entry>
    <title>2019.3.1IntelliJ IDEA永久破解</title>
    <url>/2020/01/25/2019-3-1IntelliJ-IDEA%E6%B0%B8%E4%B9%85%E7%A0%B4%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote>
<p>大二刚接触到Java这门课程的时候，都是在eclipse上使用。当时老师讲了IDE的作用什么的，然而当时的我根本就没有听，导致我大三花更多的时间自己自学Java和JavaWeb还有框架等等。然后就是大三自学的时候用的是Myeclipse破解版的，发现这个编译器真的卡，也可能是因为我的笔记本性能一般，所以一直在用eclipse。最后是在大三的期末实训接触到的IDEA编译器，对于我来说打开了另一个门，然后我一直用的是IDEA的破解码，一般都是一年的期限，现在好像是破解码很多都用不了，所以找了IDEA的永久破解方法。</p>
</blockquote>
<a id="more"></a>
<h2 id="破解步骤"><a href="#破解步骤" class="headerlink" title="破解步骤"></a>破解步骤</h2><p><strong>1、先把本机的IDEA升级到2019.3的版本，因为我以前是用2018年的，现在用2019年的版本，其实都是差不多的，但是你用2019.3以前的版本我不敢保证能成功破解。我的方法是用jar包+破解码来达到一个永久破解的效果。</strong></p>
<p><strong>我自己用的IDEA版本介绍：</strong></p>
<p><img src="https://pic1.zhimg.com/80/v2-a40d2b362951818fd455a873a80183d0_hd.jpg" alt="img"></p>
<p><strong>2、打开IDEA先免费使用30天，它会让你注册账号你可以直接跳过，免费使用30天</strong></p>
<p><img src="https://pic2.zhimg.com/80/v2-d24804ee0ff26a74632183aec4de8be1_hd.jpg" alt="img"></p>
<p><strong>3、进入到IDEA里面，点击菜单栏【Help】 -&gt; 【Edit Custom VM Options】。注意不要在安装目录改idea64.exe.vmoptions文件，因为IDEA针对反破解已经越来越严格了。在最后添加一行代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//对应你自己的jar包路径，注意路径不要出现中文</span><br><span class="line">-javaagent:C:\Program Files\JetBrains\IntelliJ IDEA 2019.2.3\bin\jetbrains-agent.jar</span><br></pre></td></tr></table></figure>
<p><img src="https://pic4.zhimg.com/80/v2-cd6162669466f4d123dc134fbc167e43_hd.jpg" alt="img"></p>
<p><strong>注意：添加javaagent路径不要包含中文，不然可能破解失败！！！</strong></p>
<p><strong>4、重启IDEA，然后点击菜单栏【Help】 -&gt; 【Register】。然后在Activation code加入破解码。</strong></p>
<p><img src="https://pic3.zhimg.com/80/v2-28b0072e006ec54d67cf4b98afe535c6_hd.jpg" alt="img"></p>
<p><strong>然后破解完它就显示有效期到2089年了。</strong></p>
<p><strong>jar包+破解码的分享在这里：</strong></p>
<p>链接:<a href="https://link.zhihu.com/?target=https%3A//pan.baidu.com/s/1nkV8x4WF72ZvOSFiDyipdg" target="_blank" rel="noopener">https://pan.baidu.com/s/1nkV8x4WF72ZvOSFiDyipdg</a></p>
<p>提取码:amaq </p>
<p><img src="https://pic1.zhimg.com/80/v2-60b3c2f0f8f4b791fb74e6639a0ac374_hd.jpg" alt="img"></p>
<p><strong>祝你们大家都能破解成功~~~</strong></p>
]]></content>
      <categories>
        <category>软件破解</category>
      </categories>
      <tags>
        <tag>IDEA破解</tag>
      </tags>
  </entry>
  <entry>
    <title>N数之和求解</title>
    <url>/2020/01/24/N%E6%95%B0%E4%B9%8B%E5%92%8C%E6%B1%82%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote>
<p>刷leetcode上的题发现有一些题型相似的题目可以单独拿出来一起练习，因为相似，所以可以用同一种解法优化一下就可以做，以达到巩固的效果，本文就把介绍<strong>两数之和（简单）</strong>和<strong>三数之和（中等）</strong>的解法，类似的四数之和等等都是类似的。</p>
</blockquote>
<a id="more"></a>
<h2 id="题目1描述（两数之和）"><a href="#题目1描述（两数之和）" class="headerlink" title="题目1描述（两数之和）"></a>题目1描述（两数之和）</h2><p><img src="/images/N数之和/1.jpg" alt="img"></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote>
<p>利用<strong>哈希表</strong>来解题，利用“空间换时间”。把<strong>nums[i]的值作为哈希表的key</strong>，把 <strong>i 作为哈希表的value</strong>。然后<strong>判断target-nums[i]是否在哈希表中出现过</strong>就可以找到了。</p>
</blockquote>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/1/24  18:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoSum</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> res = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (map.size() &gt; <span class="number">0</span> &amp;&amp; map.containsKey(res)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(res), i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="leetcode通过截图"><a href="#leetcode通过截图" class="headerlink" title="leetcode通过截图"></a>leetcode通过截图</h2><p><img src="/images/N数之和/2.jpg" alt="img"></p>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><blockquote>
<p>因为遍历一次就得到结果，所以时间复杂度为O(N)。然后就是因为利用哈希表开辟了跟数组一样长度的空间N，所以空间复杂度为O(N)。</p>
</blockquote>
<hr>
<h2 id="题目2描述（三数之和）"><a href="#题目2描述（三数之和）" class="headerlink" title="题目2描述（三数之和）"></a>题目2描述（三数之和）</h2><p><img src="/images/N数之和/3.jpg" alt="img"></p>
<h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote>
<p>先固定第一个数，然后就变成了两数之和，解法和上面一样。然后这道题可以用双指针解，先将数组排序完，然后遍历的时候先固定一个数，剩下就是左指针和右指针相互移动来解出这道题。细节直接上代码好了</p>
</blockquote>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/1/24  19:32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreeSum</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//去重操作</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span> (sum == <span class="number">0</span>) &#123;</span><br><span class="line">                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));</span><br><span class="line">                    <span class="comment">//去重操作</span></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//去重操作</span></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="leetcode通过截图-1"><a href="#leetcode通过截图-1" class="headerlink" title="leetcode通过截图"></a>leetcode通过截图</h2><p><img src="/images/N数之和/4.jpg" alt="img"></p>
<h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><blockquote>
<p>因为一开始数组的排序过程的时间复杂度为O(N*logN)，然后就是固定一个值，通过移动左右指针来获得结果，时间复杂度为O(N^2)，空间复杂度因为没有引入额外的空间变量，所以空间复杂度为O(1)</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>通过<strong>两数之和</strong> 和 <strong>三数之和</strong>两道题，对于四数之和或者五数之和又有什么不一样呢，大不了固定一个值变成三数之和，只要掌握了核心，再怎么变化我觉得都是可以解出来的，只不过会复杂一点，百变不离其中就是这么一个道理。</p>
</blockquote>
<p><strong>PS：今晚刚吃完年夜饭就来更新leetcode的题解了，选择的是比较简单的两道相似题目（两数之和&amp;三数之和），讲解了一下大概解法还有复杂度的分析，觉得还是挺入门级别的题目，利用这两道题可以明白到哈希表的好用，利用“空间换时间”，就这样吧。觉得博主写的还可以的可以点点赞，关注一波，谢谢大家的支持了~~~</strong></p>
]]></content>
      <categories>
        <category>LeetCode&amp;牛客题解</category>
      </categories>
      <tags>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title>统计无序数组各元素出现的次数</title>
    <url>/2020/01/22/%E7%BB%9F%E8%AE%A1%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E5%90%84%E5%85%83%E7%B4%A0%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>一个长度大小为N的数组，数组中的每个元素的取值范围在[1，N]，且为正整数。<br>问：如何在时间复杂度为O(N)，空间复杂度为O(1)的条件下，统计数组中不同元素出现的次数。</p>
</blockquote>
<a id="more"></a>
<h2 id="对这道题的感受"><a href="#对这道题的感受" class="headerlink" title="对这道题的感受"></a>对这道题的感受</h2><blockquote>
<p>一开始接触到这道题，我是觉得不难的，因为我会开辟一个辅助数组来帮助统计这个过程。但是这道题要求的是空间复杂度为O(1)，然后这道题的难度就噌噌噌的上升，然后我现在弄明白了就来写一下我对这道题的题解吧。</p>
</blockquote>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>遍历数组，通过当前元素的值作为下标，找到下一个元素。最后得到的数组中，下标（<strong>因为数组的下标都是从0开始的，所以需要+1</strong>）为数组中出现的元素，每个下标对应的值取反输出即是该元素出现的次数。</p>
<ul>
<li>若当前元素小于0，则跳过</li>
<li>若当前元素大于0，则判断其作为下标对应的元素是否大于0。若大于0，则把对应的元素赋值给当前元素，并把它的值设置为-1；若小于0，则把对应的元素自减1，当前元素置为0；</li>
</ul>
<p><strong>估计阅读到这里，你会一脸懵逼，这些当前元素和对应元素到底是什么鬼，好混。我明白，所以接下来我举个例子来讲解整个过程。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组举例</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、遍历数组，第一个arr[0]=2，然后看下标为2的元素是arr[2]=5。</span></span><br><span class="line"><span class="comment">2、把arr[2]对应的5赋值给arr[0]，然后arr[2]就设置为-1</span></span><br><span class="line"><span class="comment">3、然后重复整个过程直到结束</span></span><br><span class="line"><span class="comment">它的整个变化过程就是这样</span></span><br><span class="line"><span class="comment">- &#123;2, 5, 5, 2, 3&#125;</span></span><br><span class="line"><span class="comment">- 5, [-1], 5, 2, 3</span></span><br><span class="line"><span class="comment">- 3, [-1], 5, 2, [-1]</span></span><br><span class="line"><span class="comment">- 5, [-1], [-1], 2, [-1]</span></span><br><span class="line"><span class="comment">- [0], [-1], [-1], 2, [-2]</span></span><br><span class="line"><span class="comment">- [0], [-2], [-1], [0], [-2]</span></span><br><span class="line"><span class="comment">这个结果表示：1有0个，2有2个，3有一个，4有0个，5有2个</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/1/22  17:30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountArr</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; n) &#123;</span><br><span class="line">            <span class="comment">//因为数组都是从0开始的，所以arr[index]得减1才可以找到对应的元素，否则会数组越界</span></span><br><span class="line">            <span class="keyword">int</span> temp = arr[index] - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (temp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                index++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arr[temp] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                arr[index] = arr[temp];</span><br><span class="line">                arr[temp] = -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                arr[temp]--;</span><br><span class="line">                arr[index] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        work(arr, arr.length);</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> countResult : arr</span><br><span class="line">        ) &#123;</span><br><span class="line">            System.out.println(index++ + <span class="string">"出现了"</span> + (-<span class="number">1</span>) * countResult + <span class="string">"次"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行截图"><a href="#运行截图" class="headerlink" title="运行截图"></a>运行截图</h2><p><img src="/images/统计元素个数/1.jpg" alt="img"></p>
<h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><blockquote>
<p>今天一睡醒就一直在家帮忙，也没啥时间可以刷题，偶尔看会小说和刷抖音，颓废了一点，就写一些以前接触过的题，也挺有意思的。觉得博主写得还可以的点点赞，关注一下，谢谢大家的支持了~~~</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode&amp;牛客题解</category>
      </categories>
      <tags>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬虫入门笔记</title>
    <url>/2020/01/22/python%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote>
<p>由于这两天在家大扫除贴对联准备过年，所以刷题的机会少了许多，我也就放松放松一下，不写题解了，哈哈。由于python语言越来越火热，虽然我是走Java后台开发，但是也被python给吸引住了。所以这几天我学习了一下python的爬虫入门，记录一下我学习python爬虫的经历吧。</p>
</blockquote>
<a id="more"></a>
<h2 id="基础准备"><a href="#基础准备" class="headerlink" title="基础准备"></a>基础准备</h2><ul>
<li>我觉得要学习一个新的东西的时候，兴趣是最重要的一个因素。因为我本人很喜欢看小说，然后又是技术控，所以想试一下用python爬虫爬取我喜欢的小说（刺激~~~）</li>
<li>有一门面向对象的编程语言基础，例如我熟悉Java，然后入手python就觉得还可以（有点自恋~~~）</li>
<li>装python3.x的环境（因为我是用python3.8）,觉得麻烦可以直接装anaconda也行。我是因为毕业设计做深度学习都有安装，不过我还是用自己安装的python3.8来做爬虫。</li>
</ul>
<h2 id="开发爬虫的步骤"><a href="#开发爬虫的步骤" class="headerlink" title="开发爬虫的步骤"></a>开发爬虫的步骤</h2><ul>
<li>目标数据（网站、页面）</li>
<li>分析数据加载流程（分析目标数据所对应的url）</li>
<li>下载数据到本地</li>
<li>清洗，处理数据</li>
<li>数据持久化</li>
</ul>
<p><strong>因为我喜欢看伏天氏，所以爬取的是笔趣阁里面的伏天氏小说，以此来记录python爬虫的入门。</strong></p>
<h2 id="爬取数据"><a href="#爬取数据" class="headerlink" title="爬取数据"></a><strong>爬取数据</strong></h2><ol>
<li>需要导入requests库，没有这个库可以直接在win+r的cmd里面输入pip install requests下载即可</li>
<li>需要学习正则表达式来帮助我们爬取想要的数据</li>
</ol>
<h2 id="代码（加注释）"><a href="#代码（加注释）" class="headerlink" title="代码（加注释）"></a>代码（加注释）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python </span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"></span><br><span class="line"># 导入requests库，前提是已安装requests库，可以在命令提示符窗口输入pip install requests得到，</span><br><span class="line">import requests</span><br><span class="line"># 爬虫必备的正则模块</span><br><span class="line">import re</span><br><span class="line"></span><br><span class="line"># url存放要爬取的网页地址</span><br><span class="line">url = &apos;https://www.jupindai.com/book/87.html&apos;</span><br><span class="line"></span><br><span class="line"># requests发起get请求url，返回response</span><br><span class="line">response = requests.get(url)</span><br><span class="line"># 设置网页响应回来的编码格式</span><br><span class="line">response.encoding = &apos;gbk&apos;</span><br><span class="line"># 拿到网页的html</span><br><span class="line">html = response.text;</span><br><span class="line"># 拿到小说的名字</span><br><span class="line">title = re.findall(r&apos;&lt;meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;(.*?)&quot;&gt;&apos;, html)[0]</span><br><span class="line"># print(title)</span><br><span class="line"># 新建一个文件保存小说</span><br><span class="line">fb = open(&apos;%s.txt&apos; % title, &apos;w&apos;, encoding=&apos;utf-8&apos;)</span><br><span class="line"># print(html)</span><br><span class="line"></span><br><span class="line"># 获取对应的章节List</span><br><span class="line">dl = re.findall(</span><br><span class="line">    r&apos;&lt;dl class=&quot;panel-body panel-chapterlist&quot;&gt;.*?&lt;/div&gt;&apos;,</span><br><span class="line">    html, re.S)[1]</span><br><span class="line"># 获取对应的title和href</span><br><span class="line">chapter_info_list = re.findall(r&apos;&lt;a href=&quot;(.*?)&quot; title=&quot;(.*?)&quot;&gt;(.*?)&lt;/a&gt;&apos;, dl)</span><br><span class="line"># print(chapter_info_list)</span><br><span class="line"></span><br><span class="line"># 循环每一个chapter_info_list，分别下载</span><br><span class="line">for chapter_info in chapter_info_list:</span><br><span class="line">    chapter_url, none, chapter_title = chapter_info</span><br><span class="line">    chapter_url = &apos;https://www.jupindai.com%s&apos; %\</span><br><span class="line">                  chapter_url</span><br><span class="line">    # 下载</span><br><span class="line">    chapter_response = requests.get(chapter_url)</span><br><span class="line">    chapter_response.encoding = &apos;gbk&apos;</span><br><span class="line">    chapter_html = chapter_response.text</span><br><span class="line">    # print(chapter_url, chapter_title)</span><br><span class="line">    # 提取章节内容</span><br><span class="line">    chapter_content = re.findall(r&apos;&lt;div class=&quot;panel-body&quot; id=&quot;htmlContent&quot;&gt;(.*?)&lt;/div&gt;&apos;, chapter_html, re.S)[0]</span><br><span class="line">    # 清洗数据</span><br><span class="line">    chapter_content = str(chapter_content).replace(&apos; &apos;, &apos;&apos;)</span><br><span class="line">    chapter_content = str(chapter_content).replace(&apos;&amp;nbsp;&apos;, &apos;&apos;)</span><br><span class="line">    chapter_content = str(chapter_content).replace(&apos;&lt;br/&gt;&apos;, &apos;&apos;)</span><br><span class="line">    # 回车</span><br><span class="line">    chapter_content = str(chapter_content).replace(&apos;\r&apos;, &apos;&apos;)</span><br><span class="line">    # 换行</span><br><span class="line">    chapter_content = str(chapter_content).replace(&apos;\n&apos;, &apos;&apos;)</span><br><span class="line">    # print(chapter_content)</span><br><span class="line">    # 数据持久化</span><br><span class="line">    fb.write(chapter_title)</span><br><span class="line">    fb.write(&apos;\n&apos;)</span><br><span class="line">    fb.write(chapter_content)</span><br><span class="line">    fb.write(&apos;\n&apos;)</span><br><span class="line">    print(chapter_url)</span><br></pre></td></tr></table></figure>
<h2 id="运行部分截图"><a href="#运行部分截图" class="headerlink" title="运行部分截图"></a>运行部分截图</h2><p><img src="/images/爬虫/3.jpg" alt="img"></p>
<hr>
<p><strong>PS：由于写代码的时候是一边写一边测试，所以中间挺多过程你们可能看着有点懵，可以尝试着自己写一下来熟悉一下整个过程。这个应该就是最简单的一个python爬虫入门了吧，因为喜欢看小说，刚好现在在看《伏天氏》，就试着爬取一下数据，结果还不错，就是过程可能有点坎坷，毕竟本身我就是学Java出身，python也是半吊子，要不是刚好毕业设计做深度学习，我估计连python的语法都不会吧（哈哈），觉得对你有点帮助的点点赞，谢谢你们的支持了。</strong></p>
]]></content>
      <categories>
        <category>python学习</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>链表中环的入口节点</title>
    <url>/2020/01/21/%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>给定一个链表，若其中包含环，请找出该链表的环的入口节点，否则，输出null。</p>
</blockquote>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote>
<p>设置快慢指针，都从链表头出发，快指针每次<strong>走两步，</strong>慢指针一次<strong>走一步，</strong>假如有环，一定相遇于环中某点（结论1）.接着让两个指针分别从相遇点和链表头出发，两者都改为每次<strong>走一步</strong>，最终相遇于环入口（结论2）。以下是两个结论的证明：</p>
</blockquote>
<h2 id="两个结论："><a href="#两个结论：" class="headerlink" title="两个结论："></a>两个结论：</h2><ol>
<li><strong>设置快慢指针，假如有环，他们最后一定相遇在环中。</strong></li>
<li><strong>两个指针相遇后，让两个指针分别从链表头和相遇点重新出发，每次走一步，最后一定相遇于环入口。</strong></li>
</ol>
<p><strong>证明结论1</strong>：设置快慢指针fast和slow，fast每次走两步，low每次走一步。假如有环，两者一定在环中相遇。（因为low指针一旦进环，可以看作是fast指针在追slow指针，因为fast指针每次走两步，slow指针每次走一步，所以最后一定能追上（相遇））。</p>
<p><strong>证明结论2</strong>：</p>
<p>假设</p>
<p>链表头到环入口长度为——a，</p>
<p>环入口到相遇点长度为——b，</p>
<p>相遇点到环入口长度为——c，如图所示：</p>
<p><img src="/images/链表中环的入口节点/1.jpg" alt="img"></p>
<p>则相遇时，</p>
<p><strong>快指针路程=a+（b+c）k+b，k&gt;=1</strong>，其中b+c为环的长度，k为环的圈数（k&gt;=1，即最少一圈，不能是0圈，不然快慢指针走的路程一样，矛盾）。</p>
<p><strong>慢指针路程=a+b</strong>。</p>
<p>因为快指针的路程是慢指针的路程的两倍，所以：<strong>（a+b）*2=a+（b+c）k+b</strong>。</p>
<p>化简得：</p>
<p><strong>a=（k-1）（b+c）+c</strong>，这个式子的意思是：<strong>链表头到环入口的距离=相遇点到环入口的距离+（k-1）圈数环长度</strong>。其中k&gt;=1，所以k-1&gt;=0圈。所以两个指针分别从链表头和相遇点出发，最后一定相遇于环入口。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> nowcoder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/1/21  0:40</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryNodeOfLoop</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义链表结构</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        ListNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义快慢指针</span></span><br><span class="line">        ListNode fast = pHead;</span><br><span class="line">        ListNode slow = pHead;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="comment">//如果有环，想遇于环中某点</span></span><br><span class="line">            <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果没有环，return null</span></span><br><span class="line">        <span class="keyword">if</span> (fast.next == <span class="keyword">null</span> || fast.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果有环，两个指针分别从链表头和相遇点出发，最终必定在环入口相遇</span></span><br><span class="line">        slow = pHead;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过截图"><a href="#通过截图" class="headerlink" title="通过截图"></a>通过截图</h2><p><img src="/images/链表中环的入口节点/2.jpg" alt="img"></p>
<p><strong>参考来自牛客网的Java牛人（却顾所来径）的题解，觉得他写的真的很好，所以分享一波。</strong></p>
<p><strong>PS：今天刚从广州回到普宁，路上一直塞车，到晚上10点多才到家，洗完澡又觉得还有点精神，所以参考（却顾所来径）大神的题解，分享了一波链表中的环入口结点，真的觉得挺有意思的。最后就是快要过年了，在学校搞老师的毕业设计弄到19号，20号回家又塞车，等于我颓废了几天了，然后就是想说，这两天应该就是要好好过年帮忙了，看到有意思的题我会试着写它们的题解，觉得我写的还好的帮忙点点赞，关注一波。不出意外的话，今年毕业找到工作后，那个时候我应该会试着更新在工作上学到的技术和遇到的难点，相信自己的努力终有一天会有回报吧，谢谢你们对我的支持~~~</strong></p>
]]></content>
      <categories>
        <category>LeetCode&amp;牛客题解</category>
      </categories>
      <tags>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串的排列</title>
    <url>/2020/01/18/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>输入一个字符串，按字典序打印出该字符串中字符的所有排列。例如输入字符串abc，则打印出由字符a，b，c所能排列出来的所有字符串abc，acb，bac，bca，cab，cba。</p>
</blockquote>
<a id="more"></a>
<h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h2><blockquote>
<p>输入一个字符串，长度不超过9（可能有字符重复），字符只包括大小写字母。</p>
</blockquote>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote>
<p>该题目的解法原型就是全排列算法，给一个abc字符串有6种不同的排列。然后这道题是要在全排列的基础上做到字典序排序。</p>
</blockquote>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/1/18  20:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Permutation_nowcoder</span> </span>&#123;</span><br><span class="line">    <span class="comment">//全排列入口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;String&gt; <span class="title">Permutation</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (str != <span class="keyword">null</span> &amp;&amp; str.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            permutation(str.toCharArray(), <span class="number">0</span>, list);</span><br><span class="line">            Collections.sort(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//全排列实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">permutation</span><span class="params">(<span class="keyword">char</span>[] arr, <span class="keyword">int</span> i, ArrayList&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == arr.length - <span class="number">1</span>) &#123;</span><br><span class="line">            list.add(String.valueOf(arr[i]));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == i || !set.contains(arr[j])) &#123;</span><br><span class="line">                    set.add(arr[j]);</span><br><span class="line">                    swap(arr, i, j);</span><br><span class="line">                    permutation(arr, i + <span class="number">1</span>, list);</span><br><span class="line">                    swap(arr, j, i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换两个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过截图"><a href="#通过截图" class="headerlink" title="通过截图"></a>通过截图</h2><p><img src="/images/字符串的排列/2.jpg" alt="img"></p>
<p><strong>PS：今天在学校实验室弄我的深度学习的毕业设计项目的第一步目标检测，弄了至少两个星期了才搞好图片的目标检测，用的是yolov3来做检测，本来在自己的电脑跑一小部分数据是没问题的，到了实验室跑全部数据是巨多小问题，后面都解决了，谢天谢地哈哈哈。准备从广州回家过年了，这段时间过得还是挺充足的，每天都有学到新的东西，但是今天的这道题确实有点水了，勿怪哈~~~</strong></p>
]]></content>
      <categories>
        <category>LeetCode&amp;牛客题解</category>
      </categories>
      <tags>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>顺时针打印矩阵</title>
    <url>/2020/01/17/%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印每一个数字，例如，如果输入如下4*4矩阵：</p>
<p>1     2     3    4</p>
<p> 5     6    7    8</p>
<p> 9    10  11  12 </p>
<p>13  14  15   16 </p>
<p>则依次打印出数字1，2，3，4，8，12，16，15，14，13，9，5，6，7，11，10。</p>
</blockquote>
<a id="more"></a>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol>
<li>因为一个二维平面，给定两个坐标（x1, y1）和（x2, y2）可以唯一确定一个矩阵。</li>
<li>然后可以通过圈子来打印对应的矩阵，然后缩小圈子完成整个过程即可。</li>
</ol>
<h2 id="图解过程"><a href="#图解过程" class="headerlink" title="图解过程"></a>图解过程</h2><p><img src="/images/顺时针打印矩阵/2.jpg" alt="img"></p>
<p><strong>这个时候就打印出了1，2，3，4，8，12，16，15，14，13，9，5。</strong></p>
<p><strong>然后这个时候缩小圈子继续重复：</strong></p>
<p><img src="/images/顺时针打印矩阵/3.jpg" alt="img"></p>
<p><strong>这个时候继续打印出6，7，11，10。然后全部拼接起来就是答案了。</strong></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/1/17  20:58</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ArrayList&lt;Integer&gt; resList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//拿到左上角(x1, y1)和右下角(x2, y2)</span></span><br><span class="line">        <span class="keyword">int</span> x1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> y1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> x2 = matrix.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> y2 = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//顺时针打印圈子的数值</span></span><br><span class="line">        <span class="keyword">while</span> (x1 &lt;= x2 &amp;&amp; y1 &lt;= y2) &#123;</span><br><span class="line">            helpPrintMatrix(matrix, x1++, y1++, x2--, y2--);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">helpPrintMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x1 == x2) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = y1; i &lt;= y2; i++) &#123;</span><br><span class="line">                resList.add(matrix[x1][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (y1 == y2) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = x1; i &lt;= x2; i++) &#123;</span><br><span class="line">                resList.add(matrix[i][y1]);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//知道（x1, y1）和（x2, y2）可以确定一个矩阵</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> curX = x1;</span><br><span class="line">            <span class="keyword">int</span> curY = y1;</span><br><span class="line">            <span class="keyword">while</span> (curY != y2) &#123;</span><br><span class="line">                resList.add(matrix[x1][curY]);</span><br><span class="line">                curY++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (curX != x2) &#123;</span><br><span class="line">                resList.add(matrix[curX][y2]);</span><br><span class="line">                curX++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (curY != y1) &#123;</span><br><span class="line">                resList.add(matrix[x2][curY]);</span><br><span class="line">                curY--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (curX != x1) &#123;</span><br><span class="line">                resList.add(matrix[curX][y1]);</span><br><span class="line">                curX--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过截图："><a href="#通过截图：" class="headerlink" title="通过截图："></a>通过截图：</h2><p><img src="/images/顺时针打印矩阵/4.jpg" alt="img"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>如果你要是通过规律来顺时针打印矩阵的话会显得非常麻烦，我不是说不按照我的方法做不出来，只是会比较麻烦，coding能力较差的人可能会写不出来，但是把一个矩阵分解成多个圈子打印即可，打印单独写一个函数即可完成。</p>
</blockquote>
<p><strong>PS：觉得博主写的还可以的点点赞，关注走一波，谢谢大家的支持了~~~</strong></p>
]]></content>
      <categories>
        <category>LeetCode&amp;牛客题解</category>
      </categories>
      <tags>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title>复杂链表的复制</title>
    <url>/2020/01/16/%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判断程序会直接返回空）</p>
</blockquote>
<a id="more"></a>
<h2 id="两种策略解决"><a href="#两种策略解决" class="headerlink" title="两种策略解决"></a>两种策略解决</h2><h2 id="策略1（HashMap解决）"><a href="#策略1（HashMap解决）" class="headerlink" title="策略1（HashMap解决）"></a>策略1（HashMap解决）</h2><ol>
<li>先用一个HashMap的key存放原来的链表，value存放key的值。</li>
<li>知道了key的指向，然后让value跟着key一样的指向即可。</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/1/16  18:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomListNodeCopy</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义复杂链表的结构</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> label;</span><br><span class="line">        RandomListNode next = <span class="keyword">null</span>;</span><br><span class="line">        RandomListNode random = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        RandomListNode(<span class="keyword">int</span> label) &#123;</span><br><span class="line">            <span class="keyword">this</span>.label = label;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode pHead)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;RandomListNode, RandomListNode&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        RandomListNode cur = pHead;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            map.put(cur, <span class="keyword">new</span> RandomListNode(cur.label));</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = pHead;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            map.get(cur).next = map.get(cur.next);</span><br><span class="line">            map.get(cur).random = map.get(cur.random);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(pHead);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过截图"><a href="#通过截图" class="headerlink" title="通过截图"></a>通过截图</h2><p><img src="/images/复杂链表的复制/3.jpg" alt="img"></p>
<h2 id="HashMap解法总结"><a href="#HashMap解法总结" class="headerlink" title="HashMap解法总结"></a>HashMap解法总结</h2><blockquote>
<p>用HashMap做简单，容易理解，时间复杂度为O(N)，空间复杂度也为O(N)，其实这道题还可以做到时间复杂度为O(N)，空间复杂度为O(1)，就是我接下来介绍的这种解法。</p>
</blockquote>
<hr>
<h2 id="策略2（创建拆分）"><a href="#策略2（创建拆分）" class="headerlink" title="策略2（创建拆分）"></a>策略2（创建拆分）</h2><ol>
<li>遍历链表，复制每个节点，如复制节点A得到A1，将节点A1插到节点A后面</li>
<li>重新遍历链表，复制旧节点的随机指针给新节点，如A1.random = A.random.next</li>
<li>拆分链表，将链表拆分为原链表和复制后的链表</li>
</ol>
<h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><p><img src="/images/复杂链表的复制/2.jpg" alt="img"></p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/1/16  18:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomListNodeCopy</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义复杂链表的结构</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> label;</span><br><span class="line">        RandomListNode next = <span class="keyword">null</span>;</span><br><span class="line">        RandomListNode random = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        RandomListNode(<span class="keyword">int</span> label) &#123;</span><br><span class="line">            <span class="keyword">this</span>.label = label;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并拆分的时间复杂度为O(N)，空间复杂度为O(1)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        RandomListNode cur = pHead;</span><br><span class="line">        <span class="comment">//1、复制每个结点，如复制结点A得到A1，将结点A1插到结点A后面；</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            RandomListNode cloneNode = <span class="keyword">new</span> RandomListNode(cur.label);</span><br><span class="line">            RandomListNode nextNode = cur.next;</span><br><span class="line">            cur.next = cloneNode;</span><br><span class="line">            cloneNode.next = nextNode;</span><br><span class="line">            cur = nextNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur = pHead;</span><br><span class="line">        <span class="comment">//2、重新遍历链表，复制老结点的随机指针给新结点，如A1.random = A.random.next;</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cur.next.random = cur.random == <span class="keyword">null</span> ? <span class="keyword">null</span> : cur.random.next;</span><br><span class="line">            cur = cur.next.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、拆分链表，将链表拆分为原链表和复制后的链表</span></span><br><span class="line">        cur = pHead;</span><br><span class="line">        RandomListNode pCloneHead = pHead.next;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            RandomListNode cloneNode = cur.next;</span><br><span class="line">            cur.next = cloneNode.next;</span><br><span class="line">            cloneNode.next = cloneNode.next == <span class="keyword">null</span> ? <span class="keyword">null</span> : cloneNode.next.next;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pCloneHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过截图-1"><a href="#通过截图-1" class="headerlink" title="通过截图"></a>通过截图</h2><p><img src="/images/复杂链表的复制/4.jpg" alt="img"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>一道好的题目往往有多种解决的办法，大二时期的我就只会用最基础的贪心和暴力解决各类问题，不是说暴力解法不好，只是有时候有更好的算法可以解决我们又为何不去掌握呢。所以一道题目的多种的解法我都会好好研读和学习。希望也有人喜欢和我一样多了解多种解法，扩展一下自己的思路，嘿嘿嘿。。。</p>
</blockquote>
<p><strong>PS：如果觉得博主写的不错的话可以点点赞，关注走一波，谢谢大家的支持了~~~</strong></p>
]]></content>
      <categories>
        <category>LeetCode&amp;牛客题解</category>
      </categories>
      <tags>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title>神级算法——二分天下</title>
    <url>/2020/01/11/%E7%A5%9E%E7%BA%A7%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E4%BA%8C%E5%88%86%E5%A4%A9%E4%B8%8B/</url>
    <content><![CDATA[<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><blockquote>
<p>二分查找也称折半查找（Binary Search），它是一种效率较高得查找方法。一般都是要求线性表有序，然后二分查找的时间复杂度为O(logN)。</p>
</blockquote>
<a id="more"></a>
<h2 id="不一样的二分"><a href="#不一样的二分" class="headerlink" title="不一样的二分"></a>不一样的二分</h2><blockquote>
<p>如果数组无序，难道就不能用二分查找了吗？答案是否定的，即使一个数组无序，也可以用二分查找来找。下面我就用两个例子来给你们上一课（膨胀了我，哈哈~~~）</p>
</blockquote>
<h2 id="例子1（旋转数组）："><a href="#例子1（旋转数组）：" class="headerlink" title="例子1（旋转数组）："></a>例子1（旋转数组）：</h2><blockquote>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
</blockquote>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><blockquote>
<p>即使数组无序，但是我们还是可以使用二分查找来找出最小值。因为旋转数组部分有序，利用二分查找还是很容易查找到最小值</p>
</blockquote>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span> ; <span class="keyword">int</span> high = array.length - <span class="number">1</span>;  </span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;       </span><br><span class="line">            <span class="keyword">if</span>(array[mid] &gt; array[high])&#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                high = mid;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[low];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过："><a href="#通过：" class="headerlink" title="通过："></a>通过：</h2><p><img src="/images/二分法/2.jpg" alt="img"></p>
<p><strong>可能有人会觉得，即使无序可以使用二分查找，但是你这个旋转数组也是部分有序，所以可以使用二分查找。接下来我再讲解一道题来证明给你看——查找局部最小值。</strong></p>
<h2 id="例子2（查找局部最小值）"><a href="#例子2（查找局部最小值）" class="headerlink" title="例子2（查找局部最小值）"></a><strong>例子2（查找局部最小值）</strong></h2><blockquote>
<p>定义局部最小的概念。arr数组长度为1时，arr[0]是局部最小。arr的长度为N(N&gt;1)时，如果arr[0]&lt;arr[1]，那么arr[0]是局部最小；如果arr[N-1]&lt;arr[N-2]，那么arr[N-1]是局部最小；如果0&lt;i&lt;N-1，既有arr[i]&lt;arr[i-1]，又有arr[i]&lt;arr[i+1]，那么arr[i]是局部最小。 给定无序数组arr，已知arr中任意两个相邻的数都不相等。写一个函数，只需返回arr中任意一个局部最小出现的位置即可。</p>
</blockquote>
<h2 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h2><ul>
<li>先查找arr[0]和arr[N-1]，即第一个数和最后一个数是不是局部最小，如果是，直接返回这个数即可。</li>
<li>如果arr[0]&gt;arr[1]，arr[N-1]&gt;arr[N-2]，那么此时的情况就是这样的：</li>
</ul>
<p><img src="/images/二分法/z.jpg" alt="img"></p>
<h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/1/11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindOneLessValueIndex</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLessIndex</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果不存在直接return -1</span></span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先看arr[0]和arr[N-1]是不是局部最小，是的话直接返回即可</span></span><br><span class="line">        <span class="keyword">if</span> (arr.length == <span class="number">1</span> || arr[<span class="number">0</span>] &lt; arr[<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[arr.length - <span class="number">1</span>] &lt; arr[arr.length - <span class="number">2</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> arr.length - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//然后中间部分使用二分</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = arr.length - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] &gt; arr[mid - <span class="number">1</span>]) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; arr[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        printArray(arr);</span><br><span class="line">        <span class="keyword">int</span> index = getLessIndex(arr);</span><br><span class="line">        System.out.println(<span class="string">"index: "</span> + index + <span class="string">", value: "</span> + arr[index]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h2><p><img src="/images/二分法/x.jpg" alt="img"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>看了上面的两个例子，是不是颠覆了你对二分查找的认知。哈哈。不是说一定要有序才能用二分查找，只要你确定了某一部分一定有你要找的，你就可以二分下去找。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法积累ing</category>
      </categories>
      <tags>
        <tag>算法进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>单调栈及其应用</title>
    <url>/2020/01/08/%E5%8D%95%E8%B0%83%E6%A0%88%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><blockquote>
<p>博主是因为在刷LeetCode题的时候才知道有单调栈这个数据结构，说起来也是真的巧妙。一开始是在LeetCode739题（每日温度）接触到的，其实单调栈就是从数组中找到左右两边比你大的数或者比你小的数而且时间复杂度为O(N)。以下讲一些单调栈的特性和一些应用题</p>
</blockquote>
<a id="more"></a>
<h2 id="什么是单调栈"><a href="#什么是单调栈" class="headerlink" title="什么是单调栈"></a>什么是单调栈</h2><p><strong>单调栈就是栈里面存放的数据都是有序的，所以可以分为单调递增栈和单调递减栈两种。</strong></p>
<ol>
<li>单调递增栈就是从栈底到栈顶是从大到小</li>
<li>单调递减栈就是从栈底到栈顶是从小到大</li>
</ol>
<h2 id="单调栈的经典题目（求最大子矩阵的大小）"><a href="#单调栈的经典题目（求最大子矩阵的大小）" class="headerlink" title="单调栈的经典题目（求最大子矩阵的大小）"></a>单调栈的经典题目（求最大子矩阵的大小）</h2><blockquote>
<p>【题目】<br>给定一个整型矩阵map，其中的值只有0和1两种，求其中全是1的所有矩形区域中，最大的矩形区域为1的数量。<br>例如：<br>1  1  1  0<br>其中，最大的矩形区域有3个1，所以返回3。<br>再如：<br>1  0  1  1<br>1  1  1  1<br>1  1  1  0<br>其中，最大的矩形区域有6个1，所以返回6.</p>
</blockquote>
<p><strong>要想解答这道题，我先引入另一道题来更好得帮你理解。</strong></p>
<blockquote>
<p>给出一个矩形统计图，它的每个矩形的宽度都为1，高度是题目所给。要你求出这个矩形图中最大面积的长方形。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">矩形统计图的数据为 [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure>
<p><img src="/images/单调栈/2.jpg" alt="img"></p>
<p><strong>思路：</strong></p>
<p>准备一个栈，栈低到栈顶是从小到大的。栈如图所示</p>
<p><img src="/images/单调栈/3.jpg" alt="img"></p>
<ol>
<li>第一个下标是0，值是4，栈为空，放入栈中。</li>
<li>第二个下标为1，值为3，比栈顶（此时是4）小，不符合栈低到栈顶从小到大，所以弹出栈顶（4），此时4最左边界就是-1，最右就是1，所以弹出的面积就是4 *（1-（-1）-1）为4；然后3入栈</li>
<li>第三个下标为2，值为2，比栈顶（此时是3）小，不符合栈低到栈顶从小到大，所以弹出栈顶（3），此时3的最左边界是-1，最右就是2，所以弹出的面积是3 *（2-（-1）-1）为6；然后2入栈</li>
<li>第四个下标为3，值为5，比栈顶（此时是2）大，符合栈低到栈顶从小到大，所以5入栈</li>
<li>第五个下标为4，值为6，比栈顶（此时是6）大，符合栈低到栈顶从小到大，所以6入栈</li>
<li>此时没有值可以入栈了，弹出6，此时6的最左边界就是栈顶（5）的下标3，最右边界就是5，所以弹出的面积是6 *（5-（3）-1）为6</li>
<li>继续出栈，面积为5 *（5-（2）-1）为10；</li>
<li>继续出栈，面积为2 *（5-（-1）-1）为10；</li>
<li>最大值就是10，所以输入10</li>
</ol>
<p><strong>ps：建议画图，然后按照我上面写的步骤尝试一遍，你就很清楚整个过程了。</strong></p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a><strong>代码：</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/1/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaximalRectangle</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给定一个数组[4,3,2,5,6]，每一个数代表一个矩形的高度，组成的一个二维数组，求其中的最大矩形</span></span><br><span class="line"><span class="comment">     * 解法，用最大单调栈的结构来求解，用来求解一个连续的无规则面积中最大的矩形面积</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxRecFromBottom</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (height.length &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//从小到大的单调栈</span></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">//这一步是在求每次遇到不是单调递增的时候那个柱子的面积</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.length; i++) &#123;</span><br><span class="line">            <span class="comment">//如果栈不为空，且当前元素小于栈顶元素</span></span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; height[i] &lt;= height[stack.peek()]) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = stack.pop();</span><br><span class="line">                <span class="comment">//左边界</span></span><br><span class="line">                <span class="keyword">int</span> k = stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">                <span class="comment">//(右边界 - 左边界)*高度</span></span><br><span class="line">                <span class="keyword">int</span> curArea = (i - k - <span class="number">1</span>) * height[j];</span><br><span class="line">                maxArea = Math.max(maxArea, curArea);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//求整个单调递增的面积</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = stack.pop();</span><br><span class="line">            <span class="keyword">int</span> k = stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">            <span class="comment">//当前的右边界就是数组长度</span></span><br><span class="line">            <span class="keyword">int</span> curArea = (height.length - k - <span class="number">1</span>) * height[j];</span><br><span class="line">            maxArea = Math.max(maxArea, curArea);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>回归正题，来解答一开始的那道题</strong></p>
<blockquote>
<p>思路就是当传入一个二维数组的时候，我们把它压缩成一个一维数组的形式进行解答。<br>从第0行开始调用我们上面那个求矩形的面积的函数，求完求第0行到第一行，依次类推，反正当前要是有0的话就是0，不是0就加1.</p>
</blockquote>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/1/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaximalRectangle</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给定一个数组[4,3,2,5,6]，每一个数代表一个矩形的高度，组成的一个二维数组，求其中的最大矩形</span></span><br><span class="line"><span class="comment">     * 解法，用最大单调栈的结构来求解，用来求解一个连续的无规则面积中最大的矩形面积</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxRecFromBottom</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (height.length &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//从小到大的单调栈</span></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">//这一步是在求每次遇到不是单调递增的时候那个柱子的面积</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.length; i++) &#123;</span><br><span class="line">            <span class="comment">//如果栈不为空，且当前元素小于栈顶元素</span></span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; height[i] &lt;= height[stack.peek()]) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = stack.pop();</span><br><span class="line">                <span class="comment">//左边界</span></span><br><span class="line">                <span class="keyword">int</span> k = stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">                <span class="comment">//(右边界 - 左边界)*高度</span></span><br><span class="line">                <span class="keyword">int</span> curArea = (i - k - <span class="number">1</span>) * height[j];</span><br><span class="line">                maxArea = Math.max(maxArea, curArea);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//求整个单调递增的面积</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = stack.pop();</span><br><span class="line">            <span class="keyword">int</span> k = stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">            <span class="comment">//当前的右边界就是数组长度</span></span><br><span class="line">            <span class="keyword">int</span> curArea = (height.length - k - <span class="number">1</span>) * height[j];</span><br><span class="line">            maxArea = Math.max(maxArea, curArea);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxRecSize</span><span class="params">(<span class="keyword">int</span>[][] map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (map.length &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] height = <span class="keyword">new</span> <span class="keyword">int</span>[map[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; map.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; map[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="comment">//如果当前行不是0，则累加高度</span></span><br><span class="line">                <span class="keyword">if</span> (map[i][j] != <span class="number">0</span>)</span><br><span class="line">                    height[j] += map[i][j];</span><br><span class="line">                <span class="keyword">else</span><span class="comment">//如果当前行的值为0，则高度为0</span></span><br><span class="line">                    height[j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//求出每一行的最大矩形面积</span></span><br><span class="line">            maxArea = Math.max(maxRecFromBottom(height), maxArea);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>以上就是我接触到的单调栈，当然有许多的应用，但是也不可能一一列举，只是抽出比较经典的题目来讲一下，然后就是觉得写得还不错的给博主点点赞和关注一波，谢谢大家的支持了。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法积累ing</category>
      </categories>
      <tags>
        <tag>算法进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>栈(Stack)与队列(Queue)</title>
    <url>/2020/01/06/%E6%A0%88-Stack-%E4%B8%8E%E9%98%9F%E5%88%97-Queue/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>栈：后进先出（LIFO-last in first out）：最后插入的元素最先出来。<br>队列：先进先出（FIFO-first in first out）：最先插入的元素最先出来。</p>
</blockquote>
<a id="more"></a>
<h2 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h2><p><img src="/images/栈与队列/栈与队列.jpg" alt="img"></p>
<p><strong>本文通过一些简单的算法题来带你们更好的理解栈(Stack)和队列(Queue)。</strong></p>
<h2 id="三道算法题加深理解"><a href="#三道算法题加深理解" class="headerlink" title="三道算法题加深理解"></a>三道算法题加深理解</h2><h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a><strong>第一题</strong></h3><p><strong>题目：获取一个栈的min</strong></p>
<blockquote>
<p><strong>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O(1)）。</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/1/6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Format3</span> </span>&#123;</span><br><span class="line">    <span class="comment">//正常stack</span></span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="comment">//存放min的stack</span></span><br><span class="line">    Stack&lt;Integer&gt; help = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack.push(node);</span><br><span class="line">        <span class="keyword">if</span> (help.isEmpty()) &#123;</span><br><span class="line">            help.push(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//help里面存放的都是最小值,也就是pop之后里面是当前的最小值</span></span><br><span class="line">            <span class="keyword">int</span> res = help.peek() &gt; node ? node : help.peek();</span><br><span class="line">            help.push(res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack.pop();</span><br><span class="line">        help.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> help.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><p><strong>题目：用栈实现队列</strong></p>
<p><strong>思路：构建两个栈（Push栈和Pop栈）;将Push栈中的数据导入Pop栈中然后返回给用户，就实现了队列。需要注意两个条件：①Pop栈为空时才能往里面倒数据。②向Pop栈倒数据必须全部倒完。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/1/6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackToQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">//用s1、s2避免代码看起来混乱，因为都是push和pop操作</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; s1;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; s2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StackToQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        s1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        s2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> obj)</span> </span>&#123;</span><br><span class="line">        s1.push(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.isEmpty() &amp;&amp; s2.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"empty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s2.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!s1.isEmpty()) &#123;</span><br><span class="line">                s2.push(s1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s2.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.isEmpty() &amp;&amp; s2.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"empty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s2.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!s1.isEmpty()) &#123;</span><br><span class="line">                s2.push(s1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h3><p><strong>题目：用队列实现栈</strong></p>
<p><strong>思路：构建两个队列：queue队列和help队列；压入数据时数据都进queue队列，假设队列中进入了1、2、3、4、5，返回数据时，把1、2、3、4放入help队列，然后拿出queue的5返回。接着把queue队列和help队列的引用交换。即下次返回数据还是从queue队列拿1、2、3、放入help队列，然后queue拿出4返回，再交换各自的引用，一直重复。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/1/6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueToStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; help;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">QueueToStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        help = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Integer e)</span> </span>&#123;</span><br><span class="line">        queue.add(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"empty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (queue.size() != <span class="number">1</span>) &#123;</span><br><span class="line">            help.add(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = queue.poll();</span><br><span class="line">        swap();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"empty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (queue.size() != <span class="number">1</span>) &#123;</span><br><span class="line">            help.add(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = queue.poll();</span><br><span class="line">        help.add(res);</span><br><span class="line">        swap();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; tmp = queue;</span><br><span class="line">        queue = help;</span><br><span class="line">        help = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>就是把栈跟队列的特点介绍了一下，然后用三道经典的题目来加深对栈和队列的理解，然后附上我自己写的代码，都是经过测试后才附上的。有什么问题，欢迎与我交流和讨论，我的目的就是大家一起学习一起进步。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法积累ing</category>
      </categories>
      <tags>
        <tag>栈与队列</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈hash函数及应用</title>
    <url>/2020/01/04/%E6%B5%85%E8%B0%88hash%E5%87%BD%E6%95%B0%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h2 id="一、Hash-散列函数"><a href="#一、Hash-散列函数" class="headerlink" title="一、Hash(散列函数)"></a>一、Hash(散列函数)</h2><blockquote>
<p>Hash一般被翻译成散列、杂凑或音译为哈希，是把任意长度的输入（又叫做预映射pre-image）通过散列算法变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列出相同的输出，所以不可能从散列值来确定唯一的输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。（<strong>介绍来源于百度百科</strong>）</p>
</blockquote>
<a id="more"></a>
<h3 id="Hash函数性质："><a href="#Hash函数性质：" class="headerlink" title="Hash函数性质："></a>Hash函数性质：</h3><ol>
<li>输入为任意长度字符串，输出为固定长度字符串。</li>
<li>输入确定，输出也确定。特定输入对应唯一输出（有可能两个输入对应一个输出——<strong>hash碰撞</strong>，解决碰撞有<strong>链地址法</strong>和<strong>开发地址法</strong>，这里就不展开了，就浅谈一下就好了）</li>
<li>随着输入域的增大，输出域均匀增大（这种均匀性越好，hash函数越好）</li>
</ol>
<hr>
<h2 id="二、设计RandomPool结构"><a href="#二、设计RandomPool结构" class="headerlink" title="二、设计RandomPool结构"></a>二、设计RandomPool结构</h2><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><blockquote>
<p>【题目】</p>
<p>设计一种结构，在该结构中有如下三个功能：</p>
<p>insert(key)：将某个key加入到该结构，做到不重复加入。</p>
<p>delete(key)：将原本在结构中的某个key移除。</p>
<p>getRandom()：等概率随机返回结构中的任何一个key。</p>
<p>【要求】</p>
<p>insert、delete和getRandom方法的时间复杂度都是O(1)</p>
</blockquote>
<h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><blockquote>
<p>insert：</p>
<p>构造map&lt;key,Integer&gt; keyIndexMap，map&lt;Integer,key&gt; indexKeyMap。当第一个插入o1，就在keyIndexMap.add（o1,1）,indexKeyMap.add(1,o1)。</p>
<p>getRandom：</p>
<p>通过数字进行random，得到的就是等概率的。（保证0~Integer是连续的就可以保证等概率）。</p>
<p>delete：</p>
<p>删除后存在空位，这些空位会影响到0~Integer是连续的。解决办法：拿最后一条记录填补空位。</p>
</blockquote>
<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/1/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomPool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pool</span>&lt;<span class="title">K</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> HashMap&lt;K,Integer&gt; keyIndexMap;</span><br><span class="line">        <span class="keyword">private</span> HashMap&lt;Integer,K&gt; indexKeyMap;</span><br><span class="line">        <span class="comment">//size记录第几个进来的</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Pool</span><span class="params">()</span></span>&#123;</span><br><span class="line">            keyIndexMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            indexKeyMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//插入操作分别插入到keyIndexMap和indexKeyMap中</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!keyIndexMap.containsKey(key))&#123;</span><br><span class="line">                 keyIndexMap.put(key,size);</span><br><span class="line">                indexKeyMap.put(size++,key);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// A 0 0 A</span></span><br><span class="line">        <span class="comment">// B 1 1 B</span></span><br><span class="line">        <span class="comment">// C 2 2 C</span></span><br><span class="line">        <span class="comment">// D 3 3 D</span></span><br><span class="line">        <span class="comment">//先确定删除的索引，以及最后面的值，把最后面的值补充到删除的地方</span></span><br><span class="line">        <span class="comment">//之后删除开始应该删除的</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(keyIndexMap.containsKey(key))&#123;</span><br><span class="line">                <span class="keyword">int</span> deleteIndex = keyIndexMap.get(key);</span><br><span class="line">                <span class="keyword">int</span> lastIndex = --size;</span><br><span class="line">                K lastKey = indexKeyMap.get(lastIndex);</span><br><span class="line">                keyIndexMap.put(lastKey,deleteIndex);</span><br><span class="line">                indexKeyMap.put(deleteIndex,lastKey);</span><br><span class="line">                keyIndexMap.remove(key);</span><br><span class="line">                indexKeyMap.remove(lastIndex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//等概率从indexKeyMap返回key</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> K <span class="title">random</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(size==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> num = (<span class="keyword">int</span>) (Math.random()*size);</span><br><span class="line">            <span class="keyword">return</span> indexKeyMap.get(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="三、布隆过滤器"><a href="#三、布隆过滤器" class="headerlink" title="三、布隆过滤器"></a>三、布隆过滤器</h2><h3 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h3><blockquote>
<p>布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量（位图）和一系列随机映射函数（哈希函数）。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询效率到远远超于一般的算法，缺点是有一定的误识别率和删除困难。</p>
</blockquote>
<h3 id="操作过程"><a href="#操作过程" class="headerlink" title="操作过程"></a>操作过程</h3><p>布隆过滤器最重要的实现就是位图的实现，也就是位数组，并且在这个数组中每一个位置只占有一个bit，而每个bit只有0和1两种状态。</p>
<p>假设有k个哈希函数，且每个哈希函数的输出范围都大于m，我们就把输出值对k取余（%m），就会得到k个[0,m-1]的值，由于每个哈希函数之间相互独立，因此这k个数也相互独立，最后将这k个数对应到的bit标记为1（涂黑）</p>
<p>等判断时，将输入对象经过这k个哈希函数计算得到k个值，然后判断对应的bit位是否都为1（涂黑），<strong>如果有一个不为黑，那么这个输入对象则不在这个集合中，也就不是黑名单！如果都是黑，说明在集合中，但是有可能有误</strong>。</p>
<h3 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h3><p><img src="/images/浅谈hash/1.jpg" alt=""></p>
<h3 id="重要参数计算"><a href="#重要参数计算" class="headerlink" title="重要参数计算"></a>重要参数计算</h3><p>通过上面的描述，如果输入量过大，而bit空间很小，那么误判率会上升。那么要怎么平衡bit空间呢，已经有大神通过数据推导出公式了~~~</p>
<p>假设输入对象个数为n，bit大小为m，所能容忍的误判率为p和哈希函数的个数为k。计算公式如下（小数向上取整）</p>
<p><img src="/images/浅谈hash/2.jpg" alt=""></p>
<p><strong>注意：由于我们计算的m和k可能为小数，通过向上取整，此时的误判率会下降</strong></p>
<hr>
<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><blockquote>
<p>以上就是浅谈hash函数及应用。当然hash函数的应用还有很多，我也只是略懂皮毛，写下这一篇加深我对hash的理解和应用，仅此而已。</p>
</blockquote>
<h2 id="五、参考来源"><a href="#五、参考来源" class="headerlink" title="五、参考来源"></a>五、参考来源</h2><p><a href="https://baike.baidu.com/item/Hash/390310?fr=aladdin" target="_blank" rel="noopener">hash百度百科</a></p>
<p><a href="http://www.bubuko.com/infodetail-2710292.html" target="_blank" rel="noopener">RandomPool结构</a></p>
<p><a href="https://blog.csdn.net/weixin_41576121/article/details/94723342" target="_blank" rel="noopener">布隆过滤器</a></p>
]]></content>
      <categories>
        <category>算法积累ing</category>
      </categories>
      <tags>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>数据流中的中位数解法</title>
    <url>/2020/01/03/%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%E8%A7%A3%E6%B3%95/</url>
    <content><![CDATA[<h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><blockquote>
<p>越来越多的程序员关注数据结构和算法的知识，会在leetcode和牛客等各种网站刷题，但是遇到一些中等难度或者困难难度的题就束手无策，而我通过刷题来写一些关于中等或者困难的题目的题解，达到一个自己越来越熟悉，而且还可以帮助别人理解的程度。接下来我会用两种策略来解决这道题——数据流中的中位数。</p>
</blockquote>
<a id="more"></a>
<h2 id="数据流中的中位数解法"><a href="#数据流中的中位数解法" class="headerlink" title="数据流中的中位数解法"></a>数据流中的中位数解法</h2><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><blockquote>
<p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。</p>
</blockquote>
<h3 id="Solution（两种解决策略）"><a href="#Solution（两种解决策略）" class="headerlink" title="Solution（两种解决策略）"></a>Solution（两种解决策略）</h3><hr>
<h4 id="解决策略1"><a href="#解决策略1" class="headerlink" title="解决策略1"></a>解决策略1</h4><ol>
<li>建立一个大根堆和一个小根堆，用一个临时变量（count）来统计数据流的个数</li>
<li>当插入的数字个数为奇数时，使小根堆的个数比大根堆多1；当插入的数字个数为偶数时，使大根堆和小根堆的个数一样多</li>
<li>当总的个数为奇数时，中位数就是小根堆的堆顶；当总的个数为偶数时，中位数就是两个堆顶的值相加除以2</li>
</ol>
<h4 id="Code1"><a href="#Code1" class="headerlink" title="Code1"></a>Code1</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/1/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; min = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; max = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o2 - o1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//统计数据流的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//确保小根堆里面的数 &gt; 大根堆里面的数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span> (count % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//奇数的时候，放在小根堆里面</span></span><br><span class="line">            max.offer(num);<span class="comment">//先从大顶堆过滤一遍</span></span><br><span class="line">            min.offer(max.poll());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//偶数的时候，放在大根堆里面</span></span><br><span class="line">            min.offer(num);<span class="comment">//先从小顶堆过滤一遍</span></span><br><span class="line">            max.offer(min.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">GetMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> (min.peek() + max.peek()) / <span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> (<span class="keyword">double</span>) min.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Test1"><a href="#Test1" class="headerlink" title="Test1"></a>Test1</h4><p><img src="/images/数据流中的中位数/1.jpg" alt=""></p>
<hr>
<h4 id="解决策略2"><a href="#解决策略2" class="headerlink" title="解决策略2"></a>解决策略2</h4><ol>
<li>建立一个大根堆和一个小根堆，必须确保满足两点：<ul>
<li>小根堆里面的数 &gt; 大根堆里面的数</li>
<li>大根堆和小根堆的个数差值必须 &lt;= 1</li>
</ul>
</li>
<li>当总的个数为偶数时：<ul>
<li>中位数就是（大根堆堆顶+小根堆堆顶）/ 2.0</li>
</ul>
</li>
<li>当总的个数为奇数时：<ul>
<li>大根堆的个数 &gt; 小根堆的个数，则中位数就是大根堆的堆顶</li>
<li>大根堆的个数 &lt; 小根堆的个数，则中位数就是小根堆的堆顶</li>
</ul>
</li>
</ol>
<h4 id="Code2"><a href="#Code2" class="headerlink" title="Code2"></a>Code2</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/1/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> </span>&#123;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; min = <span class="keyword">null</span>;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; max = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * initialize your data structure here.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MedianFinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//默认从小到大排序</span></span><br><span class="line">        min = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        <span class="comment">//修改比较器，让他从大到小排序</span></span><br><span class="line">        max = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2 - o1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//进来一个树先判断是不是小于大根堆堆顶，是就放大根堆，不是放小根堆</span></span><br><span class="line">        <span class="keyword">if</span> (max.size() == <span class="number">0</span> || max.peek() &gt; num) &#123;</span><br><span class="line">            max.add(num);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            min.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//保证两个堆的个数相差不大于1</span></span><br><span class="line">        <span class="keyword">if</span> (min.size() - max.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            max.add(min.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (max.size() - min.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            min.add(max.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = max.size() + min.size();</span><br><span class="line">        <span class="comment">//判断总的个数是否为偶数</span></span><br><span class="line">        <span class="keyword">if</span> ((count &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (max.peek() + min.peek()) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//总的个数是奇数的情况</span></span><br><span class="line">        <span class="keyword">if</span> (max.size() &gt; min.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> max.peek() / <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min.peek() / <span class="number">1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MedianFinder object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MedianFinder obj = new MedianFinder();</span></span><br><span class="line"><span class="comment"> * obj.addNum(num);</span></span><br><span class="line"><span class="comment"> * double param_2 = obj.findMedian();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h4 id="Test2"><a href="#Test2" class="headerlink" title="Test2"></a>Test2</h4><p><img src="/images/数据流中的中位数/2.jpg" alt=""></p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>今天介绍的是LeetCode上的困难题目——数据流中的中位数。其实可以用排序的方式进行计算，但是计算的话会耗费O(N*logN)的时间复杂度，代价太高。因为我们只关注数据流的中位数，为何要去排序呢。最后通过大根堆和小根堆进行操作就可以计算出中位数，时间代价也就O(logN)，空间复杂度为O(N)。</p>
</blockquote>
<h2 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h2><p><a href="https://leetcode-cn.com/problems/find-median-from-data-stream/submissions/" target="_blank" rel="noopener">LeetCode295.数据流的中位数</a></p>
<p><a href="https://www.nowcoder.com/practice/9be0172896bd43948f8a32fb954e1be1?tpId=13&amp;tqId=11216&amp;tPage=4&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">牛客网的数据流中的中位数</a></p>
]]></content>
      <categories>
        <category>LeetCode&amp;牛客题解</category>
      </categories>
      <tags>
        <tag>困难</tag>
      </tags>
  </entry>
  <entry>
    <title>滑动窗口算法</title>
    <url>/2020/01/01/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="滑动窗口操作"><a href="#滑动窗口操作" class="headerlink" title="滑动窗口操作"></a>滑动窗口操作</h2><ul>
<li>使用左右指针L、R</li>
<li>当一个数进入窗口时，必须从尾部进入，R向右移动一位</li>
<li>当一个数出窗口时，必须从头部出去，L向右移动一位</li>
<li>L、R只能向右移动，且R&gt;L</li>
</ul>
<hr>
<a id="more"></a>
<h2 id="算法原题-滑动窗口的最大值"><a href="#算法原题-滑动窗口的最大值" class="headerlink" title="算法原题(滑动窗口的最大值)"></a>算法原题(滑动窗口的最大值)</h2><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><blockquote>
<p>有一个整型数组arr和一个大小为w的窗口从数组的最左边滑到最右边，窗口每次向右边滑一个位置。<br>例如，数组为[4, 3, 5, 4, 3, 3, 6, 7]，窗口大小为3时：<br>[4 3 5] 4 3 3 6 7 窗口中最大值为5<br>4[3 5 4] 3 3 6 7 窗口中最大值为5<br>4 3[5 4 3] 3 6 7 窗口中最大值为5<br>4 3 5[4 3 3] 6 7 窗口中最大值为4<br>4 3 5 4[3 3 6] 7 窗口中最大值为6<br>4 3 5 4 3[3 6 7] 窗口中最大值为7<br>如果数组长度为n，窗口大小为w，则一共产生n - w + 1个窗口的最大值。<br>请实现一个函数。<br>输入：整型数组arr，窗口大小为w。<br>输出：一个长度为n - w + 1的数组res，res[i]表示每一种窗口状态下的最大值。<br>以本题为例，结果应该返回{ 5,5,5,4,6,7 }。</p>
</blockquote>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><ol>
<li>使用双向链表进行解答（LinkedList）</li>
<li>R的操作<ul>
<li>保证链表从左到右必须是从大到小，即头节点为最大值</li>
<li>每进入一个数，从链表的尾部进入，一但发现新的值比原来的链表的尾部大，先弹出，直到尾部的值大于即将插入的值，然后插入</li>
<li>每次压入的值都是原数组的下标值</li>
</ul>
</li>
<li>L的操作<ul>
<li>每一次进行L的操作时，判断链表的头节点是否过期，过期就直接弹出，否则继续向右移动</li>
<li>举例：当窗口的大小size=3，R=4，链表里面有4个数，大于size了，这个时候i=0就过期了，所以直接弹出头节点</li>
</ul>
</li>
</ol>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/1/1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">maxSlidingWindow</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//记录滑动窗口实时的最大值结果</span></span><br><span class="line">            ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">//双向链表，从左到右必须是从大到小的顺序</span></span><br><span class="line">            LinkedList&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> length = num.length;</span><br><span class="line">            <span class="keyword">if</span> (length &lt; size || size == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> list;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">                <span class="comment">//如果链表的尾部小于即将插入的值，则弹出</span></span><br><span class="line">                <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; num[queue.peekLast()] &lt;= num[i]) &#123;</span><br><span class="line">                    queue.pollLast();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//插入只能从尾部插入</span></span><br><span class="line">                queue.addLast(i);</span><br><span class="line">                <span class="comment">//判断链表的头节点是否过期，从头部弹出</span></span><br><span class="line">                <span class="keyword">if</span> (i - queue.peekFirst() == size) &#123;</span><br><span class="line">                    queue.pollFirst();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//当达到滑动窗口的size时，进行收集结果</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt;= size - <span class="number">1</span>) &#123;</span><br><span class="line">                    list.add(num[queue.peekFirst()]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h3><p><img src="/images/滑动窗口最大值/1.jpg" alt=""></p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>以上就是滑动窗口最大值的解法，在leetcode上是属于困难难度的一道题目，但是你掌握了滑动窗口算法，加一些边界的判断就可以轻松拿下</p>
</blockquote>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://www.cnblogs.com/zzw1024/p/11042635.html" target="_blank" rel="noopener">一笔一画一人生</a></li>
<li><a href="https://blog.csdn.net/tangyuan_sibal/article/details/94486570" target="_blank" rel="noopener">经典算法总结</a></li>
</ul>
]]></content>
      <categories>
        <category>LeetCode&amp;牛客题解</category>
      </categories>
      <tags>
        <tag>困难</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客搭建gitalk</title>
    <url>/2019/12/31/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BAgittalk/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote>
<p>2019年1月份的时候就开始搭建了我的第一个博客hexo，部署到了Github Page上，也陆陆续续更新了一些大学时期学习的数据结构和算法内容，然后加了阅读量和访问量，后面发现没有评论系统的博客有点low的感觉，看了很多的评论系统，这里就不一一列举了，最后使用的是Gittalk评论系统。接下来就来介绍hexo集成Gittalk评论系统的全部过程。</p>
</blockquote>
<a id="more"></a>
<h2 id="关于Gitalk"><a href="#关于Gitalk" class="headerlink" title="关于Gitalk"></a>关于Gitalk</h2><blockquote>
<p>Gitalk是一个基于Github Issue和Preact开发的评论插件。使用Github账号登录，界面干净整洁，主要还是Gitalk支持MarkDown语法。（<strong>写过博客的都知道MarkDown好用</strong>）</p>
</blockquote>
<hr>
<h2 id="集成Gitalk"><a href="#集成Gitalk" class="headerlink" title="集成Gitalk"></a>集成Gitalk</h2><h3 id="建立评论仓库"><a href="#建立评论仓库" class="headerlink" title="建立评论仓库"></a>建立评论仓库</h3><ol>
<li>可以在你的个人Github上重新创建一个仓库来专门存放你的评论信息</li>
<li>可以直接使用你的hexo在Github上的仓库地址来存放你的评论信息，信息会放进你仓库里面的issue</li>
</ol>
<h3 id="新建一个OAuth-App"><a href="#新建一个OAuth-App" class="headerlink" title="新建一个OAuth App"></a>新建一个OAuth App</h3><p>​    地址：<a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">https://github.com/settings/applications/new</a></p>
<p><img src="/images/新建OAuth App.png" alt=""></p>
<p><img src="/images/OAuth说明.png" alt=""></p>
<p><strong>填完以上的信息会生成一个Client ID和一个Client Secret，等下的配置会用到这两个信息</strong></p>
<p><img src="/images/生成OAuth.png" alt=""></p>
<h3 id="更改配置文件"><a href="#更改配置文件" class="headerlink" title="更改配置文件"></a>更改配置文件</h3><ol>
<li>新建<code>/layout/_third-party/comments/gitalk.swig</code>文件，并添加内容：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if page.comments &amp;&amp; theme.gitalk.enable %&#125;</span><br><span class="line">  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/gitalk/dist/gitalk.css&quot;&gt;</span><br><span class="line">  &lt;script src=&quot;https://unpkg.com/gitalk/dist/gitalk.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">   &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        var gitalk = new Gitalk(&#123;</span><br><span class="line">          clientID: &apos;&#123;&#123; theme.gitalk.ClientID &#125;&#125;&apos;,</span><br><span class="line">          clientSecret: &apos;&#123;&#123; theme.gitalk.ClientSecret &#125;&#125;&apos;,</span><br><span class="line">          repo: &apos;&#123;&#123; theme.gitalk.repo &#125;&#125;&apos;,</span><br><span class="line">          owner: &apos;&#123;&#123; theme.gitalk.githubID &#125;&#125;&apos;,</span><br><span class="line">          admin: [&apos;&#123;&#123; theme.gitalk.adminUser &#125;&#125;&apos;],</span><br><span class="line">          id: location.pathname,</span><br><span class="line">          distractionFreeMode: &apos;&#123;&#123; theme.gitalk.distractionFreeMode &#125;&#125;&apos;</span><br><span class="line">        &#125;)</span><br><span class="line">        gitalk.render(&apos;gitalk-container&apos;)           </span><br><span class="line">       &lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>修改<code>/layout/_partials/comments.swig</code>，添加内容如下，与前面的<code>elseif</code>同一级别上：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% elseif theme.gitalk.enable %&#125;</span><br><span class="line"> &lt;div id=&quot;gitalk-container&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>修改<code>layout/_third-party/comments/index.swig</code>，在最后一行添加内容：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% include &apos;gitalk.swig&apos; %&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>新建<code>/source/css/_common/components/third-party/gitalk.styl</code>文件，添加内容：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.gt-header a, .gt-comments a, .gt-popup a</span><br><span class="line">  border-bottom: none;</span><br><span class="line">.gt-container .gt-popup .gt-action.is--active:before</span><br><span class="line">  top: 0.7em;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>修改<code>/source/css/_common/components/third-party/third-party.styl</code>，在最后一行上添加内容，引入样式：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@import &quot;gitalk&quot;;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>在主题配置文件<code>next/_config.yml</code>中添加如下内容：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gitalk:</span><br><span class="line">  enable: true</span><br><span class="line">  githubID: github帐号  # 例：god-jiang   </span><br><span class="line">  repo: 仓库名称   # 例：god-jiang.github.io</span><br><span class="line">  ClientID: Client ID</span><br><span class="line">  ClientSecret: Client Secret</span><br><span class="line">  adminUser: github帐号 #指定可初始化评论账户</span><br><span class="line">  distractionFreeMode: true</span><br></pre></td></tr></table></figure>
<p><strong>以上就是next主题中添加Gitalk评论的配置，博客上传到Github上后，打开某一篇文章就可以看到评论了。</strong></p>
<hr>
<h2 id="搭建完成效果"><a href="#搭建完成效果" class="headerlink" title="搭建完成效果"></a>搭建完成效果</h2><p><img src="/images/评论效果图.png" alt=""></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><blockquote>
<p>到这里就已经是大功告成了，当你用github账号登录，第一次加载会比较慢，因为第一次加载会自动在你的仓库下创建相对应的issue。</p>
</blockquote>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://segmentfault.com/a/1190000014085547" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014085547</a></li>
<li><a href="https://blog.csdn.net/qq_35076330/article/details/99968291" target="_blank" rel="noopener">https://blog.csdn.net/qq_35076330/article/details/99968291</a></li>
<li><a href="https://asdfv1929.github.io/2018/01/20/gitalk/" target="_blank" rel="noopener">https://asdfv1929.github.io/2018/01/20/gitalk/</a></li>
</ul>
]]></content>
      <categories>
        <category>hexo优化</category>
      </categories>
  </entry>
  <entry>
    <title>荷兰国旗问题&amp;快排&amp;BFPRT算法</title>
    <url>/2019/12/26/%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97%E9%97%AE%E9%A2%98-%E5%BF%AB%E6%8E%92-BFPRT%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="荷兰国旗问题"><a href="#荷兰国旗问题" class="headerlink" title="荷兰国旗问题"></a>荷兰国旗问题</h2><blockquote>
<p>给定一个数组arr和一个数num，请把小于num的数放在数组的左边，等于num的数放在数组的中间，大于num的数放在数组的右边。要求额外空间复杂度为O(1)，时间复杂度为O(N)</p>
</blockquote>
<a id="more"></a>
<h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3><p>初始化less=-1，more=len(arr)，当前位置为cur=0。</p>
<ul>
<li>如果arr[cur]&lt;num，交换arr[cur]和arr[++less]的数，然后cur++</li>
<li>如果arr[cur]&gt;num，交换arr[cur]和arr[–more]的数，然后cur不变</li>
<li>如果当前位置上的数等于num，less和more均不变，cur++</li>
<li>当cur==more时，停止比较，返回</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NetherLandsFlag</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] partition(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="keyword">int</span> less = L - <span class="number">1</span>;<span class="comment">//小于区域的边界</span></span><br><span class="line">        <span class="keyword">int</span> more = R + <span class="number">1</span>;<span class="comment">//大于区域的边界</span></span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur &lt; more) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[cur] &lt; num) &#123;</span><br><span class="line">                swap(arr, ++less, cur++);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[cur] &gt; num) &#123;</span><br><span class="line">                swap(arr, --more, cur);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] res = partition(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">        System.out.println(Arrays.toString(res));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行截图"><a href="#运行截图" class="headerlink" title="运行截图"></a>运行截图</h3><p><img src="/images/荷兰国旗.png" alt=""></p>
<hr>
<h2 id="稳定算法的定义"><a href="#稳定算法的定义" class="headerlink" title="稳定算法的定义"></a>稳定算法的定义</h2><blockquote>
<p>假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这个排序算法是稳定的；否则称为不稳定的。</p>
</blockquote>
<hr>
<h2 id="BFPRT算法"><a href="#BFPRT算法" class="headerlink" title="BFPRT算法"></a>BFPRT算法</h2><h3 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h3><blockquote>
<p>在一大堆数中求其前k大或前k小的问题，简称TOP-K问题。目前解决TOP-K问题最有效的算法是BFPRT算法，又称为中位数的中位数算法，该算法由Blum、Floyd、Pratt、Rivest、Tarjan提出，最坏时间复杂度为O(N)</p>
</blockquote>
<p>一般第一反应解决TOP-K问题就是对所有数据进行一次排序，然后取其前k即可，但是有两个问题：</p>
<ol>
<li>排序的平均复杂度为O(n*logn)，最坏时间复杂度为O(n^2)，不能保证较好的复杂度</li>
<li>我们只需要前k大的数，而对其余不需要的数也进行了排序，浪费了大量排序时间</li>
</ol>
<p>除了这种方法之外，堆排序也是一个比较好的选择， 可以维护一个大小为k的堆，时间复杂度为O(n*logk)。</p>
<h3 id="算法套路"><a href="#算法套路" class="headerlink" title="算法套路"></a>算法套路</h3><ol>
<li>对整个数组进行分组，每组5个数，不满5个的凑成最后一组</li>
<li>对每个组进行组内排序，组内5个数排序的时间复杂度为O(1)，所以总共有n/5个组，时间复杂度为O(N)</li>
<li>拿出排序后的每个组的中位数，组成一个新的n/5长度的数组</li>
<li>递归调用BFPRT算法，求出最后的中位数num</li>
<li>拿到BFPRT的返回的num，利用荷兰国旗算法把小于的放在数组的左边，等于的放在数组的中间，大于放在数组的右边。</li>
</ol>
<h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BFPRT</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bfprt</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1、对arr数组进行分组，每5个为一组</span></span><br><span class="line">        <span class="comment">//2、进行组内排序，时间复杂度为O(N)，取出每个组的中位数</span></span><br><span class="line">        <span class="comment">//3、每个组的中位数组成一个n/5的数组new_arr</span></span><br><span class="line">        <span class="comment">//4、递归bfprt(new_arr,new_arr.length/2)</span></span><br><span class="line">        <span class="comment">//5、得到一个中位数num</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//利用这个中位数进行荷兰国旗算法，小于在左边，等于在中间，大于在右边</span></span><br><span class="line">    <span class="comment">//如果num==k,则该中位数就是第k大的数</span></span><br><span class="line">    <span class="comment">//如果num&lt;k，则递归求num之后的数组</span></span><br><span class="line">    <span class="comment">//如果num&gt;k，则递归求num之前的数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度证明"><a href="#时间复杂度证明" class="headerlink" title="时间复杂度证明"></a>时间复杂度证明</h3><p><img src="/images/BFPRT时间复杂度.png" alt=""></p>
<hr>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>算法导论</li>
<li>csdn博客</li>
</ol>
<blockquote>
<p>以上讲的是荷兰国旗的解法，可以运用于经典快排算法的partition操作，也可以用于BFPRT算法求解（TOP-K问题）</p>
</blockquote>
]]></content>
      <categories>
        <category>算法积累ing</category>
      </categories>
      <tags>
        <tag>算法进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>有趣的位运算</title>
    <url>/2019/12/20/%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h2 id="位运算概述"><a href="#位运算概述" class="headerlink" title="位运算概述"></a>位运算概述</h2><p>从现代计算机中所有的数据都以二进制的形式存储在设备中。即0、1两种状态，计算机对二进制进行的运算（+、-、*、/）都叫位运算。示例：</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">35</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">47</span>;</span><br><span class="line"><span class="keyword">int</span> c = a + b;</span><br></pre></td></tr></table></figure>
<p>计算a+b的值，在计算机中就是以二进制进行运算的。所以上面我们所给的int变量会在机器内部先转换为二进制在进行相加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">35:  0 0 1 0 0 0 1 1</span><br><span class="line">47:  0 0 1 0 1 1 1 1</span><br><span class="line">————————————————————</span><br><span class="line">82:  0 1 0 1 0 0 1 0</span><br></pre></td></tr></table></figure>
<p><strong>所以，合理的运用位运算更能显著提高代码在机器上的运行效率。</strong></p>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><table>
<thead>
<tr>
<th style="text-align:center">含义</th>
<th style="text-align:center">运算符</th>
<th style="text-align:left">例子</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">左移</td>
<td style="text-align:center">&lt;&lt;</td>
<td style="text-align:left">0011  =&gt;  0110</td>
</tr>
<tr>
<td style="text-align:center">右移</td>
<td style="text-align:center">&gt;&gt;</td>
<td style="text-align:left">0110  =&gt;  0011</td>
</tr>
<tr>
<td style="text-align:center">按位或</td>
<td style="text-align:center">︳</td>
<td style="text-align:left">0011 <br> ——-  =&gt;1011<br>1011</td>
</tr>
<tr>
<td style="text-align:center">按位与</td>
<td style="text-align:center">&amp;</td>
<td style="text-align:left">0011 <br> ——-  =&gt;0011<br>1011</td>
</tr>
<tr>
<td style="text-align:center">按位取反</td>
<td style="text-align:center">~</td>
<td style="text-align:left">0011  =&gt;1100</td>
</tr>
<tr>
<td style="text-align:center">按位异或 (相同为零不同为一)</td>
<td style="text-align:center">^</td>
<td style="text-align:left">0011 <br> ——-  =&gt;1000<br>1011</td>
</tr>
</tbody>
</table>
<h2 id="经典运用"><a href="#经典运用" class="headerlink" title="经典运用"></a>经典运用</h2><h3 id="不用加减乘除做加法"><a href="#不用加减乘除做加法" class="headerlink" title="不用加减乘除做加法"></a>不用加减乘除做加法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//step1:异或查看两个数进行加法操作后的结果</span></span><br><span class="line"><span class="comment">//step2:与运算计算出想对应的位置的进位结果，然后左移一位</span></span><br><span class="line"><span class="comment">//b代表的是两数相加是否有进位，有的话就继续，没有的话就结束得出相加后的答案</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(b != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = a ^ b;<span class="comment">//计算出相对应的位置相加后的结果</span></span><br><span class="line">            b = (a &amp; b) &lt;&lt; <span class="number">1</span>;<span class="comment">//计算出想对应的位置的进位，然后左移一位</span></span><br><span class="line">            a = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个其实可以简写成return (a^b)+((a&amp;b)&lt;&lt;1);</span></span><br></pre></td></tr></table></figure>
<h3 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">0</span>||a == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(a != <span class="number">0</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            a = a &amp; (a-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="不使用第三个变量的情况下交换两个变量的值"><a href="#不使用第三个变量的情况下交换两个变量的值" class="headerlink" title="不使用第三个变量的情况下交换两个变量的值"></a>不使用第三个变量的情况下交换两个变量的值</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原理：运用异或的特性</span></span><br><span class="line"><span class="comment">//A ^ B = C --&gt; C ^ A = B --&gt; C ^ B = A</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    x = x ^ y;</span><br><span class="line">    y = x ^ y;</span><br><span class="line">    x = x ^ y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他运用"><a href="#其他运用" class="headerlink" title="其他运用"></a>其他运用</h2><ul>
<li>判断一个数的奇偶性</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((a &amp; <span class="number">1</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">"a是偶数"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"a是奇数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>两数的中位数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="comment">//通过位运算不会造成溢出</span></span><br><span class="line">	<span class="keyword">int</span> mid = a + (a - b) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>两数的平均数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">average</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (a &amp; b)+((x ^ y) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上就是我今天分享的常见位运算的经典问题，其实位运算的应用远远不止这些，在算法方面适当的使用还是很有帮助的。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法积累ing</category>
      </categories>
      <tags>
        <tag>运算</tag>
      </tags>
  </entry>
  <entry>
    <title>三大高效排序之堆排序(Java实现)</title>
    <url>/2019/12/17/%E4%B8%89%E5%A4%A7%E9%AB%98%E6%95%88%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%A0%86%E6%8E%92%E5%BA%8F-Java%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="堆排序的介绍"><a href="#堆排序的介绍" class="headerlink" title="堆排序的介绍"></a>堆排序的介绍</h2><blockquote>
<p>堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是<strong>完全二叉树</strong>。</p>
</blockquote>
<a id="more"></a>
<ul>
<li>完全二叉树：除了最后一层之外的其他每一层都被完全填充，每一层从左到右的填充数据，不能空缺</li>
<li>大根堆：任意一个节点的值均大于等于它的左右孩子的值，位于堆顶的节点值最大</li>
<li>小根堆：任意一个节点的值均小于等于它的左右孩子的值，位于堆顶的节点值最小</li>
</ul>
<p><strong>本节分享的堆排序以大根堆为例子</strong></p>
<h2 id="堆排序的实现步骤"><a href="#堆排序的实现步骤" class="headerlink" title="堆排序的实现步骤"></a>堆排序的实现步骤</h2><ul>
<li><h3 id="把一个数组调整为大根堆（heapInsert）"><a href="#把一个数组调整为大根堆（heapInsert）" class="headerlink" title="把一个数组调整为大根堆（heapInsert）"></a>把一个数组调整为大根堆（heapInsert）</h3><p>假设当前节点的下标为i，那么它的父亲节点为(i-1)/2，每次heapInsert的时候就把insert进来的节点与它的父亲节点进行比较，比它的父节点大就交换，一直重复调整</p>
</li>
<li><h3 id="每次把堆顶放到最后的节点位置，然后调整整个堆为大根堆（heapify）"><a href="#每次把堆顶放到最后的节点位置，然后调整整个堆为大根堆（heapify）" class="headerlink" title="每次把堆顶放到最后的节点位置，然后调整整个堆为大根堆（heapify）"></a>每次把堆顶放到最后的节点位置，然后调整整个堆为大根堆（heapify）</h3><p>每次把堆顶的节点放到最后，然后堆大小减1，然后调整为大根堆，一直重复，直到大根堆的大小为0为止</p>
</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> size = arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            heapInsert(arr, i);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, <span class="number">0</span>, --size);</span><br><span class="line">        <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            heapify(arr, <span class="number">0</span>, size);</span><br><span class="line">            swap(arr, <span class="number">0</span>, --size);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//heapInsert操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapInsert</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (arr[index] &gt; arr[(index - <span class="number">1</span>) / <span class="number">2</span>]) &#123;</span><br><span class="line">            swap(arr, index, (index - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">            index = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//heapify操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; size) &#123;</span><br><span class="line">            <span class="keyword">int</span> largest = left + <span class="number">1</span> &lt; size &amp;&amp; arr[left + <span class="number">1</span>] &gt; arr[left] ? left + <span class="number">1</span> : left;</span><br><span class="line">            largest = arr[index] &gt; arr[largest] ? index : largest;</span><br><span class="line">            <span class="keyword">if</span> (largest == index)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            swap(arr, index, largest);</span><br><span class="line">            index = largest;</span><br><span class="line">            left = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//交换两数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行截图"><a href="#运行截图" class="headerlink" title="运行截图"></a>运行截图</h2><p><img src="/images/归并运行截图.png" alt=""></p>
<blockquote>
<p>以上就是今天分享的堆排序，主要操作是heapInsert和heapify，时间复杂度为O(N*logN)，空间复杂度为O(1)</p>
</blockquote>
]]></content>
      <categories>
        <category>算法积累ing</category>
      </categories>
      <tags>
        <tag>高效排序</tag>
      </tags>
  </entry>
  <entry>
    <title>三大高效排序之归并排序(Java实现)</title>
    <url>/2019/12/16/%E4%B8%89%E5%A4%A7%E9%AB%98%E6%95%88%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-Java%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="归并排序的介绍"><a href="#归并排序的介绍" class="headerlink" title="归并排序的介绍"></a>归并排序的介绍</h2><p>归并排序(英语：Merge sort，或Mergesort)，是创建在归并操作上的一种有效的排序算法，效率为O(n log n)。1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。</p>
<a id="more"></a>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>是利用递归与分治的技术将数据序列划分为越来越小的半子表，再对半子表排序，最后再用递归方法将排好序的半子表合并成越来越大的有序序列。</p>
<h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><p><strong>将两个有序的数列合并成一个大的有序的序列。通过递归，层层合并，即为归并。</strong></p>
<p><img src="/images/归并排序图示.png" alt=""></p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">//归并排序，时间复杂度为O(N*logN)，空间复杂度为O(N)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//分治的结束条件</span></span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//保证不溢出取start和end的中位数</span></span><br><span class="line">        <span class="keyword">int</span> mid = start + ((end - start) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//递归排序并且合并</span></span><br><span class="line">        MergeSort(arr, start, mid);</span><br><span class="line">        MergeSort(arr, mid + <span class="number">1</span>, end);</span><br><span class="line">        Merge(arr, start, mid, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> mid, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[end - start + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> p1 = start;</span><br><span class="line">        <span class="keyword">int</span> p2 = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= end) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[p1] &gt; arr[p2]) &#123;</span><br><span class="line">                temp[p++] = arr[p2++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[p++] = arr[p1++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= mid) &#123;</span><br><span class="line">            temp[p++] = arr[p1++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p2 &lt;= end) &#123;</span><br><span class="line">            temp[p++] = arr[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">            arr[i + start] = temp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        MergeSort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行截图"><a href="#运行截图" class="headerlink" title="运行截图"></a>运行截图</h2><p><img src="/images/归并运行截图.png" alt=""></p>
<blockquote>
<p>1、以上就是今天分享的归并排序，时间复杂度为O(N*logN)，空间复杂度为O(N)</p>
<p>2、归并排序的额外空间复杂度可以做到O(1)，但是非常难，不需要掌握，有一篇论文”归并排序内部缓存法”可以做到</p>
</blockquote>
]]></content>
      <categories>
        <category>算法积累ing</category>
      </categories>
      <tags>
        <tag>高效排序</tag>
      </tags>
  </entry>
  <entry>
    <title>三大高效排序之快速排序(Java实现)</title>
    <url>/2019/12/16/%E4%B8%89%E5%A4%A7%E9%AB%98%E6%95%88%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-Java%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>快速排序是一种原地排序，只需要一个很小的栈作为辅助空间，空间复杂度为O(logN)，所以适合在数据集比较大且无序的时候使用。</p>
<p><strong>时间复杂度</strong></p>
<p>时间复杂度比较复杂，最好的情况是O(N)，最差的时候是O(N^2)，所以平时说的O(N*logN)为其平均时间复杂度。</p>
<a id="more"></a>
<h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>随机找出一个数，可以随机取，也可以取固定位置，一般是取第一个或最后一个称为基准，然后就是比基准小的在左边，比基准大的放到右边，如何放做，就是和基准进行交换，这样交换完左边都是比基准小的，右边都是比较基准大的，这样就将一个数组分成了两个子数组，然后再按照同样的方法把子数组再分成更小的子数组，直到不能分解为止。</p>
<h2 id="操作实现"><a href="#操作实现" class="headerlink" title="操作实现"></a>操作实现</h2><p>partition方法中</p>
<p>1.选择数组中的第一个元素arr[startIndex]作为轴（pivot）</p>
<p>2.左指针为left，从最左边开始寻找第一个比pivot大的数</p>
<p>3.右指针为right，从最右面的一个元素开始向左寻找第一个小于等于pivot的数值</p>
<p>4.经过2，3两个步骤后，将会出现以下两种情况</p>
<p>​           （1）：left和right没有相遇，此时进行交换，swap（arr,left,right）;</p>
<p>​           （2）：left和right相遇，做swap（arr,startIndex,left），然后返回left</p>
<p>5.partition中返回pivot用于分割数组，下一次用于排序的数组被分割为(startIndex,pivot-1),(pivot+1,endIndex)两段，进行递归操作</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        quickSort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//时间复杂度O(n*logn)，空间复杂度O(n*logn)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (startIndex &lt; endIndex) &#123;</span><br><span class="line">            <span class="comment">//找出基准</span></span><br><span class="line">            <span class="keyword">int</span> partition = partition(arr, startIndex, endIndex);</span><br><span class="line">            <span class="comment">//分成两边递归进行</span></span><br><span class="line">            quickSort(arr, startIndex, partition - <span class="number">1</span>);</span><br><span class="line">            quickSort(arr, partition + <span class="number">1</span>, endIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//找基准</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = arr[startIndex];</span><br><span class="line">        <span class="keyword">int</span> left = startIndex;</span><br><span class="line">        <span class="keyword">int</span> right = endIndex;</span><br><span class="line">        <span class="keyword">while</span> (left != right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt; pivot) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= pivot) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到left比基准大，right比基准小，进行交换</span></span><br><span class="line">            <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">                swap(arr, left, right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一轮完成，让left和right重合的位置和基准交换，返回基准的位置</span></span><br><span class="line">        swap(arr, startIndex, left);</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//两数交换</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行截图"><a href="#运行截图" class="headerlink" title="运行截图"></a>运行截图</h2><p><img src="/images/快排运行截图.png" alt=""></p>
<blockquote>
<p>1、以上就是今天分享的快速排序，时间复杂度为O(N<em>logN)，空间复杂度为O(N\</em>logN)</p>
<p>2、快排是不稳定排序，要想做到稳定性是可以的，但是非常难，不需要掌握，有一篇论文叫”01 stable sort”可以做到</p>
<p>3、有一道题目，是奇数放数组左边，偶数放在数组右边，还要求原始的相对次序不变，额外空间复杂度为O(1)，碰到这个问题，直接可以怼面试官，根本不可能做出来</p>
</blockquote>
]]></content>
      <categories>
        <category>算法积累ing</category>
      </categories>
      <tags>
        <tag>高效排序</tag>
      </tags>
  </entry>
  <entry>
    <title>神级遍历-morris</title>
    <url>/2019/12/15/%E7%A5%9E%E7%BA%A7%E9%81%8D%E5%8E%86-morris/</url>
    <content><![CDATA[<h2 id="morris遍历介绍"><a href="#morris遍历介绍" class="headerlink" title="morris遍历介绍"></a>morris遍历介绍</h2><p>morris遍历是二叉树遍历算法的超强进阶算法，跟递归、非递归（栈实现）的空间复杂度，morris遍历可以将非递归遍历中的空间复杂度降为O(1)。从而实现时间复杂度为O(N)，而空间复杂度为O(1)的精妙算法。</p>
<p>morris遍历利用的是树的叶节点左右孩子为空（树的大量空闲指针），实现空间开销的极限缩减。</p>
<a id="more"></a>
<h2 id="morris遍历的实现原则"><a href="#morris遍历的实现原则" class="headerlink" title="morris遍历的实现原则"></a>morris遍历的实现原则</h2><p><strong>记作当前节点为cur。</strong></p>
<ol>
<li>如果cur无左孩子，cur向右移动（cur=cur.right）</li>
<li>如果cur有左孩子，找到cur左子树上最右的节点，记为mostright<ol>
<li>如果mostright的right指针指向空，让其指向cur，cur向左移动（cur=cur.left）</li>
<li>如果mostright的right指针指向cur，让其指向空，cur向右移动（cur=cur.right）</li>
</ol>
</li>
</ol>
<p>实现以上的原则，即实现了morris遍历。</p>
<h2 id="morris遍历的实质"><a href="#morris遍历的实质" class="headerlink" title="morris遍历的实质"></a>morris遍历的实质</h2><p>建立一种机制，对<strong>于没有左子树的节点只到达一次，对于有左子树的节点会到达两次</strong></p>
<h2 id="morris遍历的实例"><a href="#morris遍历的实例" class="headerlink" title="morris遍历的实例"></a>morris遍历的实例</h2><p>一个树若按层遍历的结构为{1,2,3,4,5,6,7}，即该树为满二叉树，头结点值为1，左右孩子为2,3，叶节点为4,5,6,7</p>
<p>我们按照morris遍历来遍历该树。</p>
<p>1）首先cur来到头结点1，按照morris原则的第二条第一点，它存在左孩子，cur左子树上最右的节点为5，它的right指针指向空，所以让其指向1，cur向左移动到2。</p>
<p>2）2有左孩子，且它左子树最右的节点4指向空，按照morris原则的第二条第一点,让4的right指针指向2，cur向左移动到4</p>
<p>3）4不存在左孩子，按照morris原则的第一条，cur向右移动，在第二步中，4的right指针已经指向了2，所以cur会回到2</p>
<p>4）重新回到2，有左孩子，它左子树最右的节点为4，但是在第二步中，4的right指针已经指向了2，不为空。所以按照morris原则的第二条第二点，2向右移动到5，同时4的right指针重新指向空</p>
<p>5）5不存在左孩子，按照morris原则的第一条，cur向右移动，在第一步中，5的right指针已经指向了1，所以cur会回到1</p>
<p>6）cur回到1，回到头结点，左子树遍历完成，1有左孩子，左子树上最右的节点为5，它的right指针指向1，按照morris原则的第二条第二点，1向右移动到3，同时5的right指针重新指回空</p>
<p>……</p>
<p>当到达最后一个节点7时，按照流程下来，此时7无左右孩子，遍历结束。</p>
<h2 id="morris代码实现（前序、中序、后序遍历）"><a href="#morris代码实现（前序、中序、后序遍历）" class="headerlink" title="morris代码实现（前序、中序、后序遍历）"></a>morris代码实现（前序、中序、后序遍历）</h2><p>前序遍历：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">morrisPre</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node cur = head;</span><br><span class="line">    Node mostRight = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        mostRight = cur.left;</span><br><span class="line">        <span class="keyword">if</span>(mostRight != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span> (mostRight.right !=<span class="keyword">null</span> &amp;&amp; mostRight.right != cur)&#123;</span><br><span class="line">                mostRight = mostRight.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(mostRight.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                mostRight.right = cur;</span><br><span class="line">                System.out.print(cur.value+<span class="string">" "</span>);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                mostRight.right = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.print(cur.value + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>中序遍历：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">morrisIn</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node cur = head;</span><br><span class="line">    Node mostRight = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        mostRight = cur.left;</span><br><span class="line">        <span class="keyword">if</span>(mostRight != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span> (mostRight.right !=<span class="keyword">null</span> &amp;&amp; mostRight.right != cur)&#123;</span><br><span class="line">                mostRight = mostRight.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(mostRight.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                mostRight.right = cur;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                mostRight.right = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(cur.value+<span class="string">" "</span>);</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后续遍历（复杂一点）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">morrisPos</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       Node cur = head;</span><br><span class="line">       Node mostRight = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">           mostRight = cur.left;</span><br><span class="line">           <span class="keyword">if</span>(mostRight != <span class="keyword">null</span>)&#123;</span><br><span class="line">               <span class="keyword">while</span> (mostRight.right !=<span class="keyword">null</span> &amp;&amp; mostRight.right != cur)&#123;</span><br><span class="line">                   mostRight = mostRight.right;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>(mostRight.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                   mostRight.right = cur;</span><br><span class="line">                   cur = cur.left;</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                   mostRight.right = <span class="keyword">null</span>;</span><br><span class="line">                   printEdge(cur.left);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           cur = cur.right;</span><br><span class="line">       &#125;</span><br><span class="line">       printEdge(head);</span><br><span class="line">       System.out.println();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printEdge</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">       Node tail =reverseEdge(node);</span><br><span class="line">       Node cur = tail;</span><br><span class="line">       <span class="keyword">while</span> (cur != <span class="keyword">null</span> )&#123;</span><br><span class="line">           System.out.print(cur.value+<span class="string">" "</span>);</span><br><span class="line">           cur =cur.right;</span><br><span class="line">       &#125;</span><br><span class="line">       reverseEdge(tail);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reverseEdge</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">       Node pre = <span class="keyword">null</span>;</span><br><span class="line">       Node next = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">while</span> (node != <span class="keyword">null</span>)&#123;</span><br><span class="line">           next = node.right;</span><br><span class="line">           node.right = pre;</span><br><span class="line">           pre = node;</span><br><span class="line">           node = next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> pre;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上就是我今天所要分享的morris遍历，神级算法，时间复杂度为O(N)，空间复杂度为O(1)。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法积累ing</category>
      </categories>
      <tags>
        <tag>算法进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>链表反转解法</title>
    <url>/2019/04/20/%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC%E8%A7%A3%E6%B3%95/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote>
<p>当初大二学习数据结构的时候，有许多数据结构我都学得有点懵，总感觉没有一个系统的概括和总结，导致我的链表学得一般。后来班上有个同学微信跟我说叫我关注”程序员小灰”这个公众号，说他讲得很生动形象，最后关注了一波，看了他里面一道经典的面试题——链表反转。接下来就来讲解链表反转的解法。</p>
</blockquote>
<a id="more"></a>
<h2 id="链表反转图示"><a href="#链表反转图示" class="headerlink" title="链表反转图示"></a>链表反转图示</h2><p><img src="/images/链表反转解法/1.png" alt=""></p>
<h2 id="解法说明"><a href="#解法说明" class="headerlink" title="解法说明"></a>解法说明</h2><ol>
<li><p>链表反转的本质其实就是把每一个节点原本指向下一个节点的next的指针，反转过来指向它的前置节点。</p>
<p><img src="/images/链表反转解法/2.png" alt=""></p>
</li>
<li><p>进行链表反转的时候，需要同时知道三个节点才能进行反转。</p>
<p><img src="/images/链表反转解法/3.png" alt=""></p>
</li>
</ol>
<h2 id="解法步骤"><a href="#解法步骤" class="headerlink" title="解法步骤"></a>解法步骤</h2><ol>
<li><p>以p2节点为根，把p2节点原本指向p3的next指针反转，指向p1</p>
<p><img src="/images/链表反转解法/4.png" alt=""></p>
</li>
<li><p>三个临时节点引用p1，p2，p3分别向后移动一位</p>
<p><img src="/images/链表反转解法/5.png" alt=""></p>
</li>
<li><p>重复”1”的工作，以p2节点为根，把p2节点原本指向p3的next指针反转，指向p1</p>
<p><img src="/images/链表反转解法/6.png" alt=""></p>
</li>
<li><p>重复”2”的工作，三个临时节点引用p1，p2，p3分别向后移动一位</p>
<p><img src="/images/链表反转解法/7.png" alt=""></p>
</li>
<li><p>继续重复以上的工作，一直到p2为空为止</p>
<p><img src="/images/链表反转解法/8.png" alt=""></p>
</li>
<li><p>最后，把head节点的next指向空，成为反转链表的尾节点。并把p1赋值给head，让p1所在节点成为反转链表的头节点</p>
<p><img src="/images/链表反转解法/9.png" alt=""></p>
</li>
</ol>
<p>​    <strong>听完上面的讲解，估计有点懵逼，来看看代码的实现，再结合上面的图示步骤，相信你就会理解链表反转了</strong></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    ListNode(<span class="keyword">int</span> val)&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode p1 = head;</span><br><span class="line">        ListNode p2 = head.next;</span><br><span class="line">        ListNode p3 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(p2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            p3 = p2.next;</span><br><span class="line">            p2.next = p1;</span><br><span class="line">            p1 = p2;</span><br><span class="line">            p2 = p3;</span><br><span class="line">        &#125;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        head = p1;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>对于链表的反转就介绍到这里，感谢大家的支持。嘻嘻嘻~~~</p>
</blockquote>
<h2 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h2><ul>
<li>程序员小灰公众号</li>
<li><a href="https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=13&amp;tqId=11168&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">牛客网原题链接</a></li>
</ul>
]]></content>
      <categories>
        <category>LeetCode&amp;牛客题解</category>
      </categories>
      <tags>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title>全排列算法</title>
    <url>/2019/03/02/%E5%85%A8%E6%8E%92%E5%88%97%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="全排列算法详细解析"><a href="#全排列算法详细解析" class="headerlink" title="全排列算法详细解析"></a>全排列算法详细解析</h2><p>全排列在笔试面试和ACM竞赛中很热门，因为它难度适中，既可以考察递归实现，又能进一步考察非递归的实现，便于区分出考生的水平。（<strong>自己的心得：回溯是思想，深搜是本质，递归是实现</strong>）</p>
<a id="more"></a>
<h4 id="一、全排列的递归实现（以下所有代码以java为主）"><a href="#一、全排列的递归实现（以下所有代码以java为主）" class="headerlink" title="一、全排列的递归实现（以下所有代码以java为主）"></a>一、全排列的递归实现（以下所有代码以java为主）</h4><p>以abcd为例，共有24种排列方式，abcd,abdc,acbd,acdb…….，因此可以知道——<em>全排列就是从第一个数字起每个数分别与它后面的数字交换。</em>递归的代码如下：</p>
<pre><code>public class Main{
    public static int count=0;
    public static void swap(char[] a,int i,int j){
        char tmp = a[i];
        a[i]=a[j];
        a[j]=tmp;
}

    public static void perm(char[] a,int st,int len){
        if(st==len-1){
            for(int i=0;i&lt;len;i++){
                System.out.print(a[i]);
            }
            System.out.println(&quot;&quot;);
            count++;
        }else{
            for(int i=st;i&lt;len;i++){
                swap(a,st,i);
                perm(a,st+1,len);
                swap(a,st,i);
            }
        }
    }
    public static void main(String[] args) {
        char[] a=&quot;abcd&quot;.toCharArray();
        perm(a,0,4);
        System.out.println(&quot;总共有：&quot;+count+&quot;种&quot;);
    }
}
</code></pre><h6 id="运行结果如下："><a href="#运行结果如下：" class="headerlink" title="运行结果如下："></a>运行结果如下：</h6><p><img src="/images/perm.jpg" alt="全排列的结果"></p>
<h3 id="二、以蓝桥杯里面的一道例题来使用全排列解决"><a href="#二、以蓝桥杯里面的一道例题来使用全排列解决" class="headerlink" title="二、以蓝桥杯里面的一道例题来使用全排列解决"></a>二、以蓝桥杯里面的一道例题来使用全排列解决</h3><p><strong>题目：</strong><br><em>凑算式:  A+B/C+DEF/GHI = 10<br>这个算式中A~I代表1~9的数字，不同的字母代表不同的数字。比如： 6+8/3+952/714就是一种解法, 5+3/1+972/486是另一种解法。这个算式一共有多少种解法？</em></p>
<p>代码如下：</p>
<pre><code>public class Main {
    static int count=0;
    public static void swap(char[] a,int i,int j){
        char temp=a[i];
        a[i]=a[j];
        a[j]=temp;
    }
    public static boolean check(char[] a){
        double[] num = new double[9];
        for(int i=0;i&lt;9;i++){
            num[i]=a[i]-&apos;0&apos;;
        }
        if(num[0]+num[1]*1.0/num[2]+(num[3]*100+num[4]*10+num[5])*1.0/(num[6]*100+num[7]*10+num[8])==10){
            return true;
        }
        return false;
    }

    public static void perm(char[] a,int st,int length){
        if(st==length-1){
            if(check(a)){
                count++;
            }
        }else{
            for(int i=st;i&lt;length;i++){
                swap(a,st,i);
                perm(a,st+1,length);
                swap(a,st,i);
            }
        }
    }
    public static void main(String[] args) {    
        char[] a=&quot;123456789&quot;.toCharArray();
        perm(a,0,9);
        System.out.println(&quot;共有&quot;+count+&quot;种解法&quot;);
    }
}
</code></pre><h6 id="运行结果如下：-1"><a href="#运行结果如下：-1" class="headerlink" title="运行结果如下："></a>运行结果如下：</h6><p><img src="/images/perm01.jpg" alt=""></p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p><strong>全排列就是从第一个数字起每个数分别与它后面的数字交换</strong></p>
]]></content>
      <categories>
        <category>算法积累ing</category>
      </categories>
      <tags>
        <tag>算法基础</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis开发流程</title>
    <url>/2019/02/16/MyBatis%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>通过这几天的学习，大概懂得了mybatis的开发流程还有基础的CURD操作，就想着把它写下来，接下来会写下mybatis框架的开发步骤，举例代码就用insert，其他read、update、delete大致跟insert一样。<br><a id="more"></a></p>
<h2 id="mybatis开发步骤"><a href="#mybatis开发步骤" class="headerlink" title="mybatis开发步骤"></a>mybatis开发步骤</h2><h4 id="一、导入相对应的jar包"><a href="#一、导入相对应的jar包" class="headerlink" title="一、导入相对应的jar包"></a>一、导入相对应的jar包</h4><p>如图所示：<br><img src="/images/myBatisJar.jpg" alt="jar"></p>
<h4 id="二、写主配置文件myBatis-config-xml"><a href="#二、写主配置文件myBatis-config-xml" class="headerlink" title="二、写主配置文件myBatis-config.xml"></a>二、写主配置文件myBatis-config.xml</h4><p><code>&lt;environments default=&quot;development&quot;&gt;
        &lt;environment id=&quot;development&quot;&gt;
            &lt;transactionManager type=&quot;JDBC&quot; /&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;
                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;amp;characterEncoding=UTF-8&quot; /&gt;
                &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;
                &lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;
    &lt;mappers&gt;
    &lt;mapper resource=&quot;god/jiang/entity/DeptMapper.xml&quot;/&gt;
&lt;/mappers&gt;</code></p>
<h4 id="三、写映射文件"><a href="#三、写映射文件" class="headerlink" title="三、写映射文件"></a>三、写映射文件</h4><p>例如创建一个xxx.java的javebean,同时就要创建一个xxx.Mapper.xml来映射数据库的字段，还有要先写CURD的SQL语句，如图所示：<br><img src="/images/myBatisMapper.jpg" alt="mapper"></p>
<h4 id="四、写Dao的接口和实现（以insert为例子）"><a href="#四、写Dao的接口和实现（以insert为例子）" class="headerlink" title="四、写Dao的接口和实现（以insert为例子）"></a>四、写Dao的接口和实现（以insert为例子）</h4><p>1.先用Resources.getResourcesAsReader(myBatis-config.xml)读取主配置文件<br>2.构建sessionFactory<br>3.创建session(mybatis默认开启事务)<br>4.业务逻辑（insert为例子）<br>5.提交事务<br>代码如下：<br><img src="/images/myBatisSave.jpg" alt="insert"></p>
<h4 id="五、test（省略）"><a href="#五、test（省略）" class="headerlink" title="五、test（省略）"></a>五、test（省略）</h4><p>…<br>…<br>…</p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><blockquote>
<p>MyBatis是一款优秀的持久层框架，它支持定制化SQL、存储过程以及高级映射。MyBatis避免了几乎所有的JDBC代码和手动设置参数以及获取结果集。MyBatis可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录。<br>以上就是我对MyBatis的开发流程的理解和CURD示例。</p>
</blockquote>
]]></content>
      <categories>
        <category>SSM学习ing</category>
      </categories>
      <tags>
        <tag>学习经历</tag>
      </tags>
  </entry>
  <entry>
    <title>学习mybatis的记录初体验</title>
    <url>/2019/01/22/%E5%AD%A6%E4%B9%A0mybatis%E7%9A%84%E8%AE%B0%E5%BD%9501/</url>
    <content><![CDATA[<p>今天刚开始学习mybatis，听了mybatis和hibernate之间的比较，大致是这样的：<br>一、灵活性：mybatis可以直接使用SQL语句，灵活性较高<br>二、效率性：mybatis直接用SQL，效率高（hibernate使用hql语句，底层需要转换成<br>SQL来操作数据库，时间上有消耗）</p>
<a id="more"></a>
<p>三、移植性：hibernate更好，因为hibernate用配置文件关联数据库，用hql语句与<br>数据库无直接关系</p>
<p>听完课学了大概一个小时，弄懂了mybatis开发的大致流程，但是轮到我自己动手操<br>作的时候，一直保空指针异常，初学者总是遇到这个问题，弄了我将近2个多小时，<br>最后才知道原来要使用SQL语句的时候，SqlSession.insert(1,2)传的参数弄错了，<br>第一个参数要传的是mapper.xml的命名空间加定义的id来定位，第二个参数就是你<br>要传的值。</p>
<p>总的来说，我还是觉得学习编程，理论固然重要，但是动手能力也很重要，编码能力<br>也很重要，这就是我学习mybatis的初次体验。</p>
]]></content>
      <categories>
        <category>SSM学习ing</category>
      </categories>
      <tags>
        <tag>学习经历</tag>
      </tags>
  </entry>
  <entry>
    <title>god_jiang的第一篇博客</title>
    <url>/2019/01/17/god-jiang-title/</url>
    <content><![CDATA[<p>这是我得第一个博客网站，也不知道说些啥，就是假期大家好好学习，不要过度玩电脑游戏，偶尔放松一下没啥，但是关键得ssm框架还是得先学好，下学期好找实习。。。。</p>
]]></content>
  </entry>
</search>
