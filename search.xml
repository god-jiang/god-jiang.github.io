<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>排列组合的模板算法</title>
    <url>/2020/03/23/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E7%9A%84%E6%A8%A1%E6%9D%BF%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="排列组合（百度百科）"><a href="#排列组合（百度百科）" class="headerlink" title="排列组合（百度百科）"></a>排列组合（百度百科）</h2><blockquote>
<p>排列组合是组合学最基本的概念。所谓排列，就是指从给定个数的元素中取出指定个数的元素进行排序。组合则是指从给定个数的元素仅仅取出指定个数的元素，不考虑排序。排列组合的中心问题是研究给定要求的排列和组合可能出现的情况总数。排列组合与古典概率论关系密切。</p>
</blockquote>
<a id="more"></a>
<h2 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//abc的排列</span><br><span class="line">abc  acb  bac  bca  cba  cab</span><br><span class="line">共有6种排序</span><br><span class="line"></span><br><span class="line">//abc的组合</span><br><span class="line">3取3的可能：abc</span><br><span class="line">3取2的可能：ab  ac  bc</span><br><span class="line">3取1的可能：a  b  c</span><br></pre></td></tr></table></figure>
<h2 id="排列模板代码"><a href="#排列模板代码" class="headerlink" title="排列模板代码"></a>排列模板代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/3/23  14:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Permutation</span> </span>&#123;</span><br><span class="line">    <span class="comment">//全排列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">perm</span><span class="params">(<span class="keyword">char</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == len - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                System.out.print(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; len; i++) &#123;</span><br><span class="line">                swap(arr, start, i);</span><br><span class="line">                perm(arr, start + <span class="number">1</span>, len);</span><br><span class="line">                swap(arr, start, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换两个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] arr = <span class="string">"abc"</span>.toCharArray();</span><br><span class="line">        perm(arr, <span class="number">0</span>, arr.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/80/v2-77719ddaedea6854ac906cbaaa7b4454_720w.jpg" alt="img"></p>
<hr>
<h2 id="组合模板代码"><a href="#组合模板代码" class="headerlink" title="组合模板代码"></a>组合模板代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/3/23  14:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Combination</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[] input, <span class="keyword">char</span>[] output, <span class="keyword">int</span> index, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == output.length) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(output));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = start; j &lt; input.length; j++) &#123;</span><br><span class="line">                output[index] = input[j];</span><br><span class="line">                dfs(input, output, index + <span class="number">1</span>, j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] input = <span class="string">"abc"</span>.toCharArray();</span><br><span class="line">        <span class="comment">//N表示组合中取几位数</span></span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">char</span>[] output = <span class="keyword">new</span> <span class="keyword">char</span>[N];</span><br><span class="line">        dfs(input, output, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic4.zhimg.com/80/v2-67b0531fd3bc3ae3a125ddc897ad65a3_720w.jpg" alt="img"></p>
<p><strong>PS：一般比赛或者笔试都可以直接当作模板来使用。就好比，蓝桥杯比赛和牛客网笔试要带输入输出模板一样。然后就是希望对你们有所帮助。</strong></p>
]]></content>
      <categories>
        <category>算法积累ing</category>
      </categories>
      <tags>
        <tag>算法基础</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap1.8源码粗略解读</title>
    <url>/2020/03/18/HashMap1-8%E6%BA%90%E7%A0%81%E7%B2%97%E7%95%A5%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<p><strong>本文主要以几个方面来讲解一下HashMap：</strong></p>
<ol>
<li><strong>HashMap默认容量</strong></li>
<li><strong>HashMap如何扩容</strong></li>
<li><strong>HashMap的数组大小为什么一定要是2的幂</strong></li>
<li><strong>HashMap为什么是线程不安全的</strong></li>
<li><strong>Java7到Java8做了哪些改进</strong></li>
</ol>
<a id="more"></a>
<h2 id="1、HashMap的默认容量"><a href="#1、HashMap的默认容量" class="headerlink" title="1、HashMap的默认容量"></a><strong>1、HashMap的默认容量</strong></h2><p>从HashMap的构造函数说起。</p>
<p><img src="https://pic3.zhimg.com/80/v2-cd9cd946ef255eb972ecc93e3d95e27e_720w.jpg" alt="img"></p>
<p>initialCapacity表示的是初始化的容量，默认是1&lt;&lt;4（也就是16）；</p>
<p>loadFactor表示的是扩容因子，默认是0.75f（也就是面试常问的3/4）</p>
<p><strong>为啥扩容因子默认是0.75f？（HashMap的源码翻译）</strong></p>
<p><img src="https://pic3.zhimg.com/80/v2-cd921529a13691f02a7d117735e8fc9e_720w.jpg" alt="img"></p>
<p>假如你创建HashMap的时候传入一个不是2的幂的初始值，HashMap会把它转换为离它最近的2的幂的值。假设你输入7，HashMap会默认把他转换为8；输入29，会默认帮你转换为32</p>
<h2 id="2、HashMap如何扩容？"><a href="#2、HashMap如何扩容？" class="headerlink" title="2、HashMap如何扩容？"></a>2、HashMap如何扩容？</h2><p>当put进去的容量大于初始容量*扩容因子时，进行resize操作，就是把初始容量&lt;&lt;1(就是乘以2)进行扩容。</p>
<p><img src="https://pic2.zhimg.com/80/v2-67d62d00b77ca71b81974abefb929475_720w.jpg" alt="img"></p>
<p>源码太长，只截图一部分。1.7的resize操作和transfer操作在1.8合并为resize操作。</p>
<p><img src="https://pic3.zhimg.com/80/v2-e15ae1ecddb070e728a33485a3f79efa_720w.jpg" alt="img"></p>
<h2 id="3、HashMap的数组大小为什么一定要是2的幂？"><a href="#3、HashMap的数组大小为什么一定要是2的幂？" class="headerlink" title="3、HashMap的数组大小为什么一定要是2的幂？"></a>3、HashMap的数组大小为什么一定要是2的幂？</h2><p>首先先说明数组的大小开辟是在put操作而不是在构造函数阶段，这样为了防止创建HashMap的时候就开辟桶的空间，导致浪费，所以在进行put操作的时候才会开辟空间。</p>
<p><img src="https://pic4.zhimg.com/80/v2-93c2baa6af235b15554ca778c057649f_720w.jpg" alt="img"></p>
<p>因为hashcode(key)运算完将近有42亿个值，需要均匀的分布在16个桶里面，所以采用的是<strong>与运算</strong>。</p>
<p><strong>为啥不能用取余操作呢？</strong></p>
<ol>
<li>因为hash%n的话，假设hash算出来是负数，任何负数进行%运算都是负数</li>
<li>因为%运算的本质就是不停的使用除法，没有位运算（&amp;）来的效率高</li>
</ol>
<p>然后就是因为需要用到与运算，假如数组长度不是2的幂会导致与运算完的结果有一部分是0，导致HashMap的不均匀分布。<strong>所以数组大小一定要是2的幂</strong>。为了使HashMap均匀分布，同时还要提高计算机的运行效率，还要把<strong>hash%数组长度</strong>改为<strong>hash&amp;(数组长度-1)。</strong></p>
<h2 id="4、HashMap为什么是线程不安全的？"><a href="#4、HashMap为什么是线程不安全的？" class="headerlink" title="4、HashMap为什么是线程不安全的？"></a>4、HashMap为什么是线程不安全的？</h2><p>HashMap的官方源码用加粗的<strong></strong>标签表明了是该实现是不同步的，也就是线程不安全的。要是有大量并发还用HashMap的话，肯定由你们开发者自己背锅。</p>
<p><img src="https://pic4.zhimg.com/80/v2-527264ea48ef4a23521f4ce961fe2027_720w.jpg" alt="img"></p>
<p>线程不安全的注释翻译如下：</p>
<p><img src="https://pic1.zhimg.com/80/v2-fb3d6ff1d17653b5356cb7fa3c9b9d08_720w.jpg" alt="img"></p>
<h2 id="5、Java7到Java8做了哪些改进？"><a href="#5、Java7到Java8做了哪些改进？" class="headerlink" title="5、Java7到Java8做了哪些改进？"></a>5、Java7到Java8做了哪些改进？</h2><p><strong>1、hash算法的计算方式不同。</strong></p>
<p><img src="https://pic3.zhimg.com/80/v2-5cb81b69c8525d3ff1cb8660e8ca7cb2_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-2df62649ed3b28c84d7055e85c1522a8_720w.jpg" alt="img"></p>
<p><strong>2、jdk1.7的扩容操作在并发场景下会发送死锁现象，在jdk1.8就改进了。</strong>对于怎样产生死锁感兴趣的可以去搜“<strong>codeshell hashmap</strong>”（需要翻墙然后在google上搜索）。其实就rehash的重新插入直接把按照链表的顺序拿下来插入新的链表中。感兴趣的可以google。</p>
<p><strong>3、jdk1.7经典的数组+链表变成了jdk1.8的数组+链表+红黑树</strong></p>
<p>链表的长度阈值到达8就会转换成红黑树。为啥阈值是8？官方给出的源码翻译如下：</p>
<p><img src="https://pic1.zhimg.com/80/v2-101f3effa60096b1ed59ced6d5e4c518_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-0b4d2bde34bfdeaa3e5cafb06ca2becc_720w.jpg" alt="img"></p>
<p>就是到达8的几率已经非常非常接近0了，所以认为几乎不可能达到9，所以阈值设置为8。</p>
<p><strong>PS：以上就是我对HashMap1.7和1.8源码解读所得出来的结论。假如有哪里写得不对的可以指出批评和修改，也可以一起探讨HashMap的学习。</strong></p>
]]></content>
      <categories>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>HashMap源码</tag>
      </tags>
  </entry>
  <entry>
    <title>数值的整数次方</title>
    <url>/2020/03/10/%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>实现函数double Power（double base, int exponent），求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。</p>
</blockquote>
<a id="more"></a>
<h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例1：</span><br><span class="line">输入：2.00000 10</span><br><span class="line">输出：1024.00000</span><br><span class="line"></span><br><span class="line">示例2：</span><br><span class="line">输入：2.10000 3</span><br><span class="line">输出：9.26100</span><br><span class="line"></span><br><span class="line">示例3：</span><br><span class="line">输入：2.00000 -2</span><br><span class="line">输出：0.25000</span><br><span class="line">解释：2^-2 = 1/2^2 = 1/4 = 0.25</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ul>
<li>-100.0&lt; x &lt;100.0</li>
<li>n是32位有符号整数，其数值范围是[-2^31，2^31 -1]。</li>
</ul>
<h2 id="算法思路-二分法"><a href="#算法思路-二分法" class="headerlink" title="算法思路(二分法)"></a>算法思路(二分法)</h2><ul>
<li>当n是偶数时，x^n = (x^2)^(n/2)</li>
<li>当n是奇数时，x^n = x(x^2)^(n/2)，相比偶数多出了一项x</li>
</ul>
<p><img src="https://pic4.zhimg.com/v2-ad6d8dbd563f157d699939c0e84b122f_b.png" alt="img"></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/3/10  19:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Power</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//避免当n为最大值时，进行n=-n时数据越界出错</span></span><br><span class="line">        <span class="keyword">long</span> exponent = n;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">            exponent = -exponent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">while</span> (exponent != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//奇数多出了一项x</span></span><br><span class="line">            <span class="keyword">if</span> ((exponent &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                res = res * x;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//二分操作</span></span><br><span class="line">            x = x * x;</span><br><span class="line">            exponent = exponent &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过截图"><a href="#通过截图" class="headerlink" title="通过截图"></a>通过截图</h2><p><img src="https://pic4.zhimg.com/v2-38ea3404723a97ddbb4ceda3cecb19bb_b.png" alt="img"></p>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(logN)。跟二分操作的时间复杂度一样</li>
<li>空间复杂度：O(1)。没有引入额外的变量</li>
</ul>
<p>ps：参考leetcode大佬<strong>Krahets</strong>的解答。</p>
]]></content>
      <categories>
        <category>LeetCode&amp;牛客题解</category>
      </categories>
      <tags>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title>桶排序</title>
    <url>/2020/03/07/%E6%A1%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="桶排序（百度百科）"><a href="#桶排序（百度百科）" class="headerlink" title="桶排序（百度百科）"></a>桶排序（百度百科）</h2><blockquote>
<p><strong>桶排序 (Bucket sort)</strong>或所谓的<strong>箱排序</strong>，是一个<a href="https://baike.baidu.com/item/排序算法/5399605" target="_blank" rel="noopener">排序算法</a>，工作的原理是将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的<a href="https://baike.baidu.com/item/排序算法/5399605" target="_blank" rel="noopener">排序算法</a>或是以递归方式继续使用桶排序进行排序）。桶排序是<a href="https://baike.baidu.com/item/鸽巢排序/8010555" target="_blank" rel="noopener">鸽巢排序</a>的一种<a href="https://baike.baidu.com/item/归纳/7118703" target="_blank" rel="noopener">归纳</a>结果。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间（<a href="https://baike.baidu.com/item/Θ" target="_blank" rel="noopener">Θ</a>（<em>n</em>））。但桶排序并不是 比较排序，他不受到 O(n*log n) <a href="https://baike.baidu.com/item/下限/10215216" target="_blank" rel="noopener">下限</a>的影响。</p>
</blockquote>
<a id="more"></a>
<h2 id="排序思路（图片来自小灰）"><a href="#排序思路（图片来自小灰）" class="headerlink" title="排序思路（图片来自小灰）"></a>排序思路（图片来自小灰）</h2><p>桶排序是计数排序的升级版，可以不用局限于整数。思路大致相似。首先要确定桶的区间范围。计算方式是（Max - Min）/ （length -1）。length表示桶的数量，然后最后一个桶表示最大值，其他的桶就分范围来存储数据。</p>
<p><img src="https://pic2.zhimg.com/v2-6cb81bf81992229d25c70293260b68b1_b.png" alt="img"></p>
<p>然后遍历数据把数据填入桶中。</p>
<p><img src="https://pic4.zhimg.com/v2-1001a68ce35c57d3cb34aab6be128a47_b.png" alt="img"></p>
<p>桶内进行排序。</p>
<p><img src="https://pic2.zhimg.com/v2-d55444f6d924d1772a614e66199e8bc1_b.png" alt="img"></p>
<p>最后遍历所有桶，把数据以此输出0.5、0.84、2.18、3.25、4.5。然后排序结束。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/3/7  13:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BucketSort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span>[] bucketSort(<span class="keyword">double</span>[] array) &#123;</span><br><span class="line">        <span class="keyword">double</span> max = Double.MIN_VALUE;</span><br><span class="line">        <span class="keyword">double</span> min = Double.MAX_EXPONENT;</span><br><span class="line">        <span class="comment">//求出array数组的最大值和最小值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] &gt; max) &#123;</span><br><span class="line">                max = array[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[i] &lt; min) &#123;</span><br><span class="line">                min = array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算出差值</span></span><br><span class="line">        <span class="keyword">double</span> d = max - min;</span><br><span class="line">        <span class="comment">//初始化桶</span></span><br><span class="line">        <span class="keyword">int</span> bucketNum = array.length;</span><br><span class="line">        ArrayList&lt;LinkedList&lt;Double&gt;&gt; bucketList = <span class="keyword">new</span> ArrayList&lt;&gt;(bucketNum);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketNum; i++) &#123;</span><br><span class="line">            bucketList.add(<span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = (<span class="keyword">int</span>) ((array[i] - min) * (bucketNum - <span class="number">1</span>) / d);</span><br><span class="line">            bucketList.get(num).add(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//JDK底层采用了归并排序或归并的优化版本进行排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketList.size(); i++) &#123;</span><br><span class="line">            Collections.sort(bucketList.get(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出结果</span></span><br><span class="line">        <span class="keyword">double</span>[] sortedArray = <span class="keyword">new</span> <span class="keyword">double</span>[array.length];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (LinkedList&lt;Double&gt; list : bucketList) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">double</span> element : list) &#123;</span><br><span class="line">                sortedArray[index++] = element;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sortedArray;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//主函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span>[] array = <span class="keyword">new</span> <span class="keyword">double</span>[]&#123;<span class="number">3.14</span>, <span class="number">0.002</span>, <span class="number">6.6</span>, <span class="number">3.0</span>, <span class="number">10.01</span>, <span class="number">8.8</span>, <span class="number">4.55</span>, <span class="number">7.89</span>&#125;;</span><br><span class="line">        <span class="keyword">double</span>[] sortedArray = bucketSort(array);</span><br><span class="line">        System.out.println(Arrays.toString(sortedArray));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="https://pic4.zhimg.com/v2-57ad2676a56f7e4aad1acf752a54f99b_b.png" alt="img"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>这个桶排序也是一种线性时间的排序算法。因为它不是通过比较来进行排序，而是通过桶来排序。理论上时间复杂度为O(N)。对桶排序感兴趣的可以深入学习一下。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法积累ing</category>
      </categories>
      <tags>
        <tag>基础排序</tag>
      </tags>
  </entry>
  <entry>
    <title>计数排序</title>
    <url>/2020/03/06/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="计数排序（百度百科）"><a href="#计数排序（百度百科）" class="headerlink" title="计数排序（百度百科）"></a>计数排序（百度百科）</h2><blockquote>
<p>计数排序是一个非基于比较的<a href="https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/5399605" target="_blank" rel="noopener">排序算法</a>，该算法于1954年由 Harold H. Seward  提出。它的优势在于在对一定范围内的整数排序时，它的复杂度为Ο(n+k)（其中k是整数的范围），快于任何比较排序算法。 [1]   当然这是一种牺牲空间换取时间的做法，而且当O(k)&gt;O(n*log(n))的时候其效率反而不如基于比较的排序（基于比较的排序的时间复杂度在理论上的下限是O(n*log(n)), 如归并排序，堆排序）</p>
</blockquote>
<a id="more"></a>
<h2 id="排序思路"><a href="#排序思路" class="headerlink" title="排序思路"></a>排序思路</h2><ol>
<li>假设有N个数的数组Array，取值范围在（0~9）之间，所以初始化一个数组countArray大小为10（即最大值+1），然后全部初始化为0</li>
<li>遍历Array数组填充countArray数组。就是把Array数组的值作为countArray数组的下标然后加1</li>
<li>遍历countArray数组，把值按照顺序填回Array数组，最终输出结果即可</li>
</ol>
<h2 id="图示过程（菜鸟教程）"><a href="#图示过程（菜鸟教程）" class="headerlink" title="图示过程（菜鸟教程）"></a>图示过程（菜鸟教程）</h2><p><img src="https://pic1.zhimg.com/v2-827d96b8ca3682e8775f4916f22b45ac_b.webp" alt="img"></p>
<h2 id="算法局限性"><a href="#算法局限性" class="headerlink" title="算法局限性"></a>算法局限性</h2><ul>
<li>当数列中的元素不是整数的时候，不适合用计数排序</li>
<li>当数列中的元素最大值和最小值差距过大时，不适合用计数排序</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/3/6  19:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountSort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] countSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">        <span class="comment">//求Array数组的最大值</span></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] &gt; max) &#123;</span><br><span class="line">                max = array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个长度为max+1的countArray数组</span></span><br><span class="line">        <span class="keyword">int</span>[] countArray = <span class="keyword">new</span> <span class="keyword">int</span>[max + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//计数排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            countArray[array[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] sortedArray = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; countArray.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; countArray[i]; j++) &#123;</span><br><span class="line">                sortedArray[index++] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sortedArray;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//主函数入口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] sortedArray = countSort(array);</span><br><span class="line">        System.out.println(Arrays.toString(sortedArray));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行截图"><a href="#运行截图" class="headerlink" title="运行截图"></a>运行截图</h2><p><img src="https://pic1.zhimg.com/80/v2-df64e7422e1dce874e910dcda9d8d710_720w.jpg" alt="img"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>计数排序的时间复杂度可以做到O(N)，因为它的原理不是比较，而是计数。而通过比较达到排序效果的最快也要O(N*logN)。所以计数排序能达到线性排序的效果，但是这个算法有着局限性（max和min的差距不能过大；必须是整数）。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法积累ing</category>
      </categories>
      <tags>
        <tag>基础排序</tag>
      </tags>
  </entry>
  <entry>
    <title>基础排序（冒泡、选择、插入）</title>
    <url>/2020/02/27/%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%EF%BC%88%E5%86%92%E6%B3%A1%E3%80%81%E9%80%89%E6%8B%A9%E3%80%81%E6%8F%92%E5%85%A5%EF%BC%89/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>基本每个人入门数据结构和算法都是先经历过排序，今天就来讲解一下最基础的三个入门排序算法。分别是<strong>冒泡排序</strong>、<strong>选择排序</strong>和<strong>插入排序</strong>。</p>
</blockquote>
<a id="more"></a>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p><strong>思路：两两交换，小的往左边，大的往右边。</strong></p>
<p><img src="https://pic2.zhimg.com/80/v2-49710083e8808348f2867ea1f23482c1_720w.png" alt="img"></p>
<p>就是每趟过程把最大的数往右边靠，然后从剩下的数继续刚才的过程。</p>
<h2 id="代码（冒泡排序）"><a href="#代码（冒泡排序）" class="headerlink" title="代码（冒泡排序）"></a>代码（冒泡排序）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/2/27  14:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">//冒泡排序，两两比较，小的往左边，大的往右边</span></span><br><span class="line">    <span class="comment">//时间复杂度O(n^2)  稳定排序  空间复杂度O(1)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="comment">//避免已经排好序了还要继续循环下次</span></span><br><span class="line">            <span class="keyword">boolean</span> isSorded = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    swap(array, j, j + <span class="number">1</span>);</span><br><span class="line">                    isSorded = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isSorded) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换两数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        sort(array);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结果（冒泡排序）"><a href="#结果（冒泡排序）" class="headerlink" title="结果（冒泡排序）"></a>结果（冒泡排序）</h2><p><img src="https://pic2.zhimg.com/80/v2-14cde89a7007b96da781b099c68ccc08_720w.png" alt="img"></p>
<hr>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p><strong>思路：每一次从待排序的数据元素种选出最小的元素，存放在数组的起始位置，知道全部排序完成</strong></p>
<p><img src="https://pic2.zhimg.com/80/v2-a5fd3982db5b81c77a7923d4c1a6c713_720w.png" alt="img"></p>
<p>每次都选出最小的，然后跟待排序的第一个数交换位置，直到全部排序完成。</p>
<h2 id="代码（选择排序）"><a href="#代码（选择排序）" class="headerlink" title="代码（选择排序）"></a><strong>代码（选择排序）</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/2/27  14:18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">//选择排序</span></span><br><span class="line">    <span class="comment">//思路：从数组第一个数开始跟后面的数比较，最小和第一个交换，循环进行</span></span><br><span class="line">    <span class="comment">//时间复杂度：O(n^2)  空间复杂度O(1)  不稳定排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> minIndex = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; array.length; j++) &#123;</span><br><span class="line">                minIndex = array[minIndex] &gt; array[j] ? j : minIndex;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(array, i, minIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换两数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        selectionSort(array);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结果（选择排序）"><a href="#结果（选择排序）" class="headerlink" title="结果（选择排序）"></a>结果（选择排序）</h2><p><img src="https://pic4.zhimg.com/80/v2-be00344af30c21e0c9dfcdac24291c4e_720w.png" alt="img"></p>
<hr>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>思路：跟打扑克牌一样。维持一个有序区，然后后面进来的数跟有序区比较，然后插入</p>
<p><img src="https://pic2.zhimg.com/80/v2-374ecbfdc56e0b350358584056363738_720w.png" alt="img"></p>
<h2 id="代码（插入排序）"><a href="#代码（插入排序）" class="headerlink" title="代码（插入排序）"></a>代码（插入排序）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/2/27  14:32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChaRuSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">//插入排序，跟打扑克牌一样</span></span><br><span class="line">    <span class="comment">//时间复杂度O(n^2) 空间复杂度O(1)  稳定排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; array[j] &gt; array[j + <span class="number">1</span>]; j--) &#123;</span><br><span class="line">                swap(array, j, j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换两数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        sort(array);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结果（插入排序）"><a href="#结果（插入排序）" class="headerlink" title="结果（插入排序）"></a>结果（插入排序）</h2><p><img src="https://pic2.zhimg.com/80/v2-e0f96e22cefa5145ef35bb29e7fae6c8_720w.png" alt="img"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>这三个基础入门排序的时间复杂度都为O(N^2)，空间复杂度都为O(1)。</li>
<li>冒泡排序和插入排序都是稳定性排序，选择排序不是稳定性排序。</li>
<li>本质上，冒泡排序的进阶是快速排序。</li>
<li>本质上，插入排序的进阶是希尔排序。</li>
</ul>
]]></content>
      <categories>
        <category>算法积累ing</category>
      </categories>
      <tags>
        <tag>基础排序</tag>
      </tags>
  </entry>
  <entry>
    <title>编辑距离（困难）</title>
    <url>/2020/02/19/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h2 id="LeetCode72编辑距离"><a href="#LeetCode72编辑距离" class="headerlink" title="LeetCode72编辑距离"></a>LeetCode72编辑距离</h2><blockquote>
<p>给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数。你可以对一个单词进行如下三个操作：1，插入一个字符 2，删除一个字符 3，替换一个字符</p>
</blockquote>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">示例<span class="number">1</span>：</span><br><span class="line">输入：word1 = <span class="string">"horse"</span>, word2 = <span class="string">"ros"</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释:</span><br><span class="line">horse -&gt; rorse(将<span class="string">'h'</span>替换成<span class="string">'r'</span>)</span><br><span class="line">rorse -&gt; rose(删除<span class="string">'r'</span>)</span><br><span class="line">rose -&gt; ros(删除<span class="string">'e'</span>)</span><br><span class="line"></span><br><span class="line">示例<span class="number">2</span>：</span><br><span class="line">输入：word1 = <span class="string">"intention"</span>, word2 = <span class="string">"execution"</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：</span><br><span class="line">intention -&gt; inention(删除<span class="string">'t'</span>)</span><br><span class="line">inention -&gt; enention(将<span class="string">'i'</span>替换为<span class="string">'e'</span>)</span><br><span class="line">enention -&gt; exention(将<span class="string">'n'</span>替换为<span class="string">'x'</span>)</span><br><span class="line">exention -&gt; exection(将<span class="string">'n'</span>替换为<span class="string">'c'</span>)</span><br><span class="line">exection -&gt; execution(插入<span class="string">'u'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul>
<li>dp[i][j] 表示 word1 到 i 位置 转换成 word2 到 j 位置需要最少的步数。</li>
<li>当 word1[i] == word2[j]，dp[i][j] = dp[i-1][j-1]；</li>
<li>当 word1[i] != word2[j]，dp[i][j] = min(dp[i-1][j-1]，dp[i-1][j]，dp[i][j-1])+1；</li>
</ul>
<p>其中的dp[i-1][j-1]表示代替操作，dp[i-1][j]表示删除操作，dp[i][j-1]表示插入操作。</p>
<p>以上的替换、删除、插入操作都是对 word1 来说的。</p>
<h2 id="代码（自顶向下）暴力递归"><a href="#代码（自顶向下）暴力递归" class="headerlink" title="代码（自顶向下）暴力递归"></a>代码（自顶向下）暴力递归</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/2/19  17:08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinDistance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length1 = word1.length();</span><br><span class="line">        <span class="keyword">int</span> length2 = word2.length();</span><br><span class="line">        <span class="keyword">return</span> min(word1, word2, length1, length2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(String word1, String word2, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> j;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> min(word1, word2, i - <span class="number">1</span>, j - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> len1 = min(word1, word2, i - <span class="number">1</span>, j - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> len2 = min(word1, word2, i - <span class="number">1</span>, j) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> len3 = min(word1, word2, i, j - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> Math.min(Math.min(len1, len2), len3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>因为有重复计算的过程，而且无后效性。即一个函数f(n)一旦确定，那么之后就可以直接调用它的值，不用再关心f(n)的计算过程了，这个就是无后效性。</strong></p>
<h2 id="代码（自底向上）动态规划"><a href="#代码（自底向上）动态规划" class="headerlink" title="代码（自底向上）动态规划"></a><strong>代码（自底向上）动态规划</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/2/19  17:08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinDistance</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> length1 = word1.length();</span><br><span class="line">            <span class="keyword">int</span> length2 = word2.length();</span><br><span class="line">            <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[length1 + <span class="number">1</span>][length2 + <span class="number">1</span>];</span><br><span class="line">            <span class="comment">//初始化base case</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= length1; i++) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= length2; j++) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//填充二维数组dp表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= length1; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= length2; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                        dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = Math.min(Math.min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]), dp[i][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> dp[length1][length2];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>基本上动态规划都是暴力递归改过来的。最长公共子序列、凑硬币等都是通过这种方法写出动态规划的状态转移方程。没有必要去背状态转移方程式，也不用一直想着最优子结构等名词。最需要写出暴力递归，观察能不能改动态规划即可。</strong></p>
<p><strong>递归就是“暴力的枚举”，期间可能包括一大堆重复计算，而且一般时间复杂度都是O(2^N)。改成动态规划就是“聪明的枚举”，可以省掉重复的计算。</strong></p>
]]></content>
      <categories>
        <category>LeetCode&amp;牛客题解</category>
      </categories>
      <tags>
        <tag>困难</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划的高度套路</title>
    <url>/2020/02/18/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E9%AB%98%E5%BA%A6%E5%A5%97%E8%B7%AF/</url>
    <content><![CDATA[<h2 id="动态规划（百度百科）"><a href="#动态规划（百度百科）" class="headerlink" title="动态规划（百度百科）"></a>动态规划（百度百科）</h2><blockquote>
<p>动态规划(dynamic programming)是<a href="https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E8%BF%90%E7%AD%B9%E5%AD%A6/1559" target="_blank" rel="noopener">运筹学</a>的一个分支，是求解决策过程(decision process)最优化的数学方法。20世纪50年代初<a href="https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E7%BE%8E%E5%9B%BD" target="_blank" rel="noopener">美国</a>数学家R.E.Bellman等人在研究多阶段决策过程(multistep  decision process)的优化问题时，提出了著名的最优化原理(principle of   optimality)，把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解，创立了解决这类过程优化问题的新方法——动态规划。1957年出版了他的名著《Dynamic  Programming》，这是该领域的第一本著作。</p>
</blockquote>
<a id="more"></a>
<h2 id="我对动态规划这个算法的理解"><a href="#我对动态规划这个算法的理解" class="headerlink" title="我对动态规划这个算法的理解"></a>我对动态规划这个算法的理解</h2><blockquote>
<p>当初大二接触到数据结构这门课，学习了动态规划这种算法，老师一直说很难。加上自己当初上网查都是状态转移方程、重叠子问题、最优子结构。真的是让我无能为力，无从下手。每次解动态规划老想着状态转移方程怎么得到的，所以让我望而止步。最后知道了动态规划都是高度套路的之后，其实也是挺好理解的了。</p>
</blockquote>
<h2 id="动态规划的高度套路"><a href="#动态规划的高度套路" class="headerlink" title="动态规划的高度套路"></a>动态规划的高度套路</h2><blockquote>
<p><strong>动态规划统一都是由暴力递归–&gt;找到有重复计算的子问题–&gt;动态规划。</strong></p>
</blockquote>
<p>要是你要问，状态转移方程怎么来的，改暴力递归来的。动态规划就是这个一个高度套路。</p>
<h2 id="示例1（斐波那契数列）"><a href="#示例1（斐波那契数列）" class="headerlink" title="示例1（斐波那契数列）"></a>示例1（斐波那契数列）</h2><p>大家应该都知道这个数列，f(1)=1，f(2)=1，f(n)=f(n-1)+f(n-2)。</p>
<p><strong>暴力递归写法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(N==<span class="number">1</span> || N==<span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> fib(N-<span class="number">1</span>) + fib(N-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个解法的递归展开图是这样的（以N=10举例）：</p>
<p><img src="https://pic2.zhimg.com/80/v2-12205e947e061454d2ee064010431059_hd.jpg" alt="img"></p>
<p>这个时候发现<strong>自顶向下</strong>的递归展开图有一些计算过程都是重复的，比如fib(8)，fib(7)等，所以这样的暴力递归是可以改成动态规划的。就是改成<strong>自底向上</strong>的解法</p>
<h2 id="改动态规划的步骤"><a href="#改动态规划的步骤" class="headerlink" title="改动态规划的步骤"></a>改动态规划的步骤</h2><ul>
<li>首先找到暴力递归的base case。就是fib(1)=1，fib(2)=1</li>
<li>然后任意一个N都可以由fib(N)=fib(N-1)+fib(N-2)求出</li>
</ul>
<h2 id="代码（动态规划）"><a href="#代码（动态规划）" class="headerlink" title="代码（动态规划）"></a>代码（动态规划）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">1</span> || N == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i++) &#123;</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[N - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然这个还可以优化成空间复杂度为O(1)的解法，但不在本文的讨论范围内。我们只讲暴力递归能改动态规划的套路。</p>
<h2 id="示例2（最小路径和）"><a href="#示例2（最小路径和）" class="headerlink" title="示例2（最小路径和）"></a>示例2（最小路径和）</h2><blockquote>
<p>给定一个包含非负整数的M*N的矩阵，从左上角走到右下角的过程，使路径上的数字总和为最小。每次只能向下或者向右移动一步。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[</span><br><span class="line">  [1, 3, 1],</span><br><span class="line">  [1, 5, 1],</span><br><span class="line">  [4, 2, 1]</span><br><span class="line">]</span><br><span class="line">输出：7</span><br><span class="line">解释：因为路径1-&gt;3-&gt;1-&gt;1-&gt;1的总和最小。</span><br></pre></td></tr></table></figure>
<p><strong>先写暴力递归解法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case走到最后一格了</span></span><br><span class="line">    <span class="keyword">if</span> (i == matrix.length - <span class="number">1</span> &amp;&amp; j == matrix[<span class="number">0</span>].length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> matrix[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后一行，只能向右走</span></span><br><span class="line">    <span class="keyword">if</span> (i == matrix.length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> matrix[i][j] + minPathSum(matrix, i, j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后一列，只能向下走</span></span><br><span class="line">    <span class="keyword">if</span> (j == matrix[<span class="number">0</span>].length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> matrix[i][j] + minPathSum(matrix, i + <span class="number">1</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其他情况</span></span><br><span class="line">    <span class="keyword">int</span> right = minPathSum(matrix, i, j + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> down = minPathSum(matrix, i + <span class="number">1</span>, j);</span><br><span class="line">    <span class="keyword">return</span> matrix[i][j] + Math.min(right, down);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候的<strong>自顶向下</strong>的递归展开图是这样的（以3*3为例）：</p>
<p><img src="https://pic4.zhimg.com/80/v2-7f85813abd6940c548e5bbba057e1ddb_hd.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">此时f(0,0)=Math.min（f(0,1), f(1,0)），</span><br><span class="line">然后f(0,1)=Math.min（f(0,2), f(1,1)），</span><br><span class="line">然后f(1,0)=Math.min（f(1,1）,f(2,0)）。此时f(1,1)就重复计算了，一直递归下去就会一直重复计算</span><br></pre></td></tr></table></figure>
<p>这个时候发现<strong>自顶向下</strong>的递归展开图又有一些计算过程使重复的，可以改成非递归的动态规划<strong>自底向上</strong>的解法</p>
<h2 id="改动态规划的步骤-1"><a href="#改动态规划的步骤-1" class="headerlink" title="改动态规划的步骤"></a>改动态规划的步骤</h2><ul>
<li>先找到base case，就是最右角的值，matrix[i][j]。就是你不管用什么方法走，最后都是走到matrix[i][j]，即右下角那个地方，所以那个地方就是最小值</li>
<li>然后确定了右下角的值，就可以求出最后一行和最后一列的值</li>
<li>接下来就是matrix[i][j]的值会等于它右边和下边的值的最小值</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-2a8a7c532ce4ede4e2e80932c1128794_hd.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-3f7b681ee9198a5ca0390f82fb964c93_hd.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-83fb6ea19527107cf15ba4706b8fcbce_hd.jpg" alt="img"></p>
<p><strong>这就相当于你知道了它的base case（右下角的值），填一张二维数组的dp表，然后dp[0][0]就是左上角到右下角的最短路径</strong></p>
<h2 id="代码（动态规划）-1"><a href="#代码（动态规划）-1" class="headerlink" title="代码（动态规划）"></a>代码（动态规划）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[grid.length][grid[<span class="number">0</span>].length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = dp.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = dp[<span class="number">0</span>].length - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == dp.length - <span class="number">1</span> &amp;&amp; j == dp[<span class="number">0</span>].length - <span class="number">1</span>) &#123;</span><br><span class="line">                dp[i][j] = grid[i][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == dp.length - <span class="number">1</span> &amp;&amp; j != dp[<span class="number">0</span>].length - <span class="number">1</span>) &#123;</span><br><span class="line">                dp[i][j] = grid[i][j] + dp[i][j + <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == dp[<span class="number">0</span>].length - <span class="number">1</span> &amp;&amp; i != dp.length - <span class="number">1</span>) &#123;</span><br><span class="line">                dp[i][j] = grid[i][j] + dp[i + <span class="number">1</span>][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i + <span class="number">1</span>][j], dp[i][j + <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的这道题改成动态规划后可以优化成空间复杂度为O(1)的解法，但是本文就不讨论后续的优化，只讨论怎么把暴力递归改成动态规划解法。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>其实递归的本质就是“穷举”，然后它不知道怎么优化，它只会自顶向下无限展开，直到base  case停下。然后动态规划相比于它就是自底向上计算，不会重复计算，相当于“聪明的穷举”。然后就是暴力递归改动态规划是需要有计算重复过程的时候，并且此时的状态只与以后的状态有关，和之前的状态无光，这种称为无后效性。这种可以改为动态规划。</p>
</blockquote>
<p>PS：递归算法如汉诺塔问题、N皇后问题都不能改为动态规划，因为它们此时的状态与之前的状态是有联系的。因为汉诺塔需要打印出每一步的过程，而且没有重复计算，所以不能改动态规划。然后N皇后每一步下的棋都会影响到下一步，所以也不能改动态规划。</p>
<p>在leetcode看到大神的一个比喻：你的原问题是考出最高的成绩，那么你的子问题就是把语文考最高分，数学考最高分……为了每门课考到最高，你要把每门课相对应的选择题分数拿到最高，填空题分数拿到最高……当然，最终你的每门课都是满分，这就是最高的总成绩。</p>
<p>得到了正确的结果：最高的总成绩就是总分。因为整个过程符合最优子结构，”每门科目考到最高“这些子问题互相独立，互不干扰。</p>
<p>但是，如果加一个条件：你的语文成绩和数学成绩会互相制约，此消彼长。这样的话你能考到的最高总成绩就达不到总分了，按照刚才的思路就得不到正确的结果。因为子问题不独立，所以最优子结构会被破坏。</p>
<p><strong>最后就是如果有写不对的地方可以评论或者私信我，想和我一起讨论数据结构的也可以评论和私聊我，本人非常乐意学习和进步</strong></p>
]]></content>
      <categories>
        <category>算法积累ing</category>
      </categories>
      <tags>
        <tag>算法进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>数组中的逆序对（困难）</title>
    <url>/2020/02/16/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>最近一直在家刷面经，因为疫情也出不去。所以没事就会在知乎回答别人提出的问题，还有就是刷题。最近<strong>leetcode</strong>授权了<strong>剑指offer</strong>的题，然后就当作我是复习吧。目前还在刷，今晚吃饱刷到这道<strong>归并排序</strong>的进阶题目——<strong>数组中的逆序对</strong>，所以写一篇关于它的题解吧。</p>
</blockquote>
<a id="more"></a>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p>
</blockquote>
<p><strong>实例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[7, 5, 6, 4]</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>
<p><strong>限制：0&lt;=数组长度&lt;=50000</strong></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a><strong>思路</strong></h2><p>其实这道题的本质就是<strong>归并排序</strong>。我就当你已经会<strong>归并排序</strong>了。当进行<strong>合并操作</strong>的时候，如果<strong>nums[p1]&gt;nums[p2]</strong>的话，那么这个时候就组成逆序对。然后就是<strong>nums[p1]~nums[mid]</strong>都大于<strong>nums[p2]</strong>，所以此时的逆序对数就是<strong>mid-p1+1</strong>。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/2/16  19:49</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReversePairs</span> </span>&#123;</span><br><span class="line">    <span class="comment">//统计逆序对的总数</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        mergeSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//归并排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = start + ((end - start) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            mergeSort(nums, start, mid);</span><br><span class="line">            mergeSort(nums, mid + <span class="number">1</span>, end);</span><br><span class="line">            <span class="comment">//合并操作</span></span><br><span class="line">            merge(nums, start, mid, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> mid, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[end - start + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> p1 = start;</span><br><span class="line">        <span class="keyword">int</span> p2 = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= end) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[p1] &lt;= nums[p2]) &#123;</span><br><span class="line">                temp[p++] = nums[p1++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//此时就是nums[p1]&gt;nums[p2]的时候，组成逆序对</span></span><br><span class="line">                <span class="comment">//数量是mid-p1+1</span></span><br><span class="line">                count = count + mid - p1 + <span class="number">1</span>;</span><br><span class="line">                temp[p++] = nums[p2++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= mid) &#123;</span><br><span class="line">            temp[p++] = nums[p1++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p2 &lt;= end) &#123;</span><br><span class="line">            temp[p++] = nums[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">            nums[i + start] = temp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度为：O(N<em>logN)。因为是归并排序，所以时间复杂度为O(N</em>logN)。</li>
<li>空间复杂度为：O(N)。因为借助了辅助数组temp</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode&amp;牛客题解</category>
      </categories>
      <tags>
        <tag>困难</tag>
      </tags>
  </entry>
  <entry>
    <title>K个一组翻转链表</title>
    <url>/2020/02/14/K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>给你一个链表，每k个节点一组进行翻转，请你返回翻转后得链表。</p>
<p>k是一个正整数，它的值小于或等于链表的长度。</p>
<p>如果节点总数不是k的整数倍，那么请将最后剩余的节点保持原有顺寻。</p>
</blockquote>
<a id="more"></a>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><blockquote>
<p>给定这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5</p>
<p>当k=2时，应当返回：2-&gt;1-&gt;4-&gt;3-&gt;5</p>
<p>当k=3时，应当返回：3-&gt;2-&gt;1-&gt;4-&gt;5</p>
</blockquote>
<h2 id="思路（看图看代码）"><a href="#思路（看图看代码）" class="headerlink" title="思路（看图看代码）"></a>思路（看图看代码）</h2><p>用4个指针（pre, end, start, next）来记录完成整个过程。</p>
<p><img src="https://pic4.zhimg.com/v2-7f54e75544b77687679355112c275ca3_b.png" alt="img"></p>
<p><img src="https://pic1.zhimg.com/v2-b3bb4db2076ec2ce1b12ecd2ba96f170_b.png" alt="img"></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/2/14  11:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseKGroup</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        ListNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//K个一组翻转链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dummy是虚拟节点</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode pre = dummy;</span><br><span class="line">        ListNode end = dummy;</span><br><span class="line">        <span class="keyword">while</span> (end != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k &amp;&amp; end != <span class="keyword">null</span>; i++) &#123;</span><br><span class="line">                end = end.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (end == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode start = pre.next;</span><br><span class="line">            ListNode next = end.next;</span><br><span class="line">            end.next = <span class="keyword">null</span>;</span><br><span class="line">            pre.next = reverse(start);</span><br><span class="line">            start.next = next;</span><br><span class="line">            pre = start;</span><br><span class="line">            end = start;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反转链表并返回头节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode p1 = head;</span><br><span class="line">        ListNode p2 = head.next;</span><br><span class="line">        ListNode p3 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (p2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            p3 = p2.next;</span><br><span class="line">            p2.next = p1;</span><br><span class="line">            p1 = p2;</span><br><span class="line">            p2 = p3;</span><br><span class="line">        &#125;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        head = p1;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度为O(N*K)。最好的情况是O(N)，最坏的情况是O(N^2)</li>
<li>空间复杂度为O(1)</li>
</ul>
<p><strong>PS：这道题确实挺有难度，然后leetcode上我参考了王小二大佬的图和思路，然后自己写的代码。</strong></p>
]]></content>
      <categories>
        <category>LeetCode&amp;牛客题解</category>
      </categories>
      <tags>
        <tag>困难</tag>
      </tags>
  </entry>
  <entry>
    <title>（经典）求两个单链表相交结点</title>
    <url>/2020/02/12/%EF%BC%88%E7%BB%8F%E5%85%B8%EF%BC%89%E6%B1%82%E4%B8%A4%E4%B8%AA%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>在本题中，单链表可能有环，也可能无环。给定两个单链表的头节点head1和head2，这两个链表可能相交，也可能不相交。请实现一个函数，如果两个链表相交，请返回相交的第一个节点；如果不相交，返回null即可。 要求：如果链表1的长度为N，链表2的长度为M，时间复杂度请达到O(N+M)，额外空间复杂度请达到O(1)。</p>
</blockquote>
<a id="more"></a>
<h2 id="考察点"><a href="#考察点" class="headerlink" title="考察点"></a>考察点</h2><ul>
<li>判断链表是否有环</li>
<li>如果链表有环，则找到入环结点</li>
<li>两个链表各种情况的分析</li>
</ul>
<h2 id="情况分析"><a href="#情况分析" class="headerlink" title="情况分析"></a>情况分析</h2><p>这道题总共有6种情况要分析。分别是</p>
<ul>
<li>两个链表无环</li>
<li>两个链表有环</li>
<li>一个链表有环，一个链表无环</li>
</ul>
<p><img src="https://pic4.zhimg.com/v2-9353fd155db887b0b4296543c5ac9f4b_b.png" alt="img"></p>
<p>1、如果两个链表都无环，那就直接判断是否相交即可。</p>
<p>2、如果两个链表都有环，求出入口节点。</p>
<p>求出入口节点，如果入口节点是同一个的话，把相同的入口结点当作是<strong>尾结点</strong>，这个问题就退化成<strong>两个链表都无环</strong>，直接判断是否相交即可。</p>
<p>如果入口节点不是同一个的话，从第一个入口节点开始next下去，如果<strong>遇到第二个入口节点返回</strong>即可；如果<strong>回到了本身的入口节点</strong>则表示没有相交，直接返回null</p>
<p>3、如果<strong>一个链表有环</strong>，<strong>一个链表无环</strong>，那么这<strong>两个链表必不可能相交</strong></p>
<p><strong>所有的情况就都已经分析完了，接下来就是上代码了</strong></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> zuoshen;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/2/12  11:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindFirstIntersectNode</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Java版．左老师给出的代码，很赞</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getIntersectNode</span><span class="params">(Node head1, Node head2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head1 == <span class="keyword">null</span> || head2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//求head1和head2的入环结点</span></span><br><span class="line">        Node loop1 = getLoopNode(head1);</span><br><span class="line">        Node loop2 = getLoopNode(head2);</span><br><span class="line">        <span class="comment">//head1和head2都没有环</span></span><br><span class="line">        <span class="keyword">if</span> (loop1 == <span class="keyword">null</span> &amp;&amp; loop2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> noLoop(head1, head2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//head1和head2都有环</span></span><br><span class="line">        <span class="keyword">if</span> (loop1 != <span class="keyword">null</span> &amp;&amp; loop2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> bothLoop(head1, loop1, head2, loop2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当一个有环一个无环则不存在相交结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getLoopNode</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node n1 = head.next; <span class="comment">// n1 -&gt; slow</span></span><br><span class="line">        Node n2 = head.next.next; <span class="comment">// n2 -&gt; fast</span></span><br><span class="line">        <span class="keyword">while</span> (n1 != n2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n2.next == <span class="keyword">null</span> || n2.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            n2 = n2.next.next;</span><br><span class="line">            n1 = n1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        n2 = head; <span class="comment">// n2 -&gt; walk again from head</span></span><br><span class="line">        <span class="keyword">while</span> (n1 != n2) &#123;</span><br><span class="line">            n1 = n1.next;</span><br><span class="line">            n2 = n2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">noLoop</span><span class="params">(Node head1, Node head2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head1 == <span class="keyword">null</span> || head2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node cur1 = head1;</span><br><span class="line">        Node cur2 = head2;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur1.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            n++;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (cur2.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            n--;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur1 != cur2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur1 = n &gt; <span class="number">0</span> ? head1 : head2;</span><br><span class="line">        cur2 = cur1 == head1 ? head2 : head1;</span><br><span class="line">        n = Math.abs(n);</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            n--;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (cur1 != cur2) &#123;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">bothLoop</span><span class="params">(Node head1, Node loop1, Node head2, Node loop2)</span> </span>&#123;</span><br><span class="line">        Node cur1 = <span class="keyword">null</span>;</span><br><span class="line">        Node cur2 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (loop1 == loop2) &#123;</span><br><span class="line">            cur1 = head1;</span><br><span class="line">            cur2 = head2;</span><br><span class="line">            <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (cur1 != loop1) &#123;</span><br><span class="line">                n++;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (cur2 != loop2) &#123;</span><br><span class="line">                n--;</span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur1 = n &gt; <span class="number">0</span> ? head1 : head2;</span><br><span class="line">            cur2 = cur1 == head1 ? head2 : head1;</span><br><span class="line">            n = Math.abs(n);</span><br><span class="line">            <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">                n--;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (cur1 != cur2) &#123;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cur1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur1 = loop1.next;</span><br><span class="line">            <span class="keyword">while</span> (cur1 != loop1) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur1 == loop2) &#123;</span><br><span class="line">                    <span class="keyword">return</span> loop1;</span><br><span class="line">                &#125;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;null</span></span><br><span class="line">        Node head1 = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">        head1.next = <span class="keyword">new</span> Node(<span class="number">2</span>);</span><br><span class="line">        head1.next.next = <span class="keyword">new</span> Node(<span class="number">3</span>);</span><br><span class="line">        head1.next.next.next = <span class="keyword">new</span> Node(<span class="number">4</span>);</span><br><span class="line">        head1.next.next.next.next = <span class="keyword">new</span> Node(<span class="number">5</span>);</span><br><span class="line">        head1.next.next.next.next.next = <span class="keyword">new</span> Node(<span class="number">6</span>);</span><br><span class="line">        head1.next.next.next.next.next.next = <span class="keyword">new</span> Node(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 0-&gt;9-&gt;8-&gt;6-&gt;7-&gt;null</span></span><br><span class="line">        Node head2 = <span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">        head2.next = <span class="keyword">new</span> Node(<span class="number">9</span>);</span><br><span class="line">        head2.next.next = <span class="keyword">new</span> Node(<span class="number">8</span>);</span><br><span class="line">        head2.next.next.next = head1.next.next.next.next.next; <span class="comment">// 8-&gt;6</span></span><br><span class="line">        System.out.println(getIntersectNode(head1, head2).value);<span class="comment">//output:6</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;4...</span></span><br><span class="line">        head1 = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">        head1.next = <span class="keyword">new</span> Node(<span class="number">2</span>);</span><br><span class="line">        head1.next.next = <span class="keyword">new</span> Node(<span class="number">3</span>);</span><br><span class="line">        head1.next.next.next = <span class="keyword">new</span> Node(<span class="number">4</span>);</span><br><span class="line">        head1.next.next.next.next = <span class="keyword">new</span> Node(<span class="number">5</span>);</span><br><span class="line">        head1.next.next.next.next.next = <span class="keyword">new</span> Node(<span class="number">6</span>);</span><br><span class="line">        head1.next.next.next.next.next.next = <span class="keyword">new</span> Node(<span class="number">7</span>);</span><br><span class="line">        head1.next.next.next.next.next.next.next = head1.next.next.next; <span class="comment">// 7-&gt;4</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 0-&gt;9-&gt;8-&gt;2...</span></span><br><span class="line">        head2 = <span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">        head2.next = <span class="keyword">new</span> Node(<span class="number">9</span>);</span><br><span class="line">        head2.next.next = <span class="keyword">new</span> Node(<span class="number">8</span>);</span><br><span class="line">        head2.next.next.next = head1.next; <span class="comment">// 8-&gt;2</span></span><br><span class="line">        System.out.println(getIntersectNode(head1, head2).value);<span class="comment">//output:2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 0-&gt;9-&gt;8-&gt;6-&gt;4-&gt;5-&gt;6..</span></span><br><span class="line">        head2 = <span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">        head2.next = <span class="keyword">new</span> Node(<span class="number">9</span>);</span><br><span class="line">        head2.next.next = <span class="keyword">new</span> Node(<span class="number">8</span>);</span><br><span class="line">        head2.next.next.next = head1.next.next.next.next.next; <span class="comment">// 8-&gt;6</span></span><br><span class="line">        System.out.println(getIntersectNode(head1, head2).value);<span class="comment">//output:4</span></span><br><span class="line">        System.out.println(getIntersectNode(head2, head1).value);<span class="comment">//note the order //output:6</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>这道题其实是挺难的，但是听了左神老师讲完之后发现也就那样。由此可见，一道难的题目都是由一些简单的题目组合起来的。这道题就是<strong>两个无环链表判断相交并且返回相交节点，有环链表求它的入环节点，</strong>这两道题目的组合就是今天这道题的由来，所以情况更加的复杂。</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode&amp;牛客题解</category>
      </categories>
      <tags>
        <tag>困难</tag>
      </tags>
  </entry>
  <entry>
    <title>进程与线程的一个简单解释</title>
    <url>/2020/02/11/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E8%A7%A3%E9%87%8A/</url>
    <content><![CDATA[<p><strong>转载自阮一峰大佬的网络日志</strong></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><blockquote>
<p><strong>进程（process）</strong>和<strong>线程（thread）</strong>是操作系统的基本概念，但是它们比较抽象，不容易掌握。接下来有一个很好的类比，可以把它们解释地清晰易懂。</p>
</blockquote>
<a id="more"></a>
<p><strong>1、</strong></p>
<p><img src="https://pic3.zhimg.com/80/v2-27079449e58afd118e7664b04578f344_hd.png" alt="img"></p>
<p>计算机的核心是CPU，它承担了所有的计算任务。它就像一座工厂，时刻在运行。</p>
<p><strong>2、</strong></p>
<p><img src="https://pic4.zhimg.com/80/v2-ad028c112f0d18a0b17979c47fb6cb5c_hd.png" alt="img"></p>
<p>假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，<strong>单个CPU一次只能运行一个任务</strong>。</p>
<p><strong>3、</strong></p>
<p><img src="https://pic3.zhimg.com/80/v2-b46a4028e69a4db9b5db845d3762f2a9_hd.png" alt="img"></p>
<p>进程就好比工厂的车间，它代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程，其他进程处于非运行状态。</p>
<p><strong>4、</strong></p>
<p><img src="https://pic3.zhimg.com/80/v2-127be934737e47c25f5caa7629ebb0aa_hd.png" alt="img"></p>
<p>一个车间里，可以有很多工人，他们协同完成一个任务。</p>
<p><strong>5、</strong></p>
<p><img src="https://pic3.zhimg.com/80/v2-9d51b60a7bccb5ad86cdf7634d9817da_hd.png" alt="img"></p>
<p>线程就好比车间里的工人。<strong>一个进程可以包括多个线程</strong>。</p>
<p><strong>6、</strong></p>
<p><img src="https://pic2.zhimg.com/80/v2-ac91aec51f0cc56897a114facae2a2de_hd.png" alt="img"></p>
<p>车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征<strong>一个进程的内存空间是共享的，每个线程都可以使用这些共享内存</strong>。</p>
<p><strong>7、</strong></p>
<p><img src="https://pic2.zhimg.com/80/v2-e376f83761880cc244e801bb150ba72f_hd.png" alt="img"></p>
<p>可是，每间房间的大小不同，有些房间最多只能容纳一个人，比如厕所。里面有人的时候，其他人就不能进去了。这代表一个线程使用某些共享内存时。其他线程必须等它结束，才能使用这一块内存。</p>
<p><strong>8、</strong></p>
<p><img src="https://pic2.zhimg.com/80/v2-66b20a499d48d96194dfc8b5394ab5f0_hd.png" alt="img"></p>
<p>一个防止他人进入的简单方法，就是在门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫<strong>“互斥锁”（Mutual exclusion，缩写Mutex）</strong>，防止多个线程同时读写某一块内存区域。</p>
<p><strong>9、</strong></p>
<p><img src="https://pic2.zhimg.com/80/v2-afe37d379c07f39e6136bc9d7f69b6c3_hd.png" alt="img"></p>
<p>还有些房间，可以同时容纳N个人，比如厨房。也就是说，如果人数大于N，多出来的人只能在外面等着。这好比某些内存区域，只能供给给固定数目的线程使用。</p>
<p><strong>10、</strong></p>
<p><img src="https://pic4.zhimg.com/80/v2-6b371e1c71a5accc82e95013a86453d7_hd.png" alt="img"></p>
<p>这时的解决方法，就是在门口挂N把钥匙，进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做<strong>“信号量”（Semaphore）</strong>，用来保证多个线程不会互相冲突。</p>
<p>不难看出，<strong>mutex是semaphore的一种特殊情况（N=1时）</strong>。也就是说，完全可以用后者替代前者。但是，因为mutex较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。</p>
<p><strong>11、</strong></p>
<p><img src="https://pic2.zhimg.com/80/v2-f18600f73561954968b058e118fe3877_hd.png" alt="img"></p>
<p>操作系统的设计，因此可以归结为三点：</p>
<ol>
<li>以多进程形式，允许多个任务同时运行；</li>
<li>以多线程形式，允许单个任务分成不同的部分运行；</li>
<li>提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。</li>
</ol>
<p>（完）</p>
<p><strong>转载自阮一峰大佬的网络日志</strong></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>进程和线程</tag>
      </tags>
  </entry>
  <entry>
    <title>两个链表的第一个公共结点</title>
    <url>/2020/02/10/%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>输入两个链表，找出它们的第一个公共结点。如果有公共结点，则输出它们的第一个公共结点；如果没有公共结点，则输出null即可。</p>
</blockquote>
<a id="more"></a>
<h2 id="链表的定义"><a href="#链表的定义" class="headerlink" title="链表的定义"></a>链表的定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>有公共结点的情况：</strong></p>
<p><img src="https://pic1.zhimg.com/v2-be177b90f6a447df5df70ae5a8c1d8a4_b.png" alt="img"></p>
<p>这个时候就计算出pHead1链表的长度，pHead2链表的长度，然后让长的链表先走它们之间长度的差值，然后pHead1和pHead2同时走，必定同时遇到（此时就是公共结点）。</p>
<p><strong>无公共结点的情况：</strong></p>
<p><img src="https://pic3.zhimg.com/v2-a741ce3ff09c9febd3e30230222d5132_b.png" alt="img"></p>
<p>这个时候也是采取跟有公共结点一样的思路，让链表长的先走它们长度的差值步数，然后让他们同时走，这个时候同时走到null，返回null即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> nowcoder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/2/10  11:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindFirstCommonNode</span> </span>&#123;</span><br><span class="line">    <span class="comment">//链表的定义</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        ListNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">findFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead1 == <span class="keyword">null</span> || pHead2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> length2 = <span class="number">0</span>;</span><br><span class="line">        ListNode node1 = pHead1;</span><br><span class="line">        ListNode node2 = pHead2;</span><br><span class="line">        <span class="comment">//计算出链表pHead1和pHead2的长度</span></span><br><span class="line">        <span class="keyword">while</span> (node1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            length1++;</span><br><span class="line">            node1 = node1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (node2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            length2++;</span><br><span class="line">            node2 = node2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//让长的链表先走N步（N=Math.abs(length1-length2)）</span></span><br><span class="line">        <span class="keyword">if</span> (length1 &gt; length2) &#123;</span><br><span class="line">            <span class="keyword">int</span> go = length1 - length2;</span><br><span class="line">            <span class="keyword">while</span> (go &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                go--;</span><br><span class="line">                pHead1 = pHead1.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> go = length2 - length1;</span><br><span class="line">            <span class="keyword">while</span> (go &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                go--;</span><br><span class="line">                pHead2 = pHead2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//同时走，只要有公共结点就会遇到，没有公共结点就返回null</span></span><br><span class="line">        <span class="keyword">while</span> (pHead1 != pHead2) &#123;</span><br><span class="line">            pHead1 = pHead1.next;</span><br><span class="line">            pHead2 = pHead2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pHead1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过"><a href="#通过" class="headerlink" title="通过"></a>通过</h2><p><img src="https://pic1.zhimg.com/v2-e0e3f6d5761b3b1dae9549e3cffe1444_b.png" alt="img"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>这道题也是中规中矩，现在已经写完了两个链表的相交情况。以前也写过环形链表的入口结点。这两个东西结合起来也是一道非常经典的题目，等下次我来分享给大家。</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode&amp;牛客题解</category>
      </categories>
      <tags>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈单例模式的几种实现</title>
    <url>/2020/02/08/%E6%B5%85%E8%B0%88%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="单例模式（来自菜鸟教程）"><a href="#单例模式（来自菜鸟教程）" class="headerlink" title="单例模式（来自菜鸟教程）"></a>单例模式（来自菜鸟教程）</h2><blockquote>
<p>单例模式（Singleton  Pattern）是Java中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
</blockquote>
<a id="more"></a>
<h2 id="单例模式的要求"><a href="#单例模式的要求" class="headerlink" title="单例模式的要求"></a>单例模式的要求</h2><ul>
<li>构造方法必须私有化（确保只有自己能创建）</li>
<li>以静态方法返回实例（外界不能通过new来获取到对象）</li>
<li>确保对象实例只有一个（只对类进行一次实例化，以后都直接获取第一次实例化的对象）</li>
</ul>
<h2 id="单例模式的实现"><a href="#单例模式的实现" class="headerlink" title="单例模式的实现"></a>单例模式的实现</h2><p><strong>1、懒汉式（线程不安全）</strong></p>
<p>描述：这种方式是最基本的实现方式，但是不支持多线程。因为没有加锁，在多线程不能正常工作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//懒汉式（线程不安全）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2、懒汉式（线程安全）</strong></p>
<p>描述：能够在多线程下正常工作，但是，效率极低</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//懒汉式（线程安全）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3、双重校验锁（DCL，即double-checked locking）（线程安全）</strong></p>
<p>描述：对懒汉式（线程安全）的优化，采用双锁的机制，安全且在多线程情况下能保持高性能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双重校验锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4、饿汉式（线程安全）</strong></p>
<p>描述：这种方式比较常用，但容易产生垃圾对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//饿汉式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>5、静态内部类（线程安全）</strong></p>
<p>描述：这种方式达到跟<strong>双重校验锁</strong>一样的效果，这种方式只适用于静态域的情况，双重校验锁可在实例域需要延迟初始化时使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态内部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>6、枚举（线程安全）</strong></p>
<p>描述：这种方式还没有被广泛采用，但是这种实现是单例模式的最佳方法。更简洁、自动支持序列化机制、绝对防止多次实例化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//枚举</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whateverMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>一般情况下，不建议使用第1种和第2种<strong>懒汉</strong>方式，建议使用第4种<strong>饿汉</strong>方式。只有在明确实现lazy loading时，才会使用第5种<strong>静态内部类</strong>方式。如果涉及到反序列化创建对象时，可以使用第6种<strong>枚举</strong>方式。如果有其他需求，可以考虑使用第3种<strong>双重校验锁</strong>方式。</p>
</blockquote>
<p><strong>PS：开始面临着春招，好多面经都有说到设计模式。最常见的面试题就是讲一讲单例模式的实现和理解，所以我写一下，加深我对单例模式的理解和印象。觉得对你有帮助的话可以点点赞，谢谢啦~~~</strong></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title>删除链表中重复的结点</title>
    <url>/2020/02/06/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。例如：1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5处理后为1-&gt;2-&gt;5</p>
</blockquote>
<a id="more"></a>
<h2 id="链表的定义"><a href="#链表的定义" class="headerlink" title="链表的定义"></a>链表的定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//链表的定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>PS：本文主要的解法以非递归解法为主，一切可以以递归解的题目都可以变成非递归解法。</strong></p>
<h2 id="递归代码（加注释）"><a href="#递归代码（加注释）" class="headerlink" title="递归代码（加注释）"></a>递归代码（加注释）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> nowcoder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/2/6  11:33</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeleteDuplication</span> </span>&#123;</span><br><span class="line">    <span class="comment">//链表定义</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        ListNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归解法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (pHead.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> pHead;</span><br><span class="line">        ListNode cur;</span><br><span class="line">        <span class="comment">//对重复结点的处理</span></span><br><span class="line">        <span class="keyword">if</span> (pHead.val == pHead.next.val) &#123;</span><br><span class="line">            cur = pHead.next.next;</span><br><span class="line">            <span class="comment">//遍历到没有重复结点的位置</span></span><br><span class="line">            <span class="keyword">while</span> (cur != <span class="keyword">null</span> &amp;&amp; cur.val == pHead.val) &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> deleteDuplication(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有重复结点</span></span><br><span class="line">        cur = pHead.next;</span><br><span class="line">        pHead.next = deleteDuplication(cur);</span><br><span class="line">        <span class="keyword">return</span> pHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过截图"><a href="#通过截图" class="headerlink" title="通过截图"></a>通过截图</h2><p><img src="https://pic2.zhimg.com/v2-c07487589b965bd412665d3de446a161_b.png" alt="img"></p>
<p><strong>PS：递归解法的题目都是需要你自己弄懂他的过程，就好比我当初学习递归的第一个例子就是汉诺塔，我也很懵逼，这究竟是什么东西！！！然后花了一个晚上在图书馆一直看课本上的例子和代码，然后就会恍然大悟，原来递归就是这样的。所以递归的思路我水平有限，不知道怎么解释，希望你们自己好好弄懂。</strong></p>
<hr>
<h2 id="非递归思路"><a href="#非递归思路" class="headerlink" title="非递归思路"></a>非递归思路</h2><ul>
<li>首先new一个头节点初始化为0，防止第一个结点和第二个结点相同的情况</li>
<li>设置pre和last指针，pre指针指向当前确定不重复的结点，last指针就一直向后搜索</li>
</ul>
<h2 id="代码（加注释）"><a href="#代码（加注释）" class="headerlink" title="代码（加注释）"></a>代码（加注释）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> nowcoder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/2/6  11:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeleteDuplication</span> </span>&#123;</span><br><span class="line">    <span class="comment">//链表定义</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        ListNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非递归解法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="keyword">null</span> || pHead.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> pHead;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化一个0为头结点，防止pHead的第一个结点和第二个结点相同的情况</span></span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        head.next = pHead;</span><br><span class="line">        <span class="comment">//pre指向确定不重复的结点</span></span><br><span class="line">        ListNode pre = head;</span><br><span class="line">        ListNode last = head.next;</span><br><span class="line">        <span class="keyword">while</span> (last != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果last和后面的指针相同</span></span><br><span class="line">            <span class="keyword">if</span> (last.next != <span class="keyword">null</span> &amp;&amp; last.val == last.next.val) &#123;</span><br><span class="line">                <span class="comment">//找到last往后不重复的结点的位置</span></span><br><span class="line">                <span class="keyword">while</span> (last.next != <span class="keyword">null</span> &amp;&amp; last.val == last.next.val) &#123;</span><br><span class="line">                    last = last.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//相当于删除重复的结点</span></span><br><span class="line">                pre.next = last.next;</span><br><span class="line">                last = last.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果不重复，pre和last分别往后移动</span></span><br><span class="line">                pre = pre.next;</span><br><span class="line">                last = last.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过截图-1"><a href="#通过截图-1" class="headerlink" title="通过截图"></a>通过截图</h2><p><img src="https://pic4.zhimg.com/80/v2-26f436cace283cebaa85ff50914e84df_hd.jpg" alt="img"></p>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(N)。遍历一遍就可以删除重复结点</li>
<li>空间复杂度：O(1)。因为整个过程利用有限的几个变量pre和last，所以空间复杂度为O(1)</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode&amp;牛客题解</category>
      </categories>
      <tags>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title>和为S的连续正数序列</title>
    <url>/2020/02/04/%E5%92%8C%E4%B8%BAS%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>小明很喜欢数学，有一天他在做数学作业时，要求计算出9~16的和，他马上就写出了正确答案是100。但是他并不满足于此，他在想究竟有多少种连续的正数序列的和为100（至少包括两个数）。没多久，他就得到另一组连续正数和为100的序列：18，19，20，21，22。现在把问题交给你，你能不能也很快的找到所有和为S的连续正数序列？Good Luck！</p>
</blockquote>
<a id="more"></a>
<h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h2><blockquote>
<p>输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序</p>
</blockquote>
<h2 id="暴力思路"><a href="#暴力思路" class="headerlink" title="暴力思路"></a>暴力思路</h2><p>就是正常的暴力解法，穷举所有可能相加等于S，本文章不讲这个解法。</p>
<h2 id="双指针思路"><a href="#双指针思路" class="headerlink" title="双指针思路"></a>双指针思路</h2><p>设置两个指针left和right，然后根据等差数列的求和公式（a0+an）* n / 2求出对应的和与S比较，等于的话直接返回；小于S的话就right++；大于S的话就left++。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> nowcoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/2/4  11:35</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindContinuousSequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; findContinuousSequence(<span class="keyword">int</span> sum) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//设置两个指针left和right</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">//因为都是连续的，差值为1的等差数列。</span></span><br><span class="line">            <span class="comment">//求和公式为(a0+an)*n/2</span></span><br><span class="line">            <span class="keyword">int</span> curSum = (left + right) * (right - left + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//判断curSum和sum的大小关系调整对应的left和right</span></span><br><span class="line">            <span class="keyword">if</span> (curSum == sum) &#123;</span><br><span class="line">                ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">                    list.add(i);</span><br><span class="line">                &#125;</span><br><span class="line">                res.add(list);</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curSum &lt; sum) &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过截图"><a href="#通过截图" class="headerlink" title="通过截图"></a>通过截图</h2><p><img src="https://pic4.zhimg.com/80/v2-a97efb8af8961a1eae45f96044881e87_hd.jpg" alt="img"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>其实这道题我半年前就做过了，然后当时根本对算法没多少认识，基本都是一个思路“暴力破万法”，“一切皆可暴”。所以慢慢接触到一些面经，基本就是算法题你只要是暴力解的基本都是不通过，这就给我提了个醒，不能一直依靠暴力，暴力就当作入门，后面要多学习算法达到一道题有多种解法思路。</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode&amp;牛客题解</category>
      </categories>
      <tags>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title>寻找两个有序数组的中位数</title>
    <url>/2020/02/01/%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>最近在家闲着无聊看爱情公寓5，看上瘾了发现两天没刷题了，不好，所以去leetcode看了一下，找到一道比较有意思的题目（<strong>寻找两个有序数组的中位数</strong>），尝试做了一下，暴力解法还是挺简单的，二分法也比较有意思。所以来试着讲解一下（哈哈哈）</p>
</blockquote>
<a id="more"></a>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="https://pic1.zhimg.com/80/v2-8acb38186be01f55f0b494f34e80a3e8_hd.jpg" alt="img"></p>
<h2 id="暴力思路"><a href="#暴力思路" class="headerlink" title="暴力思路"></a>暴力思路</h2><p>先申请一个长度为nums1.length+nums2.length的辅助数组，然后利用<strong>归并排序</strong>的合并算法将两个数组合并成一个数组，并且是有序的数组。若长度为奇数，则中位数就是<strong>数组长度/2</strong>；若长度为偶数，则中位数就是<strong>数组长度/2和数组长度/2 - 1之和除以2。</strong></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/2/2  10:19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindMedianSortedArrays</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length1 = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> length2 = nums2.length;</span><br><span class="line">        <span class="comment">//申请一个长度为length1+length2的辅助数组res</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[length1 + length2];</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> p2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//利用归并排序的merge操作进行两个数组合并，并且合并后的数组有序</span></span><br><span class="line">        <span class="keyword">while</span> (p1 &lt; nums1.length &amp;&amp; p2 &lt; nums2.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[p1] &lt; nums2[p2]) &#123;</span><br><span class="line">                res[p++] = nums1[p1++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res[p++] = nums2[p2++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt; nums1.length) &#123;</span><br><span class="line">            res[p++] = nums1[p1++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p2 &lt; nums2.length) &#123;</span><br><span class="line">            res[p++] = nums2[p2++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((res.length &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//合并后的数组长度为奇数</span></span><br><span class="line">            <span class="keyword">return</span> res[(res.length) / <span class="number">2</span>] / <span class="number">1.0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//为偶数</span></span><br><span class="line">            <span class="keyword">return</span> (res[(res.length) / <span class="number">2</span> - <span class="number">1</span>] + res[(res.length) / <span class="number">2</span>]) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过截图"><a href="#通过截图" class="headerlink" title="通过截图"></a>通过截图</h2><p><img src="https://pic4.zhimg.com/80/v2-ec8761b9932e712f78fede788af6222f_hd.jpg" alt="img"></p>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(M+N)，M是第一个数组的长度，N是第二个数组的长度</li>
<li>空间复杂度：O(M+N)，因为申请了一个辅助数组长度为M+N</li>
</ul>
<hr>
<h2 id="二分解法代码（加注释）"><a href="#二分解法代码（加注释）" class="headerlink" title="二分解法代码（加注释）"></a>二分解法代码（加注释）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/2/2  10:59</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindMedianSortedArrays</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 1.首先，让我们在任一位置 i 将 A(长度为m) 划分成两个部分：</span></span><br><span class="line"><span class="comment">         *            leftA            |                rightA</span></span><br><span class="line"><span class="comment">         *   A[0],A[1],...      A[i-1] |  A[i],A[i+1],...A[m - 1]</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 由于A有m个元素，所以有m + 1中划分方式(i = 0 ~ m)</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 我们知道len(leftA) = i, len(rightA) = m - i;</span></span><br><span class="line"><span class="comment">         * 注意：当i = 0时，leftA是空集，而当i = m时，rightA为空集。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 2.采用同样的方式，将B也划分为两部分：</span></span><br><span class="line"><span class="comment">         *            leftB            |                rightB</span></span><br><span class="line"><span class="comment">         *   B[0],B[1],...      B[j-1] |   B[j],B[j+1],...B[n - 1]</span></span><br><span class="line"><span class="comment">         *  我们知道len(leftA) = j, len(rightA) = n - j;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *  将leftA和leftB放入一个集合，将rightA和rightB放入一个集合。再把这两个集合分别命名为leftPart和rightPart。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *            leftPart         |                rightPart</span></span><br><span class="line"><span class="comment">         *   A[0],A[1],...      A[i-1] |  A[i],A[i+1],...A[m - 1]</span></span><br><span class="line"><span class="comment">         *   B[0],B[1],...      B[j-1] |  B[j],B[j+1],...B[n - 1]</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *   如果我们可以确认：</span></span><br><span class="line"><span class="comment">         *   1.len(leftPart) = len(rightPart); =====&gt; 该条件在m+n为奇数时，该推理不成立</span></span><br><span class="line"><span class="comment">         *   2.max(leftPart) &lt;= min(rightPart);</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *   median = (max(leftPart) + min(rightPart)) / 2;  目标结果</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *   要确保这两个条件满足：</span></span><br><span class="line"><span class="comment">         *   1.i + j = m - i + n - j(或m - i + n - j + 1)  如果n &gt;= m。只需要使i = 0 ~ m，j = (m+n+1)/2-i =====&gt; 该条件在m+n为奇数/偶数时，该推理都成立</span></span><br><span class="line"><span class="comment">         *   2.B[j] &gt;= A[i-1] 并且 A[i] &gt;= B[j-1]</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *   注意:</span></span><br><span class="line"><span class="comment">         *   1.临界条件：i=0,j=0,i=m,j=n。需要考虑</span></span><br><span class="line"><span class="comment">         *   2.为什么n &gt;= m ? 由于0 &lt;= i &lt;= m且j = (m+n+1)/2-i,必须确保j不能为负数。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *   按照以下步骤进行二叉树搜索</span></span><br><span class="line"><span class="comment">         *   1.设imin = 0,imax = m，然后开始在[imin,imax]中进行搜索</span></span><br><span class="line"><span class="comment">         *   2.令i = (imin+imax) / 2, j = (m+n+1)/2-i</span></span><br><span class="line"><span class="comment">         *   3.现在我们有len(leftPart) = len(rightPart)。而我们只会遇到三种情况：</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *      ①.B[j] &gt;= A[i-1] 并且 A[i] &gt;= B[j-1]  满足条件</span></span><br><span class="line"><span class="comment">         *      ②.B[j-1] &gt; A[i]。此时应该把i增大。 即imin = i + 1;</span></span><br><span class="line"><span class="comment">         *      ③.A[i-1] &gt; B[j]。此时应该把i减小。 即imax = i - 1;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="keyword">int</span> m = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> n = nums2.length;</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n) &#123; <span class="comment">// to ensure m&lt;=n</span></span><br><span class="line">            <span class="keyword">int</span>[] temp = nums1;</span><br><span class="line">            nums1 = nums2;</span><br><span class="line">            nums2 = temp;</span><br><span class="line">            <span class="keyword">int</span> tmp = m;</span><br><span class="line">            m = n;</span><br><span class="line">            n = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> iMin = <span class="number">0</span>, iMax = m, halfLen = (m + n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (iMin &lt;= iMax) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = (iMin + iMax) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> j = halfLen - i;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; iMax &amp;&amp; nums2[j - <span class="number">1</span>] &gt; nums1[i]) &#123;</span><br><span class="line">                iMin = i + <span class="number">1</span>; <span class="comment">// i is too small</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; iMin &amp;&amp; nums1[i - <span class="number">1</span>] &gt; nums2[j]) &#123;</span><br><span class="line">                iMax = i - <span class="number">1</span>; <span class="comment">// i is too big</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// i is perfect</span></span><br><span class="line">                <span class="keyword">int</span> maxLeft;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;<span class="comment">//A分成的leftA(空集) 和 rightA(A的全部)  所以leftPart = leftA(空集) + leftB,故maxLeft = B[j-1]。</span></span><br><span class="line">                    maxLeft = nums2[j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) &#123; <span class="comment">//B分成的leftB(空集) 和 rightB(B的全部)  所以leftPart = leftA + leftB(空集),故maxLeft = A[i-1]。</span></span><br><span class="line">                    maxLeft = nums1[i - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">//排除上述两种特殊情况，正常比较</span></span><br><span class="line">                    maxLeft = Math.max(nums1[i - <span class="number">1</span>], nums2[j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ((m + n) % <span class="number">2</span> == <span class="number">1</span>) &#123; <span class="comment">//奇数，中位数正好是maxLeft</span></span><br><span class="line">                    <span class="keyword">return</span> maxLeft;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//偶数</span></span><br><span class="line">                <span class="keyword">int</span> minRight;</span><br><span class="line">                <span class="keyword">if</span> (i == m) &#123;<span class="comment">//A分成的leftA(A的全部) 和 rightA(空集)  所以rightPart = rightA(空集) + rightB,故minRight = B[j]。</span></span><br><span class="line">                    minRight = nums2[j];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == n) &#123;<span class="comment">//B分成的leftB(B的全部) 和 rightB(空集)  所以rightPart = rightA + rightB(空集),故minRight = A[i]。</span></span><br><span class="line">                    minRight = nums1[i];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//排除上述两种特殊情况，正常比较</span></span><br><span class="line">                    minRight = Math.min(nums2[j], nums1[i]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> (maxLeft + minRight) / <span class="number">2.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过截图-1"><a href="#通过截图-1" class="headerlink" title="通过截图"></a>通过截图</h2><p><img src="https://pic2.zhimg.com/80/v2-06696895ca0a55632e8edf8cb526c161_hd.jpg" alt="img"></p>
<h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(log(M,N))</li>
<li>空间复杂度：O(1)</li>
</ul>
<p><strong>PS：该解法参考leetcode上的官方解法加上一些注释。</strong></p>
]]></content>
      <categories>
        <category>LeetCode&amp;牛客题解</category>
      </categories>
      <tags>
        <tag>困难</tag>
      </tags>
  </entry>
  <entry>
    <title>最长有效括号</title>
    <url>/2020/01/30/%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>最近被新型冠状病毒搞得人心惶惶，大家都不太敢出门，我也不敢出门（哈哈哈），索性就在家里刷了一道leetcode的简单题——有效的括号（leetcode20题），说简单也不简单，说难也不难，刷完之后觉得意犹未尽。然后再刷了一道leetcode的困难题——最长有效括号（leetcode32题）。今天就来讲一下这两道相似题目的题解。</p>
</blockquote>
<a id="more"></a>
<h2 id="第一题（leetcode20-有效的括号）"><a href="#第一题（leetcode20-有效的括号）" class="headerlink" title="第一题（leetcode20_有效的括号）"></a>第一题（leetcode20_有效的括号）</h2><p><img src="https://pic1.zhimg.com/80/v2-3009c2ec8800e2dce79bb44decad3e8c_hd.jpg" alt="img"></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote>
<p>先列出括号的类型把他存在HashMap中，然后利用栈先进后出的特性来解决。<strong>如果是左括号就直接进栈，如果是右括号就出栈，然后判断出栈的左括号是否对应着对应的右括号即可。</strong></p>
</blockquote>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/1/30  11:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackIsValid</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//把括号的类型存进HashMap中</span></span><br><span class="line">        HashMap&lt;Character,Character&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">')'</span>,<span class="string">'('</span>);</span><br><span class="line">        map.put(<span class="string">'&#125;'</span>,<span class="string">'&#123;'</span>);</span><br><span class="line">        map.put(<span class="string">']'</span>,<span class="string">'['</span>);</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="comment">//如果是左括号，直接进栈</span></span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(s.charAt(i))) &#123;</span><br><span class="line">                stack.push(s.charAt(i));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果是右括号，出栈然后判断出栈左括号对应HashMap的左括号是否一致</span></span><br><span class="line">                <span class="keyword">char</span> top = stack.isEmpty() ? <span class="string">'#'</span> : stack.pop();</span><br><span class="line">                <span class="keyword">if</span> (top != map.get(s.charAt(i))) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(N)。因为整个过程遍历一遍就可以处理完</li>
<li>空间复杂度：O(N)。借助了大小为N的栈来辅助完成</li>
</ul>
<hr>
<h2 id="第二题（leetcode32-最长有效括号）"><a href="#第二题（leetcode32-最长有效括号）" class="headerlink" title="第二题（leetcode32_最长有效括号）"></a>第二题（leetcode32_最长有效括号）</h2><p><img src="https://pic1.zhimg.com/v2-3db2f1101e338975b5dab286d6e443a4_b.png" alt="img"></p>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><blockquote>
<p>对于每个’(‘，我们将它的下标进栈。对于每个’)’，我们弹出栈顶的元素并将当前元素的下标于当前栈顶下标作差，得出当前有效括号的长度。</p>
</blockquote>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/1/30  11:59</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongestValidParentheses</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="comment">//如果匹配到左括号就直接进栈</span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">'('</span>) &#123;</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 右括号出栈，并且判断栈是否为空，</span></span><br><span class="line">                <span class="comment">// 如果为空，把当前下标进栈，</span></span><br><span class="line">                <span class="comment">// 如果不为空，计算出当前有效的长度，记录下来</span></span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">                    stack.push(i);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    max = Math.max(max, i - stack.peek());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(N)。因为遍历一次就能得出最长的有效括号</li>
<li>空间复杂度：O(N)。因为借助了大小为N的辅助栈处理</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode&amp;牛客题解</category>
      </categories>
      <tags>
        <tag>困难</tag>
      </tags>
  </entry>
  <entry>
    <title>数组中只出现一次的数字</title>
    <url>/2020/01/29/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p>
</blockquote>
<a id="more"></a>
<h2 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h2><p>利用HashMap来做这道题，时间复杂度为O(N)，空间复杂度为O(N)</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> nowcoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/1/28  16:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</span></span><br><span class="line"><span class="comment">//num1,num2分别为长度为1的数组。传出参数</span></span><br><span class="line"><span class="comment">//将num1[0],num2[0]设置为返回结果</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindNumsAppearOnce</span> </span>&#123;</span><br><span class="line">    <span class="comment">//HashMap解法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findNumsAppearOnce</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> num1[], <span class="keyword">int</span> num2[])</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(array[i])) &#123;</span><br><span class="line">                map.put(array[i], <span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(array[i], <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//标识这两个数的顺序</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.get(array[i]) == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                    num1[<span class="number">0</span>] = array[i];</span><br><span class="line">                    count++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    num2[<span class="number">0</span>] = array[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="解法2（重点）"><a href="#解法2（重点）" class="headerlink" title="解法2（重点）"></a>解法2（重点）</h2><p>利用位运算中的异或运算来解这道题。异或的性质就是两个相同的数字异或为0，一个数和0异或还是它本身。要是对位运算不熟悉的话可以先看这一篇文章：</p>
<p><a href="https://zhuanlan.zhihu.com/p/102277869" target="_blank" rel="noopener">god-jiang：神级运算——位运算</a></p>
<p>用位运算可以达到时间复杂度为O(N)，空间复杂度为O(1)</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>如果一个数组只有A和B是出现一次的数，我们把所有的数都异或了之后的结果就是A和B异或的结果。因为相同的数异或都等于0。异或的结果的二进制中至少会出现一个1，因为A和B不同，异或至少会出现一个1，我们取第一个1的位置，假设这个位置是第3位，我们把第3位为0的分成一组，把第3位为1的分成一组，各自异或，最后的结果就是出现一次的数。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> nowcoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/1/28  17:32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</span></span><br><span class="line"><span class="comment">//num1,num2分别为长度为1的数组。传出参数</span></span><br><span class="line"><span class="comment">//将num1[0],num2[0]设置为返回结果</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindNumsAppearOnce</span> </span>&#123;</span><br><span class="line">    <span class="comment">//异或解法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findNumsAppearOnce1</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> num1[], <span class="keyword">int</span> num2[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//异或的结果就是A和B的异或结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            temp = temp ^ array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//找到异或结果第一位为1的位置为index</span></span><br><span class="line">        <span class="keyword">while</span> ((index &amp; temp) == <span class="number">0</span>) &#123;</span><br><span class="line">            index = index &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> result2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((index &amp; array[i]) == <span class="number">0</span>) &#123;</span><br><span class="line">                result1 = result1 ^ array[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result2 = result2 ^ array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        num1[<span class="number">0</span>] = result1;</span><br><span class="line">        num2[<span class="number">0</span>] = result2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="https://pic2.zhimg.com/80/v2-615ae0b9de94c99c18081411de09086d_hd.jpg" alt="img"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>这道题目在牛客网上还是比较经典的一道题目，可以看出你对HashMap熟不熟悉，也可以看出你对位运算的理解程度。</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode&amp;牛客题解</category>
      </categories>
      <tags>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title>过年之抢红包算法</title>
    <url>/2020/01/26/%E8%BF%87%E5%B9%B4%E4%B9%8B%E6%8A%A2%E7%BA%A2%E5%8C%85%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>昨天是大年初一，怎么说呢，因为在读大学， 没有出来工作，所以昨晚也是陆陆续续有收到一些红包。然后想起自己对算法感兴趣，以前也看过一些公众号有讲过<strong>抢红包算法，</strong>今天就更新一遍关于<strong>抢红包的算法</strong>，对学过数据结构或者对抢红包感兴趣的可以看一看。本文就讲两个抢红包算法。</p>
</blockquote>
<a id="more"></a>
<p><strong>PS：关于抢红包算法我是参看公众号“程序员小灰”。这个公众号是引领我学数据结构的公众号，通过漫画的形式讲得很通俗易懂。</strong></p>
<hr>
<h2 id="抢红包算法的要求"><a href="#抢红包算法的要求" class="headerlink" title="抢红包算法的要求"></a><strong>抢红包算法的要求</strong></h2><p>假设有10元钱，10个人分：</p>
<ul>
<li><strong>每个人至少分到0.01元，不可以分到0元</strong></li>
<li><strong>每个人分到的金额加起来要等于10元，不可以多于10元，也不可以少于10元</strong></li>
<li><strong>每个人分的金额要尽可能随机，不能差距太大</strong></li>
</ul>
<h2 id="抢红包一"><a href="#抢红包一" class="headerlink" title="抢红包一"></a><strong>抢红包一</strong></h2><blockquote>
<p>当初大二学习数据结构的时候老师就有布置一道作业题说叫我们回去写一个类似于微信的抢红包算法，然后下个星期看哪位同学写得好。所以第一个抢红包算法应该大家很容易理解。</p>
</blockquote>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>每个人每次抢到的金额范围是：（0，剩余金额）。</strong></p>
<p>不过这个算法思路会违背“<strong>每个人分的金额随机，不能差距太大</strong>”。</p>
<p>为什么会这样，举个例子：</p>
<p>假设有10元钱，10个人分。</p>
<p>第一个人的随机范围是（0，10），平均分到5元。</p>
<p>假设第一个人随机分到5元，剩余金额为10-5=5元。</p>
<p>第二个人的随机范围是（0，5），平均分到2.5元。</p>
<p>假设第二个人随机分到2.5元，剩余金额为5-2.5=2.5元。</p>
<p>第三个人的随机范围是（0，2.5），平均分到1.25元</p>
<p>以此类推，每一次随机范围越来越小，违背了“<strong>每个人分的金额随机，不能差距太大</strong>”。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> zhihu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/1/26  16:49</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Algorithm</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">divideRedPackage</span><span class="params">(Integer totalAmount, Integer totalPeopleNum)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; amountList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Integer restAmount = totalAmount;</span><br><span class="line">        Integer restPeopleNum = totalPeopleNum;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalPeopleNum - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> amount = random.nextInt(restAmount - restPeopleNum - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            restAmount -= amount;</span><br><span class="line">            restPeopleNum--;</span><br><span class="line">            amountList.add(amount);</span><br><span class="line">        &#125;</span><br><span class="line">        amountList.add(restAmount);</span><br><span class="line">        <span class="keyword">return</span> amountList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; amountList = divideRedPackage(<span class="number">1000</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (Integer amount : amountList</span><br><span class="line">        ) &#123;</span><br><span class="line">            System.out.println(<span class="string">"抢到金额"</span> + <span class="keyword">new</span> BigDecimal(amount).divide(<span class="keyword">new</span> BigDecimal(<span class="number">100</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="https://pic2.zhimg.com/80/v2-15d72ce41de42df15c8f392da0c7921d_hd.jpg" alt="img"></p>
<hr>
<h2 id="抢红包二"><a href="#抢红包二" class="headerlink" title="抢红包二"></a>抢红包二</h2><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p><strong>每次抢到的金额=随机范围（0，M/N *2）</strong></p>
<p><strong>M表示剩余红包金额，N表示剩余人数。这个公式保证了每次随机金额的平均值是相等的。</strong></p>
<p>举个例子：</p>
<p>假设有10元钱，10个人分：</p>
<p>10/10 *2=2，所以第一个人分到的范围是（0，2），平均可以分到1元。</p>
<p>假设第一个人随机分到1元，那么剩余金额是10-1=9元。</p>
<p>9/9 *2=2，所以第二个人分到的范围是（0，2），平均可以分到1元。</p>
<p>假设第二个人随机分到1元，那么剩余金额是9-1=8元。</p>
<p>8/8 *2=2，所以第三个人的随机范围也是（0，2），平均可以分到1元。</p>
<p>以此类推，每一次随机范围都是相等的。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> zhihu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/1/26  15:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Algorithm</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">divideRedPackage</span><span class="params">(Integer totalAmount, Integer totalPeopleNum)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; amountList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Integer restAmount = totalAmount;</span><br><span class="line">        Integer restPeopleNum = totalPeopleNum;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalPeopleNum - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//保证金额范围是[1，剩余金额2倍），左闭右开</span></span><br><span class="line">            <span class="keyword">int</span> amount = random.nextInt(restAmount / restPeopleNum * <span class="number">2</span> - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            restAmount -= amount;</span><br><span class="line">            restPeopleNum--;</span><br><span class="line">            amountList.add(amount);</span><br><span class="line">        &#125;</span><br><span class="line">        amountList.add(restAmount);</span><br><span class="line">        <span class="keyword">return</span> amountList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; amountList = divideRedPackage(<span class="number">1000</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (Integer amount : amountList</span><br><span class="line">        ) &#123;</span><br><span class="line">            System.out.println(<span class="string">"抢到金额"</span> + <span class="keyword">new</span> BigDecimal(amount).divide(<span class="keyword">new</span> BigDecimal(<span class="number">100</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h2><p><img src="https://pic1.zhimg.com/80/v2-865c5937786868dcd6f08730a594c898_hd.jpg" alt="img"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>抢红包算法就只写了两个，第一个就是以前大二学习数据结构的时候老师布置作业，我的想法就是大概这样，分的不均。第二个算法就是看公众号“程序员小灰”学习到的，很厉害，挺佩服这些大佬的，哈哈。</p>
</blockquote>
<p><strong>PS：本文提供的代码红包金额都是以分为单位，因为抢红包最低都是0.01元。</strong></p>
]]></content>
      <categories>
        <category>算法积累ing</category>
      </categories>
      <tags>
        <tag>抢红包</tag>
      </tags>
  </entry>
  <entry>
    <title>2019.3.1IntelliJ IDEA永久破解</title>
    <url>/2020/01/25/2019-3-1IntelliJ-IDEA%E6%B0%B8%E4%B9%85%E7%A0%B4%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote>
<p>大二刚接触到Java这门课程的时候，都是在eclipse上使用。当时老师讲了IDE的作用什么的，然而当时的我根本就没有听，导致我大三花更多的时间自己自学Java和JavaWeb还有框架等等。然后就是大三自学的时候用的是Myeclipse破解版的，发现这个编译器真的卡，也可能是因为我的笔记本性能一般，所以一直在用eclipse。最后是在大三的期末实训接触到的IDEA编译器，对于我来说打开了另一个门，然后我一直用的是IDEA的破解码，一般都是一年的期限，现在好像是破解码很多都用不了，所以找了IDEA的永久破解方法。</p>
</blockquote>
<a id="more"></a>
<h2 id="破解步骤"><a href="#破解步骤" class="headerlink" title="破解步骤"></a>破解步骤</h2><p><strong>1、先把本机的IDEA升级到2019.3的版本，因为我以前是用2018年的，现在用2019年的版本，其实都是差不多的，但是你用2019.3以前的版本我不敢保证能成功破解。我的方法是用jar包+破解码来达到一个永久破解的效果。</strong></p>
<p><strong>我自己用的IDEA版本介绍：</strong></p>
<p><img src="https://pic1.zhimg.com/80/v2-a40d2b362951818fd455a873a80183d0_hd.jpg" alt="img"></p>
<p><strong>2、打开IDEA先免费使用30天，它会让你注册账号你可以直接跳过，免费使用30天</strong></p>
<p><img src="https://pic2.zhimg.com/80/v2-d24804ee0ff26a74632183aec4de8be1_hd.jpg" alt="img"></p>
<p><strong>3、进入到IDEA里面，点击菜单栏【Help】 -&gt; 【Edit Custom VM Options】。注意不要在安装目录改idea64.exe.vmoptions文件，因为IDEA针对反破解已经越来越严格了。在最后添加一行代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//对应你自己的jar包路径，注意路径不要出现中文</span><br><span class="line">-javaagent:C:\Program Files\JetBrains\IntelliJ IDEA 2019.2.3\bin\jetbrains-agent.jar</span><br></pre></td></tr></table></figure>
<p><img src="https://pic4.zhimg.com/80/v2-cd6162669466f4d123dc134fbc167e43_hd.jpg" alt="img"></p>
<p><strong>注意：添加javaagent路径不要包含中文，不然可能破解失败！！！</strong></p>
<p><strong>4、重启IDEA，然后点击菜单栏【Help】 -&gt; 【Register】。然后在Activation code加入破解码。</strong></p>
<p><img src="https://pic3.zhimg.com/80/v2-28b0072e006ec54d67cf4b98afe535c6_hd.jpg" alt="img"></p>
<p><strong>然后破解完它就显示有效期到2089年了。</strong></p>
<p><strong>jar包+破解码的分享在这里：</strong></p>
<p>链接:<a href="https://link.zhihu.com/?target=https%3A//pan.baidu.com/s/1nkV8x4WF72ZvOSFiDyipdg" target="_blank" rel="noopener">https://pan.baidu.com/s/1nkV8x4WF72ZvOSFiDyipdg</a></p>
<p>提取码:amaq </p>
<p><img src="https://pic1.zhimg.com/80/v2-60b3c2f0f8f4b791fb74e6639a0ac374_hd.jpg" alt="img"></p>
<p><strong>祝你们大家都能破解成功~~~</strong></p>
]]></content>
      <categories>
        <category>软件破解</category>
      </categories>
      <tags>
        <tag>IDEA破解</tag>
      </tags>
  </entry>
  <entry>
    <title>N数之和求解</title>
    <url>/2020/01/24/N%E6%95%B0%E4%B9%8B%E5%92%8C%E6%B1%82%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote>
<p>刷leetcode上的题发现有一些题型相似的题目可以单独拿出来一起练习，因为相似，所以可以用同一种解法优化一下就可以做，以达到巩固的效果，本文就把介绍<strong>两数之和（简单）</strong>和<strong>三数之和（中等）</strong>的解法，类似的四数之和等等都是类似的。</p>
</blockquote>
<a id="more"></a>
<h2 id="题目1描述（两数之和）"><a href="#题目1描述（两数之和）" class="headerlink" title="题目1描述（两数之和）"></a>题目1描述（两数之和）</h2><p><img src="/images/N数之和/1.jpg" alt="img"></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote>
<p>利用<strong>哈希表</strong>来解题，利用“空间换时间”。把<strong>nums[i]的值作为哈希表的key</strong>，把 <strong>i 作为哈希表的value</strong>。然后<strong>判断target-nums[i]是否在哈希表中出现过</strong>就可以找到了。</p>
</blockquote>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/1/24  18:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoSum</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> res = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (map.size() &gt; <span class="number">0</span> &amp;&amp; map.containsKey(res)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(res), i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="leetcode通过截图"><a href="#leetcode通过截图" class="headerlink" title="leetcode通过截图"></a>leetcode通过截图</h2><p><img src="/images/N数之和/2.jpg" alt="img"></p>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><blockquote>
<p>因为遍历一次就得到结果，所以时间复杂度为O(N)。然后就是因为利用哈希表开辟了跟数组一样长度的空间N，所以空间复杂度为O(N)。</p>
</blockquote>
<hr>
<h2 id="题目2描述（三数之和）"><a href="#题目2描述（三数之和）" class="headerlink" title="题目2描述（三数之和）"></a>题目2描述（三数之和）</h2><p><img src="/images/N数之和/3.jpg" alt="img"></p>
<h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote>
<p>先固定第一个数，然后就变成了两数之和，解法和上面一样。然后这道题可以用双指针解，先将数组排序完，然后遍历的时候先固定一个数，剩下就是左指针和右指针相互移动来解出这道题。细节直接上代码好了</p>
</blockquote>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/1/24  19:32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreeSum</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//去重操作</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span> (sum == <span class="number">0</span>) &#123;</span><br><span class="line">                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));</span><br><span class="line">                    <span class="comment">//去重操作</span></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//去重操作</span></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="leetcode通过截图-1"><a href="#leetcode通过截图-1" class="headerlink" title="leetcode通过截图"></a>leetcode通过截图</h2><p><img src="/images/N数之和/4.jpg" alt="img"></p>
<h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><blockquote>
<p>因为一开始数组的排序过程的时间复杂度为O(N*logN)，然后就是固定一个值，通过移动左右指针来获得结果，时间复杂度为O(N^2)，空间复杂度因为没有引入额外的空间变量，所以空间复杂度为O(1)</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>通过<strong>两数之和</strong> 和 <strong>三数之和</strong>两道题，对于四数之和或者五数之和又有什么不一样呢，大不了固定一个值变成三数之和，只要掌握了核心，再怎么变化我觉得都是可以解出来的，只不过会复杂一点，百变不离其中就是这么一个道理。</p>
</blockquote>
<p><strong>PS：今晚刚吃完年夜饭就来更新leetcode的题解了，选择的是比较简单的两道相似题目（两数之和&amp;三数之和），讲解了一下大概解法还有复杂度的分析，觉得还是挺入门级别的题目，利用这两道题可以明白到哈希表的好用，利用“空间换时间”，就这样吧。觉得博主写的还可以的可以点点赞，关注一波，谢谢大家的支持了~~~</strong></p>
]]></content>
      <categories>
        <category>LeetCode&amp;牛客题解</category>
      </categories>
      <tags>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title>统计无序数组各元素出现的次数</title>
    <url>/2020/01/22/%E7%BB%9F%E8%AE%A1%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E5%90%84%E5%85%83%E7%B4%A0%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>一个长度大小为N的数组，数组中的每个元素的取值范围在[1，N]，且为正整数。<br>问：如何在时间复杂度为O(N)，空间复杂度为O(1)的条件下，统计数组中不同元素出现的次数。</p>
</blockquote>
<a id="more"></a>
<h2 id="对这道题的感受"><a href="#对这道题的感受" class="headerlink" title="对这道题的感受"></a>对这道题的感受</h2><blockquote>
<p>一开始接触到这道题，我是觉得不难的，因为我会开辟一个辅助数组来帮助统计这个过程。但是这道题要求的是空间复杂度为O(1)，然后这道题的难度就噌噌噌的上升，然后我现在弄明白了就来写一下我对这道题的题解吧。</p>
</blockquote>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>遍历数组，通过当前元素的值作为下标，找到下一个元素。最后得到的数组中，下标（<strong>因为数组的下标都是从0开始的，所以需要+1</strong>）为数组中出现的元素，每个下标对应的值取反输出即是该元素出现的次数。</p>
<ul>
<li>若当前元素小于0，则跳过</li>
<li>若当前元素大于0，则判断其作为下标对应的元素是否大于0。若大于0，则把对应的元素赋值给当前元素，并把它的值设置为-1；若小于0，则把对应的元素自减1，当前元素置为0；</li>
</ul>
<p><strong>估计阅读到这里，你会一脸懵逼，这些当前元素和对应元素到底是什么鬼，好混。我明白，所以接下来我举个例子来讲解整个过程。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组举例</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、遍历数组，第一个arr[0]=2，然后看下标为2的元素是arr[2]=5。</span></span><br><span class="line"><span class="comment">2、把arr[2]对应的5赋值给arr[0]，然后arr[2]就设置为-1</span></span><br><span class="line"><span class="comment">3、然后重复整个过程直到结束</span></span><br><span class="line"><span class="comment">它的整个变化过程就是这样</span></span><br><span class="line"><span class="comment">- &#123;2, 5, 5, 2, 3&#125;</span></span><br><span class="line"><span class="comment">- 5, [-1], 5, 2, 3</span></span><br><span class="line"><span class="comment">- 3, [-1], 5, 2, [-1]</span></span><br><span class="line"><span class="comment">- 5, [-1], [-1], 2, [-1]</span></span><br><span class="line"><span class="comment">- [0], [-1], [-1], 2, [-2]</span></span><br><span class="line"><span class="comment">- [0], [-2], [-1], [0], [-2]</span></span><br><span class="line"><span class="comment">这个结果表示：1有0个，2有2个，3有一个，4有0个，5有2个</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/1/22  17:30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountArr</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; n) &#123;</span><br><span class="line">            <span class="comment">//因为数组都是从0开始的，所以arr[index]得减1才可以找到对应的元素，否则会数组越界</span></span><br><span class="line">            <span class="keyword">int</span> temp = arr[index] - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (temp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                index++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arr[temp] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                arr[index] = arr[temp];</span><br><span class="line">                arr[temp] = -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                arr[temp]--;</span><br><span class="line">                arr[index] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        work(arr, arr.length);</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> countResult : arr</span><br><span class="line">        ) &#123;</span><br><span class="line">            System.out.println(index++ + <span class="string">"出现了"</span> + (-<span class="number">1</span>) * countResult + <span class="string">"次"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行截图"><a href="#运行截图" class="headerlink" title="运行截图"></a>运行截图</h2><p><img src="/images/统计元素个数/1.jpg" alt="img"></p>
<h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><blockquote>
<p>今天一睡醒就一直在家帮忙，也没啥时间可以刷题，偶尔看会小说和刷抖音，颓废了一点，就写一些以前接触过的题，也挺有意思的。觉得博主写得还可以的点点赞，关注一下，谢谢大家的支持了~~~</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode&amp;牛客题解</category>
      </categories>
      <tags>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬虫入门笔记</title>
    <url>/2020/01/22/python%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote>
<p>由于这两天在家大扫除贴对联准备过年，所以刷题的机会少了许多，我也就放松放松一下，不写题解了，哈哈。由于python语言越来越火热，虽然我是走Java后台开发，但是也被python给吸引住了。所以这几天我学习了一下python的爬虫入门，记录一下我学习python爬虫的经历吧。</p>
</blockquote>
<a id="more"></a>
<h2 id="基础准备"><a href="#基础准备" class="headerlink" title="基础准备"></a>基础准备</h2><ul>
<li>我觉得要学习一个新的东西的时候，兴趣是最重要的一个因素。因为我本人很喜欢看小说，然后又是技术控，所以想试一下用python爬虫爬取我喜欢的小说（刺激~~~）</li>
<li>有一门面向对象的编程语言基础，例如我熟悉Java，然后入手python就觉得还可以（有点自恋~~~）</li>
<li>装python3.x的环境（因为我是用python3.8）,觉得麻烦可以直接装anaconda也行。我是因为毕业设计做深度学习都有安装，不过我还是用自己安装的python3.8来做爬虫。</li>
</ul>
<h2 id="开发爬虫的步骤"><a href="#开发爬虫的步骤" class="headerlink" title="开发爬虫的步骤"></a>开发爬虫的步骤</h2><ul>
<li>目标数据（网站、页面）</li>
<li>分析数据加载流程（分析目标数据所对应的url）</li>
<li>下载数据到本地</li>
<li>清洗，处理数据</li>
<li>数据持久化</li>
</ul>
<p><strong>因为我喜欢看伏天氏，所以爬取的是笔趣阁里面的伏天氏小说，以此来记录python爬虫的入门。</strong></p>
<h2 id="爬取数据"><a href="#爬取数据" class="headerlink" title="爬取数据"></a><strong>爬取数据</strong></h2><ol>
<li>需要导入requests库，没有这个库可以直接在win+r的cmd里面输入pip install requests下载即可</li>
<li>需要学习正则表达式来帮助我们爬取想要的数据</li>
</ol>
<h2 id="代码（加注释）"><a href="#代码（加注释）" class="headerlink" title="代码（加注释）"></a>代码（加注释）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python </span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"></span><br><span class="line"># 导入requests库，前提是已安装requests库，可以在命令提示符窗口输入pip install requests得到，</span><br><span class="line">import requests</span><br><span class="line"># 爬虫必备的正则模块</span><br><span class="line">import re</span><br><span class="line"></span><br><span class="line"># url存放要爬取的网页地址</span><br><span class="line">url = &apos;https://www.jupindai.com/book/87.html&apos;</span><br><span class="line"></span><br><span class="line"># requests发起get请求url，返回response</span><br><span class="line">response = requests.get(url)</span><br><span class="line"># 设置网页响应回来的编码格式</span><br><span class="line">response.encoding = &apos;gbk&apos;</span><br><span class="line"># 拿到网页的html</span><br><span class="line">html = response.text;</span><br><span class="line"># 拿到小说的名字</span><br><span class="line">title = re.findall(r&apos;&lt;meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;(.*?)&quot;&gt;&apos;, html)[0]</span><br><span class="line"># print(title)</span><br><span class="line"># 新建一个文件保存小说</span><br><span class="line">fb = open(&apos;%s.txt&apos; % title, &apos;w&apos;, encoding=&apos;utf-8&apos;)</span><br><span class="line"># print(html)</span><br><span class="line"></span><br><span class="line"># 获取对应的章节List</span><br><span class="line">dl = re.findall(</span><br><span class="line">    r&apos;&lt;dl class=&quot;panel-body panel-chapterlist&quot;&gt;.*?&lt;/div&gt;&apos;,</span><br><span class="line">    html, re.S)[1]</span><br><span class="line"># 获取对应的title和href</span><br><span class="line">chapter_info_list = re.findall(r&apos;&lt;a href=&quot;(.*?)&quot; title=&quot;(.*?)&quot;&gt;(.*?)&lt;/a&gt;&apos;, dl)</span><br><span class="line"># print(chapter_info_list)</span><br><span class="line"></span><br><span class="line"># 循环每一个chapter_info_list，分别下载</span><br><span class="line">for chapter_info in chapter_info_list:</span><br><span class="line">    chapter_url, none, chapter_title = chapter_info</span><br><span class="line">    chapter_url = &apos;https://www.jupindai.com%s&apos; %\</span><br><span class="line">                  chapter_url</span><br><span class="line">    # 下载</span><br><span class="line">    chapter_response = requests.get(chapter_url)</span><br><span class="line">    chapter_response.encoding = &apos;gbk&apos;</span><br><span class="line">    chapter_html = chapter_response.text</span><br><span class="line">    # print(chapter_url, chapter_title)</span><br><span class="line">    # 提取章节内容</span><br><span class="line">    chapter_content = re.findall(r&apos;&lt;div class=&quot;panel-body&quot; id=&quot;htmlContent&quot;&gt;(.*?)&lt;/div&gt;&apos;, chapter_html, re.S)[0]</span><br><span class="line">    # 清洗数据</span><br><span class="line">    chapter_content = str(chapter_content).replace(&apos; &apos;, &apos;&apos;)</span><br><span class="line">    chapter_content = str(chapter_content).replace(&apos;&amp;nbsp;&apos;, &apos;&apos;)</span><br><span class="line">    chapter_content = str(chapter_content).replace(&apos;&lt;br/&gt;&apos;, &apos;&apos;)</span><br><span class="line">    # 回车</span><br><span class="line">    chapter_content = str(chapter_content).replace(&apos;\r&apos;, &apos;&apos;)</span><br><span class="line">    # 换行</span><br><span class="line">    chapter_content = str(chapter_content).replace(&apos;\n&apos;, &apos;&apos;)</span><br><span class="line">    # print(chapter_content)</span><br><span class="line">    # 数据持久化</span><br><span class="line">    fb.write(chapter_title)</span><br><span class="line">    fb.write(&apos;\n&apos;)</span><br><span class="line">    fb.write(chapter_content)</span><br><span class="line">    fb.write(&apos;\n&apos;)</span><br><span class="line">    print(chapter_url)</span><br></pre></td></tr></table></figure>
<h2 id="运行部分截图"><a href="#运行部分截图" class="headerlink" title="运行部分截图"></a>运行部分截图</h2><p><img src="/images/爬虫/3.jpg" alt="img"></p>
<hr>
<p><strong>PS：由于写代码的时候是一边写一边测试，所以中间挺多过程你们可能看着有点懵，可以尝试着自己写一下来熟悉一下整个过程。这个应该就是最简单的一个python爬虫入门了吧，因为喜欢看小说，刚好现在在看《伏天氏》，就试着爬取一下数据，结果还不错，就是过程可能有点坎坷，毕竟本身我就是学Java出身，python也是半吊子，要不是刚好毕业设计做深度学习，我估计连python的语法都不会吧（哈哈），觉得对你有点帮助的点点赞，谢谢你们的支持了。</strong></p>
]]></content>
      <categories>
        <category>python学习</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>链表中环的入口节点</title>
    <url>/2020/01/21/%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>给定一个链表，若其中包含环，请找出该链表的环的入口节点，否则，输出null。</p>
</blockquote>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote>
<p>设置快慢指针，都从链表头出发，快指针每次<strong>走两步，</strong>慢指针一次<strong>走一步，</strong>假如有环，一定相遇于环中某点（结论1）.接着让两个指针分别从相遇点和链表头出发，两者都改为每次<strong>走一步</strong>，最终相遇于环入口（结论2）。以下是两个结论的证明：</p>
</blockquote>
<h2 id="两个结论："><a href="#两个结论：" class="headerlink" title="两个结论："></a>两个结论：</h2><ol>
<li><strong>设置快慢指针，假如有环，他们最后一定相遇在环中。</strong></li>
<li><strong>两个指针相遇后，让两个指针分别从链表头和相遇点重新出发，每次走一步，最后一定相遇于环入口。</strong></li>
</ol>
<p><strong>证明结论1</strong>：设置快慢指针fast和slow，fast每次走两步，low每次走一步。假如有环，两者一定在环中相遇。（因为low指针一旦进环，可以看作是fast指针在追slow指针，因为fast指针每次走两步，slow指针每次走一步，所以最后一定能追上（相遇））。</p>
<p><strong>证明结论2</strong>：</p>
<p>假设</p>
<p>链表头到环入口长度为——a，</p>
<p>环入口到相遇点长度为——b，</p>
<p>相遇点到环入口长度为——c，如图所示：</p>
<p><img src="/images/链表中环的入口节点/1.jpg" alt="img"></p>
<p>则相遇时，</p>
<p><strong>快指针路程=a+（b+c）k+b，k&gt;=1</strong>，其中b+c为环的长度，k为环的圈数（k&gt;=1，即最少一圈，不能是0圈，不然快慢指针走的路程一样，矛盾）。</p>
<p><strong>慢指针路程=a+b</strong>。</p>
<p>因为快指针的路程是慢指针的路程的两倍，所以：<strong>（a+b）*2=a+（b+c）k+b</strong>。</p>
<p>化简得：</p>
<p><strong>a=（k-1）（b+c）+c</strong>，这个式子的意思是：<strong>链表头到环入口的距离=相遇点到环入口的距离+（k-1）圈数环长度</strong>。其中k&gt;=1，所以k-1&gt;=0圈。所以两个指针分别从链表头和相遇点出发，最后一定相遇于环入口。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> nowcoder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/1/21  0:40</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryNodeOfLoop</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义链表结构</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        ListNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义快慢指针</span></span><br><span class="line">        ListNode fast = pHead;</span><br><span class="line">        ListNode slow = pHead;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="comment">//如果有环，想遇于环中某点</span></span><br><span class="line">            <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果没有环，return null</span></span><br><span class="line">        <span class="keyword">if</span> (fast.next == <span class="keyword">null</span> || fast.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果有环，两个指针分别从链表头和相遇点出发，最终必定在环入口相遇</span></span><br><span class="line">        slow = pHead;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过截图"><a href="#通过截图" class="headerlink" title="通过截图"></a>通过截图</h2><p><img src="/images/链表中环的入口节点/2.jpg" alt="img"></p>
<p><strong>参考来自牛客网的Java牛人（却顾所来径）的题解，觉得他写的真的很好，所以分享一波。</strong></p>
<p><strong>PS：今天刚从广州回到普宁，路上一直塞车，到晚上10点多才到家，洗完澡又觉得还有点精神，所以参考（却顾所来径）大神的题解，分享了一波链表中的环入口结点，真的觉得挺有意思的。最后就是快要过年了，在学校搞老师的毕业设计弄到19号，20号回家又塞车，等于我颓废了几天了，然后就是想说，这两天应该就是要好好过年帮忙了，看到有意思的题我会试着写它们的题解，觉得我写的还好的帮忙点点赞，关注一波。不出意外的话，今年毕业找到工作后，那个时候我应该会试着更新在工作上学到的技术和遇到的难点，相信自己的努力终有一天会有回报吧，谢谢你们对我的支持~~~</strong></p>
]]></content>
      <categories>
        <category>LeetCode&amp;牛客题解</category>
      </categories>
      <tags>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串的排列</title>
    <url>/2020/01/18/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>输入一个字符串，按字典序打印出该字符串中字符的所有排列。例如输入字符串abc，则打印出由字符a，b，c所能排列出来的所有字符串abc，acb，bac，bca，cab，cba。</p>
</blockquote>
<a id="more"></a>
<h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h2><blockquote>
<p>输入一个字符串，长度不超过9（可能有字符重复），字符只包括大小写字母。</p>
</blockquote>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote>
<p>该题目的解法原型就是全排列算法，给一个abc字符串有6种不同的排列。然后这道题是要在全排列的基础上做到字典序排序。</p>
</blockquote>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/1/18  20:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Permutation_nowcoder</span> </span>&#123;</span><br><span class="line">    <span class="comment">//全排列入口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;String&gt; <span class="title">Permutation</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (str != <span class="keyword">null</span> &amp;&amp; str.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            permutation(str.toCharArray(), <span class="number">0</span>, list);</span><br><span class="line">            Collections.sort(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//全排列实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">permutation</span><span class="params">(<span class="keyword">char</span>[] arr, <span class="keyword">int</span> i, ArrayList&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == arr.length - <span class="number">1</span>) &#123;</span><br><span class="line">            list.add(String.valueOf(arr[i]));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == i || !set.contains(arr[j])) &#123;</span><br><span class="line">                    set.add(arr[j]);</span><br><span class="line">                    swap(arr, i, j);</span><br><span class="line">                    permutation(arr, i + <span class="number">1</span>, list);</span><br><span class="line">                    swap(arr, j, i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换两个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过截图"><a href="#通过截图" class="headerlink" title="通过截图"></a>通过截图</h2><p><img src="/images/字符串的排列/2.jpg" alt="img"></p>
<p><strong>PS：今天在学校实验室弄我的深度学习的毕业设计项目的第一步目标检测，弄了至少两个星期了才搞好图片的目标检测，用的是yolov3来做检测，本来在自己的电脑跑一小部分数据是没问题的，到了实验室跑全部数据是巨多小问题，后面都解决了，谢天谢地哈哈哈。准备从广州回家过年了，这段时间过得还是挺充足的，每天都有学到新的东西，但是今天的这道题确实有点水了，勿怪哈~~~</strong></p>
]]></content>
      <categories>
        <category>LeetCode&amp;牛客题解</category>
      </categories>
      <tags>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>顺时针打印矩阵</title>
    <url>/2020/01/17/%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印每一个数字，例如，如果输入如下4*4矩阵：</p>
<p>1     2     3    4</p>
<p> 5     6    7    8</p>
<p> 9    10  11  12 </p>
<p>13  14  15   16 </p>
<p>则依次打印出数字1，2，3，4，8，12，16，15，14，13，9，5，6，7，11，10。</p>
</blockquote>
<a id="more"></a>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol>
<li>因为一个二维平面，给定两个坐标（x1, y1）和（x2, y2）可以唯一确定一个矩阵。</li>
<li>然后可以通过圈子来打印对应的矩阵，然后缩小圈子完成整个过程即可。</li>
</ol>
<h2 id="图解过程"><a href="#图解过程" class="headerlink" title="图解过程"></a>图解过程</h2><p><img src="/images/顺时针打印矩阵/2.jpg" alt="img"></p>
<p><strong>这个时候就打印出了1，2，3，4，8，12，16，15，14，13，9，5。</strong></p>
<p><strong>然后这个时候缩小圈子继续重复：</strong></p>
<p><img src="/images/顺时针打印矩阵/3.jpg" alt="img"></p>
<p><strong>这个时候继续打印出6，7，11，10。然后全部拼接起来就是答案了。</strong></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/1/17  20:58</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ArrayList&lt;Integer&gt; resList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//拿到左上角(x1, y1)和右下角(x2, y2)</span></span><br><span class="line">        <span class="keyword">int</span> x1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> y1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> x2 = matrix.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> y2 = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//顺时针打印圈子的数值</span></span><br><span class="line">        <span class="keyword">while</span> (x1 &lt;= x2 &amp;&amp; y1 &lt;= y2) &#123;</span><br><span class="line">            helpPrintMatrix(matrix, x1++, y1++, x2--, y2--);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">helpPrintMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x1 == x2) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = y1; i &lt;= y2; i++) &#123;</span><br><span class="line">                resList.add(matrix[x1][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (y1 == y2) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = x1; i &lt;= x2; i++) &#123;</span><br><span class="line">                resList.add(matrix[i][y1]);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//知道（x1, y1）和（x2, y2）可以确定一个矩阵</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> curX = x1;</span><br><span class="line">            <span class="keyword">int</span> curY = y1;</span><br><span class="line">            <span class="keyword">while</span> (curY != y2) &#123;</span><br><span class="line">                resList.add(matrix[x1][curY]);</span><br><span class="line">                curY++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (curX != x2) &#123;</span><br><span class="line">                resList.add(matrix[curX][y2]);</span><br><span class="line">                curX++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (curY != y1) &#123;</span><br><span class="line">                resList.add(matrix[x2][curY]);</span><br><span class="line">                curY--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (curX != x1) &#123;</span><br><span class="line">                resList.add(matrix[curX][y1]);</span><br><span class="line">                curX--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过截图："><a href="#通过截图：" class="headerlink" title="通过截图："></a>通过截图：</h2><p><img src="/images/顺时针打印矩阵/4.jpg" alt="img"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>如果你要是通过规律来顺时针打印矩阵的话会显得非常麻烦，我不是说不按照我的方法做不出来，只是会比较麻烦，coding能力较差的人可能会写不出来，但是把一个矩阵分解成多个圈子打印即可，打印单独写一个函数即可完成。</p>
</blockquote>
<p><strong>PS：觉得博主写的还可以的点点赞，关注走一波，谢谢大家的支持了~~~</strong></p>
]]></content>
      <categories>
        <category>LeetCode&amp;牛客题解</category>
      </categories>
      <tags>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title>复杂链表的复制</title>
    <url>/2020/01/16/%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判断程序会直接返回空）</p>
</blockquote>
<a id="more"></a>
<h2 id="两种策略解决"><a href="#两种策略解决" class="headerlink" title="两种策略解决"></a>两种策略解决</h2><h2 id="策略1（HashMap解决）"><a href="#策略1（HashMap解决）" class="headerlink" title="策略1（HashMap解决）"></a>策略1（HashMap解决）</h2><ol>
<li>先用一个HashMap的key存放原来的链表，value存放key的值。</li>
<li>知道了key的指向，然后让value跟着key一样的指向即可。</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/1/16  18:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomListNodeCopy</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义复杂链表的结构</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> label;</span><br><span class="line">        RandomListNode next = <span class="keyword">null</span>;</span><br><span class="line">        RandomListNode random = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        RandomListNode(<span class="keyword">int</span> label) &#123;</span><br><span class="line">            <span class="keyword">this</span>.label = label;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode pHead)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;RandomListNode, RandomListNode&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        RandomListNode cur = pHead;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            map.put(cur, <span class="keyword">new</span> RandomListNode(cur.label));</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = pHead;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            map.get(cur).next = map.get(cur.next);</span><br><span class="line">            map.get(cur).random = map.get(cur.random);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(pHead);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过截图"><a href="#通过截图" class="headerlink" title="通过截图"></a>通过截图</h2><p><img src="/images/复杂链表的复制/3.jpg" alt="img"></p>
<h2 id="HashMap解法总结"><a href="#HashMap解法总结" class="headerlink" title="HashMap解法总结"></a>HashMap解法总结</h2><blockquote>
<p>用HashMap做简单，容易理解，时间复杂度为O(N)，空间复杂度也为O(N)，其实这道题还可以做到时间复杂度为O(N)，空间复杂度为O(1)，就是我接下来介绍的这种解法。</p>
</blockquote>
<hr>
<h2 id="策略2（创建拆分）"><a href="#策略2（创建拆分）" class="headerlink" title="策略2（创建拆分）"></a>策略2（创建拆分）</h2><ol>
<li>遍历链表，复制每个节点，如复制节点A得到A1，将节点A1插到节点A后面</li>
<li>重新遍历链表，复制旧节点的随机指针给新节点，如A1.random = A.random.next</li>
<li>拆分链表，将链表拆分为原链表和复制后的链表</li>
</ol>
<h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><p><img src="/images/复杂链表的复制/2.jpg" alt="img"></p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/1/16  18:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomListNodeCopy</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义复杂链表的结构</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> label;</span><br><span class="line">        RandomListNode next = <span class="keyword">null</span>;</span><br><span class="line">        RandomListNode random = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        RandomListNode(<span class="keyword">int</span> label) &#123;</span><br><span class="line">            <span class="keyword">this</span>.label = label;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并拆分的时间复杂度为O(N)，空间复杂度为O(1)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        RandomListNode cur = pHead;</span><br><span class="line">        <span class="comment">//1、复制每个结点，如复制结点A得到A1，将结点A1插到结点A后面；</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            RandomListNode cloneNode = <span class="keyword">new</span> RandomListNode(cur.label);</span><br><span class="line">            RandomListNode nextNode = cur.next;</span><br><span class="line">            cur.next = cloneNode;</span><br><span class="line">            cloneNode.next = nextNode;</span><br><span class="line">            cur = nextNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur = pHead;</span><br><span class="line">        <span class="comment">//2、重新遍历链表，复制老结点的随机指针给新结点，如A1.random = A.random.next;</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cur.next.random = cur.random == <span class="keyword">null</span> ? <span class="keyword">null</span> : cur.random.next;</span><br><span class="line">            cur = cur.next.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、拆分链表，将链表拆分为原链表和复制后的链表</span></span><br><span class="line">        cur = pHead;</span><br><span class="line">        RandomListNode pCloneHead = pHead.next;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            RandomListNode cloneNode = cur.next;</span><br><span class="line">            cur.next = cloneNode.next;</span><br><span class="line">            cloneNode.next = cloneNode.next == <span class="keyword">null</span> ? <span class="keyword">null</span> : cloneNode.next.next;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pCloneHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过截图-1"><a href="#通过截图-1" class="headerlink" title="通过截图"></a>通过截图</h2><p><img src="/images/复杂链表的复制/4.jpg" alt="img"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>一道好的题目往往有多种解决的办法，大二时期的我就只会用最基础的贪心和暴力解决各类问题，不是说暴力解法不好，只是有时候有更好的算法可以解决我们又为何不去掌握呢。所以一道题目的多种的解法我都会好好研读和学习。希望也有人喜欢和我一样多了解多种解法，扩展一下自己的思路，嘿嘿嘿。。。</p>
</blockquote>
<p><strong>PS：如果觉得博主写的不错的话可以点点赞，关注走一波，谢谢大家的支持了~~~</strong></p>
]]></content>
      <categories>
        <category>LeetCode&amp;牛客题解</category>
      </categories>
      <tags>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title>神级算法——二分天下</title>
    <url>/2020/01/11/%E7%A5%9E%E7%BA%A7%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E4%BA%8C%E5%88%86%E5%A4%A9%E4%B8%8B/</url>
    <content><![CDATA[<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><blockquote>
<p>二分查找也称折半查找（Binary Search），它是一种效率较高得查找方法。一般都是要求线性表有序，然后二分查找的时间复杂度为O(logN)。</p>
</blockquote>
<a id="more"></a>
<h2 id="不一样的二分"><a href="#不一样的二分" class="headerlink" title="不一样的二分"></a>不一样的二分</h2><blockquote>
<p>如果数组无序，难道就不能用二分查找了吗？答案是否定的，即使一个数组无序，也可以用二分查找来找。下面我就用两个例子来给你们上一课（膨胀了我，哈哈~~~）</p>
</blockquote>
<h2 id="例子1（旋转数组）："><a href="#例子1（旋转数组）：" class="headerlink" title="例子1（旋转数组）："></a>例子1（旋转数组）：</h2><blockquote>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
</blockquote>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><blockquote>
<p>即使数组无序，但是我们还是可以使用二分查找来找出最小值。因为旋转数组部分有序，利用二分查找还是很容易查找到最小值</p>
</blockquote>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span> ; <span class="keyword">int</span> high = array.length - <span class="number">1</span>;  </span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;       </span><br><span class="line">            <span class="keyword">if</span>(array[mid] &gt; array[high])&#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                high = mid;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[low];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过："><a href="#通过：" class="headerlink" title="通过："></a>通过：</h2><p><img src="/images/二分法/2.jpg" alt="img"></p>
<p><strong>可能有人会觉得，即使无序可以使用二分查找，但是你这个旋转数组也是部分有序，所以可以使用二分查找。接下来我再讲解一道题来证明给你看——查找局部最小值。</strong></p>
<h2 id="例子2（查找局部最小值）"><a href="#例子2（查找局部最小值）" class="headerlink" title="例子2（查找局部最小值）"></a><strong>例子2（查找局部最小值）</strong></h2><blockquote>
<p>定义局部最小的概念。arr数组长度为1时，arr[0]是局部最小。arr的长度为N(N&gt;1)时，如果arr[0]&lt;arr[1]，那么arr[0]是局部最小；如果arr[N-1]&lt;arr[N-2]，那么arr[N-1]是局部最小；如果0&lt;i&lt;N-1，既有arr[i]&lt;arr[i-1]，又有arr[i]&lt;arr[i+1]，那么arr[i]是局部最小。 给定无序数组arr，已知arr中任意两个相邻的数都不相等。写一个函数，只需返回arr中任意一个局部最小出现的位置即可。</p>
</blockquote>
<h2 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h2><ul>
<li>先查找arr[0]和arr[N-1]，即第一个数和最后一个数是不是局部最小，如果是，直接返回这个数即可。</li>
<li>如果arr[0]&gt;arr[1]，arr[N-1]&gt;arr[N-2]，那么此时的情况就是这样的：</li>
</ul>
<p><img src="/images/二分法/z.jpg" alt="img"></p>
<h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/1/11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindOneLessValueIndex</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLessIndex</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果不存在直接return -1</span></span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先看arr[0]和arr[N-1]是不是局部最小，是的话直接返回即可</span></span><br><span class="line">        <span class="keyword">if</span> (arr.length == <span class="number">1</span> || arr[<span class="number">0</span>] &lt; arr[<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[arr.length - <span class="number">1</span>] &lt; arr[arr.length - <span class="number">2</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> arr.length - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//然后中间部分使用二分</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = arr.length - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] &gt; arr[mid - <span class="number">1</span>]) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; arr[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        printArray(arr);</span><br><span class="line">        <span class="keyword">int</span> index = getLessIndex(arr);</span><br><span class="line">        System.out.println(<span class="string">"index: "</span> + index + <span class="string">", value: "</span> + arr[index]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h2><p><img src="/images/二分法/x.jpg" alt="img"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>看了上面的两个例子，是不是颠覆了你对二分查找的认知。哈哈。不是说一定要有序才能用二分查找，只要你确定了某一部分一定有你要找的，你就可以二分下去找。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法积累ing</category>
      </categories>
      <tags>
        <tag>算法进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>单调栈及其应用</title>
    <url>/2020/01/08/%E5%8D%95%E8%B0%83%E6%A0%88%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><blockquote>
<p>博主是因为在刷LeetCode题的时候才知道有单调栈这个数据结构，说起来也是真的巧妙。一开始是在LeetCode739题（每日温度）接触到的，其实单调栈就是从数组中找到左右两边比你大的数或者比你小的数而且时间复杂度为O(N)。以下讲一些单调栈的特性和一些应用题</p>
</blockquote>
<a id="more"></a>
<h2 id="什么是单调栈"><a href="#什么是单调栈" class="headerlink" title="什么是单调栈"></a>什么是单调栈</h2><p><strong>单调栈就是栈里面存放的数据都是有序的，所以可以分为单调递增栈和单调递减栈两种。</strong></p>
<ol>
<li>单调递增栈就是从栈底到栈顶是从大到小</li>
<li>单调递减栈就是从栈底到栈顶是从小到大</li>
</ol>
<h2 id="单调栈的经典题目（求最大子矩阵的大小）"><a href="#单调栈的经典题目（求最大子矩阵的大小）" class="headerlink" title="单调栈的经典题目（求最大子矩阵的大小）"></a>单调栈的经典题目（求最大子矩阵的大小）</h2><blockquote>
<p>【题目】<br>给定一个整型矩阵map，其中的值只有0和1两种，求其中全是1的所有矩形区域中，最大的矩形区域为1的数量。<br>例如：<br>1  1  1  0<br>其中，最大的矩形区域有3个1，所以返回3。<br>再如：<br>1  0  1  1<br>1  1  1  1<br>1  1  1  0<br>其中，最大的矩形区域有6个1，所以返回6.</p>
</blockquote>
<p><strong>要想解答这道题，我先引入另一道题来更好得帮你理解。</strong></p>
<blockquote>
<p>给出一个矩形统计图，它的每个矩形的宽度都为1，高度是题目所给。要你求出这个矩形图中最大面积的长方形。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">矩形统计图的数据为 [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure>
<p><img src="/images/单调栈/2.jpg" alt="img"></p>
<p><strong>思路：</strong></p>
<p>准备一个栈，栈低到栈顶是从小到大的。栈如图所示</p>
<p><img src="/images/单调栈/3.jpg" alt="img"></p>
<ol>
<li>第一个下标是0，值是4，栈为空，放入栈中。</li>
<li>第二个下标为1，值为3，比栈顶（此时是4）小，不符合栈低到栈顶从小到大，所以弹出栈顶（4），此时4最左边界就是-1，最右就是1，所以弹出的面积就是4 *（1-（-1）-1）为4；然后3入栈</li>
<li>第三个下标为2，值为2，比栈顶（此时是3）小，不符合栈低到栈顶从小到大，所以弹出栈顶（3），此时3的最左边界是-1，最右就是2，所以弹出的面积是3 *（2-（-1）-1）为6；然后2入栈</li>
<li>第四个下标为3，值为5，比栈顶（此时是2）大，符合栈低到栈顶从小到大，所以5入栈</li>
<li>第五个下标为4，值为6，比栈顶（此时是6）大，符合栈低到栈顶从小到大，所以6入栈</li>
<li>此时没有值可以入栈了，弹出6，此时6的最左边界就是栈顶（5）的下标3，最右边界就是5，所以弹出的面积是6 *（5-（3）-1）为6</li>
<li>继续出栈，面积为5 *（5-（2）-1）为10；</li>
<li>继续出栈，面积为2 *（5-（-1）-1）为10；</li>
<li>最大值就是10，所以输入10</li>
</ol>
<p><strong>ps：建议画图，然后按照我上面写的步骤尝试一遍，你就很清楚整个过程了。</strong></p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a><strong>代码：</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/1/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaximalRectangle</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给定一个数组[4,3,2,5,6]，每一个数代表一个矩形的高度，组成的一个二维数组，求其中的最大矩形</span></span><br><span class="line"><span class="comment">     * 解法，用最大单调栈的结构来求解，用来求解一个连续的无规则面积中最大的矩形面积</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxRecFromBottom</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (height.length &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//从小到大的单调栈</span></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">//这一步是在求每次遇到不是单调递增的时候那个柱子的面积</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.length; i++) &#123;</span><br><span class="line">            <span class="comment">//如果栈不为空，且当前元素小于栈顶元素</span></span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; height[i] &lt;= height[stack.peek()]) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = stack.pop();</span><br><span class="line">                <span class="comment">//左边界</span></span><br><span class="line">                <span class="keyword">int</span> k = stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">                <span class="comment">//(右边界 - 左边界)*高度</span></span><br><span class="line">                <span class="keyword">int</span> curArea = (i - k - <span class="number">1</span>) * height[j];</span><br><span class="line">                maxArea = Math.max(maxArea, curArea);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//求整个单调递增的面积</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = stack.pop();</span><br><span class="line">            <span class="keyword">int</span> k = stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">            <span class="comment">//当前的右边界就是数组长度</span></span><br><span class="line">            <span class="keyword">int</span> curArea = (height.length - k - <span class="number">1</span>) * height[j];</span><br><span class="line">            maxArea = Math.max(maxArea, curArea);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>回归正题，来解答一开始的那道题</strong></p>
<blockquote>
<p>思路就是当传入一个二维数组的时候，我们把它压缩成一个一维数组的形式进行解答。<br>从第0行开始调用我们上面那个求矩形的面积的函数，求完求第0行到第一行，依次类推，反正当前要是有0的话就是0，不是0就加1.</p>
</blockquote>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/1/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaximalRectangle</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给定一个数组[4,3,2,5,6]，每一个数代表一个矩形的高度，组成的一个二维数组，求其中的最大矩形</span></span><br><span class="line"><span class="comment">     * 解法，用最大单调栈的结构来求解，用来求解一个连续的无规则面积中最大的矩形面积</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxRecFromBottom</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (height.length &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//从小到大的单调栈</span></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">//这一步是在求每次遇到不是单调递增的时候那个柱子的面积</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.length; i++) &#123;</span><br><span class="line">            <span class="comment">//如果栈不为空，且当前元素小于栈顶元素</span></span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; height[i] &lt;= height[stack.peek()]) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = stack.pop();</span><br><span class="line">                <span class="comment">//左边界</span></span><br><span class="line">                <span class="keyword">int</span> k = stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">                <span class="comment">//(右边界 - 左边界)*高度</span></span><br><span class="line">                <span class="keyword">int</span> curArea = (i - k - <span class="number">1</span>) * height[j];</span><br><span class="line">                maxArea = Math.max(maxArea, curArea);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//求整个单调递增的面积</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = stack.pop();</span><br><span class="line">            <span class="keyword">int</span> k = stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">            <span class="comment">//当前的右边界就是数组长度</span></span><br><span class="line">            <span class="keyword">int</span> curArea = (height.length - k - <span class="number">1</span>) * height[j];</span><br><span class="line">            maxArea = Math.max(maxArea, curArea);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxRecSize</span><span class="params">(<span class="keyword">int</span>[][] map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (map.length &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] height = <span class="keyword">new</span> <span class="keyword">int</span>[map[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; map.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; map[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="comment">//如果当前行不是0，则累加高度</span></span><br><span class="line">                <span class="keyword">if</span> (map[i][j] != <span class="number">0</span>)</span><br><span class="line">                    height[j] += map[i][j];</span><br><span class="line">                <span class="keyword">else</span><span class="comment">//如果当前行的值为0，则高度为0</span></span><br><span class="line">                    height[j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//求出每一行的最大矩形面积</span></span><br><span class="line">            maxArea = Math.max(maxRecFromBottom(height), maxArea);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>以上就是我接触到的单调栈，当然有许多的应用，但是也不可能一一列举，只是抽出比较经典的题目来讲一下，然后就是觉得写得还不错的给博主点点赞和关注一波，谢谢大家的支持了。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法积累ing</category>
      </categories>
      <tags>
        <tag>算法进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>栈(Stack)与队列(Queue)</title>
    <url>/2020/01/06/%E6%A0%88-Stack-%E4%B8%8E%E9%98%9F%E5%88%97-Queue/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>栈：后进先出（LIFO-last in first out）：最后插入的元素最先出来。<br>队列：先进先出（FIFO-first in first out）：最先插入的元素最先出来。</p>
</blockquote>
<a id="more"></a>
<h2 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h2><p><img src="/images/栈与队列/栈与队列.jpg" alt="img"></p>
<p><strong>本文通过一些简单的算法题来带你们更好的理解栈(Stack)和队列(Queue)。</strong></p>
<h2 id="三道算法题加深理解"><a href="#三道算法题加深理解" class="headerlink" title="三道算法题加深理解"></a>三道算法题加深理解</h2><h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a><strong>第一题</strong></h3><p><strong>题目：获取一个栈的min</strong></p>
<blockquote>
<p><strong>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O(1)）。</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/1/6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Format3</span> </span>&#123;</span><br><span class="line">    <span class="comment">//正常stack</span></span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="comment">//存放min的stack</span></span><br><span class="line">    Stack&lt;Integer&gt; help = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack.push(node);</span><br><span class="line">        <span class="keyword">if</span> (help.isEmpty()) &#123;</span><br><span class="line">            help.push(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//help里面存放的都是最小值,也就是pop之后里面是当前的最小值</span></span><br><span class="line">            <span class="keyword">int</span> res = help.peek() &gt; node ? node : help.peek();</span><br><span class="line">            help.push(res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack.pop();</span><br><span class="line">        help.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> help.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><p><strong>题目：用栈实现队列</strong></p>
<p><strong>思路：构建两个栈（Push栈和Pop栈）;将Push栈中的数据导入Pop栈中然后返回给用户，就实现了队列。需要注意两个条件：①Pop栈为空时才能往里面倒数据。②向Pop栈倒数据必须全部倒完。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/1/6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackToQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">//用s1、s2避免代码看起来混乱，因为都是push和pop操作</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; s1;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; s2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StackToQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        s1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        s2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> obj)</span> </span>&#123;</span><br><span class="line">        s1.push(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.isEmpty() &amp;&amp; s2.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"empty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s2.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!s1.isEmpty()) &#123;</span><br><span class="line">                s2.push(s1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s2.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.isEmpty() &amp;&amp; s2.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"empty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s2.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!s1.isEmpty()) &#123;</span><br><span class="line">                s2.push(s1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h3><p><strong>题目：用队列实现栈</strong></p>
<p><strong>思路：构建两个队列：queue队列和help队列；压入数据时数据都进queue队列，假设队列中进入了1、2、3、4、5，返回数据时，把1、2、3、4放入help队列，然后拿出queue的5返回。接着把queue队列和help队列的引用交换。即下次返回数据还是从queue队列拿1、2、3、放入help队列，然后queue拿出4返回，再交换各自的引用，一直重复。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/1/6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueToStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; help;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">QueueToStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        help = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Integer e)</span> </span>&#123;</span><br><span class="line">        queue.add(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"empty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (queue.size() != <span class="number">1</span>) &#123;</span><br><span class="line">            help.add(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = queue.poll();</span><br><span class="line">        swap();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"empty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (queue.size() != <span class="number">1</span>) &#123;</span><br><span class="line">            help.add(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = queue.poll();</span><br><span class="line">        help.add(res);</span><br><span class="line">        swap();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; tmp = queue;</span><br><span class="line">        queue = help;</span><br><span class="line">        help = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>就是把栈跟队列的特点介绍了一下，然后用三道经典的题目来加深对栈和队列的理解，然后附上我自己写的代码，都是经过测试后才附上的。有什么问题，欢迎与我交流和讨论，我的目的就是大家一起学习一起进步。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法积累ing</category>
      </categories>
      <tags>
        <tag>栈与队列</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈hash函数及应用</title>
    <url>/2020/01/04/%E6%B5%85%E8%B0%88hash%E5%87%BD%E6%95%B0%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h2 id="一、Hash-散列函数"><a href="#一、Hash-散列函数" class="headerlink" title="一、Hash(散列函数)"></a>一、Hash(散列函数)</h2><blockquote>
<p>Hash一般被翻译成散列、杂凑或音译为哈希，是把任意长度的输入（又叫做预映射pre-image）通过散列算法变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列出相同的输出，所以不可能从散列值来确定唯一的输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。（<strong>介绍来源于百度百科</strong>）</p>
</blockquote>
<a id="more"></a>
<h3 id="Hash函数性质："><a href="#Hash函数性质：" class="headerlink" title="Hash函数性质："></a>Hash函数性质：</h3><ol>
<li>输入为任意长度字符串，输出为固定长度字符串。</li>
<li>输入确定，输出也确定。特定输入对应唯一输出（有可能两个输入对应一个输出——<strong>hash碰撞</strong>，解决碰撞有<strong>链地址法</strong>和<strong>开发地址法</strong>，这里就不展开了，就浅谈一下就好了）</li>
<li>随着输入域的增大，输出域均匀增大（这种均匀性越好，hash函数越好）</li>
</ol>
<hr>
<h2 id="二、设计RandomPool结构"><a href="#二、设计RandomPool结构" class="headerlink" title="二、设计RandomPool结构"></a>二、设计RandomPool结构</h2><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><blockquote>
<p>【题目】</p>
<p>设计一种结构，在该结构中有如下三个功能：</p>
<p>insert(key)：将某个key加入到该结构，做到不重复加入。</p>
<p>delete(key)：将原本在结构中的某个key移除。</p>
<p>getRandom()：等概率随机返回结构中的任何一个key。</p>
<p>【要求】</p>
<p>insert、delete和getRandom方法的时间复杂度都是O(1)</p>
</blockquote>
<h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><blockquote>
<p>insert：</p>
<p>构造map&lt;key,Integer&gt; keyIndexMap，map&lt;Integer,key&gt; indexKeyMap。当第一个插入o1，就在keyIndexMap.add（o1,1）,indexKeyMap.add(1,o1)。</p>
<p>getRandom：</p>
<p>通过数字进行random，得到的就是等概率的。（保证0~Integer是连续的就可以保证等概率）。</p>
<p>delete：</p>
<p>删除后存在空位，这些空位会影响到0~Integer是连续的。解决办法：拿最后一条记录填补空位。</p>
</blockquote>
<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/1/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomPool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pool</span>&lt;<span class="title">K</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> HashMap&lt;K,Integer&gt; keyIndexMap;</span><br><span class="line">        <span class="keyword">private</span> HashMap&lt;Integer,K&gt; indexKeyMap;</span><br><span class="line">        <span class="comment">//size记录第几个进来的</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Pool</span><span class="params">()</span></span>&#123;</span><br><span class="line">            keyIndexMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            indexKeyMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//插入操作分别插入到keyIndexMap和indexKeyMap中</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!keyIndexMap.containsKey(key))&#123;</span><br><span class="line">                 keyIndexMap.put(key,size);</span><br><span class="line">                indexKeyMap.put(size++,key);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// A 0 0 A</span></span><br><span class="line">        <span class="comment">// B 1 1 B</span></span><br><span class="line">        <span class="comment">// C 2 2 C</span></span><br><span class="line">        <span class="comment">// D 3 3 D</span></span><br><span class="line">        <span class="comment">//先确定删除的索引，以及最后面的值，把最后面的值补充到删除的地方</span></span><br><span class="line">        <span class="comment">//之后删除开始应该删除的</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(keyIndexMap.containsKey(key))&#123;</span><br><span class="line">                <span class="keyword">int</span> deleteIndex = keyIndexMap.get(key);</span><br><span class="line">                <span class="keyword">int</span> lastIndex = --size;</span><br><span class="line">                K lastKey = indexKeyMap.get(lastIndex);</span><br><span class="line">                keyIndexMap.put(lastKey,deleteIndex);</span><br><span class="line">                indexKeyMap.put(deleteIndex,lastKey);</span><br><span class="line">                keyIndexMap.remove(key);</span><br><span class="line">                indexKeyMap.remove(lastIndex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//等概率从indexKeyMap返回key</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> K <span class="title">random</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(size==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> num = (<span class="keyword">int</span>) (Math.random()*size);</span><br><span class="line">            <span class="keyword">return</span> indexKeyMap.get(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="三、布隆过滤器"><a href="#三、布隆过滤器" class="headerlink" title="三、布隆过滤器"></a>三、布隆过滤器</h2><h3 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h3><blockquote>
<p>布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量（位图）和一系列随机映射函数（哈希函数）。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询效率到远远超于一般的算法，缺点是有一定的误识别率和删除困难。</p>
</blockquote>
<h3 id="操作过程"><a href="#操作过程" class="headerlink" title="操作过程"></a>操作过程</h3><p>布隆过滤器最重要的实现就是位图的实现，也就是位数组，并且在这个数组中每一个位置只占有一个bit，而每个bit只有0和1两种状态。</p>
<p>假设有k个哈希函数，且每个哈希函数的输出范围都大于m，我们就把输出值对k取余（%m），就会得到k个[0,m-1]的值，由于每个哈希函数之间相互独立，因此这k个数也相互独立，最后将这k个数对应到的bit标记为1（涂黑）</p>
<p>等判断时，将输入对象经过这k个哈希函数计算得到k个值，然后判断对应的bit位是否都为1（涂黑），<strong>如果有一个不为黑，那么这个输入对象则不在这个集合中，也就不是黑名单！如果都是黑，说明在集合中，但是有可能有误</strong>。</p>
<h3 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h3><p><img src="/images/浅谈hash/1.jpg" alt=""></p>
<h3 id="重要参数计算"><a href="#重要参数计算" class="headerlink" title="重要参数计算"></a>重要参数计算</h3><p>通过上面的描述，如果输入量过大，而bit空间很小，那么误判率会上升。那么要怎么平衡bit空间呢，已经有大神通过数据推导出公式了~~~</p>
<p>假设输入对象个数为n，bit大小为m，所能容忍的误判率为p和哈希函数的个数为k。计算公式如下（小数向上取整）</p>
<p><img src="/images/浅谈hash/2.jpg" alt=""></p>
<p><strong>注意：由于我们计算的m和k可能为小数，通过向上取整，此时的误判率会下降</strong></p>
<hr>
<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><blockquote>
<p>以上就是浅谈hash函数及应用。当然hash函数的应用还有很多，我也只是略懂皮毛，写下这一篇加深我对hash的理解和应用，仅此而已。</p>
</blockquote>
<h2 id="五、参考来源"><a href="#五、参考来源" class="headerlink" title="五、参考来源"></a>五、参考来源</h2><p><a href="https://baike.baidu.com/item/Hash/390310?fr=aladdin" target="_blank" rel="noopener">hash百度百科</a></p>
<p><a href="http://www.bubuko.com/infodetail-2710292.html" target="_blank" rel="noopener">RandomPool结构</a></p>
<p><a href="https://blog.csdn.net/weixin_41576121/article/details/94723342" target="_blank" rel="noopener">布隆过滤器</a></p>
]]></content>
      <categories>
        <category>算法积累ing</category>
      </categories>
      <tags>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>数据流中的中位数解法</title>
    <url>/2020/01/03/%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%E8%A7%A3%E6%B3%95/</url>
    <content><![CDATA[<h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><blockquote>
<p>越来越多的程序员关注数据结构和算法的知识，会在leetcode和牛客等各种网站刷题，但是遇到一些中等难度或者困难难度的题就束手无策，而我通过刷题来写一些关于中等或者困难的题目的题解，达到一个自己越来越熟悉，而且还可以帮助别人理解的程度。接下来我会用两种策略来解决这道题——数据流中的中位数。</p>
</blockquote>
<a id="more"></a>
<h2 id="数据流中的中位数解法"><a href="#数据流中的中位数解法" class="headerlink" title="数据流中的中位数解法"></a>数据流中的中位数解法</h2><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><blockquote>
<p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。</p>
</blockquote>
<h3 id="Solution（两种解决策略）"><a href="#Solution（两种解决策略）" class="headerlink" title="Solution（两种解决策略）"></a>Solution（两种解决策略）</h3><hr>
<h4 id="解决策略1"><a href="#解决策略1" class="headerlink" title="解决策略1"></a>解决策略1</h4><ol>
<li>建立一个大根堆和一个小根堆，用一个临时变量（count）来统计数据流的个数</li>
<li>当插入的数字个数为奇数时，使小根堆的个数比大根堆多1；当插入的数字个数为偶数时，使大根堆和小根堆的个数一样多</li>
<li>当总的个数为奇数时，中位数就是小根堆的堆顶；当总的个数为偶数时，中位数就是两个堆顶的值相加除以2</li>
</ol>
<h4 id="Code1"><a href="#Code1" class="headerlink" title="Code1"></a>Code1</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/1/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; min = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; max = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o2 - o1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//统计数据流的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//确保小根堆里面的数 &gt; 大根堆里面的数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span> (count % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//奇数的时候，放在小根堆里面</span></span><br><span class="line">            max.offer(num);<span class="comment">//先从大顶堆过滤一遍</span></span><br><span class="line">            min.offer(max.poll());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//偶数的时候，放在大根堆里面</span></span><br><span class="line">            min.offer(num);<span class="comment">//先从小顶堆过滤一遍</span></span><br><span class="line">            max.offer(min.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">GetMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> (min.peek() + max.peek()) / <span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> (<span class="keyword">double</span>) min.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Test1"><a href="#Test1" class="headerlink" title="Test1"></a>Test1</h4><p><img src="/images/数据流中的中位数/1.jpg" alt=""></p>
<hr>
<h4 id="解决策略2"><a href="#解决策略2" class="headerlink" title="解决策略2"></a>解决策略2</h4><ol>
<li>建立一个大根堆和一个小根堆，必须确保满足两点：<ul>
<li>小根堆里面的数 &gt; 大根堆里面的数</li>
<li>大根堆和小根堆的个数差值必须 &lt;= 1</li>
</ul>
</li>
<li>当总的个数为偶数时：<ul>
<li>中位数就是（大根堆堆顶+小根堆堆顶）/ 2.0</li>
</ul>
</li>
<li>当总的个数为奇数时：<ul>
<li>大根堆的个数 &gt; 小根堆的个数，则中位数就是大根堆的堆顶</li>
<li>大根堆的个数 &lt; 小根堆的个数，则中位数就是小根堆的堆顶</li>
</ul>
</li>
</ol>
<h4 id="Code2"><a href="#Code2" class="headerlink" title="Code2"></a>Code2</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/1/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> </span>&#123;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; min = <span class="keyword">null</span>;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; max = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * initialize your data structure here.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MedianFinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//默认从小到大排序</span></span><br><span class="line">        min = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        <span class="comment">//修改比较器，让他从大到小排序</span></span><br><span class="line">        max = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2 - o1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//进来一个树先判断是不是小于大根堆堆顶，是就放大根堆，不是放小根堆</span></span><br><span class="line">        <span class="keyword">if</span> (max.size() == <span class="number">0</span> || max.peek() &gt; num) &#123;</span><br><span class="line">            max.add(num);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            min.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//保证两个堆的个数相差不大于1</span></span><br><span class="line">        <span class="keyword">if</span> (min.size() - max.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            max.add(min.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (max.size() - min.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            min.add(max.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = max.size() + min.size();</span><br><span class="line">        <span class="comment">//判断总的个数是否为偶数</span></span><br><span class="line">        <span class="keyword">if</span> ((count &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (max.peek() + min.peek()) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//总的个数是奇数的情况</span></span><br><span class="line">        <span class="keyword">if</span> (max.size() &gt; min.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> max.peek() / <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min.peek() / <span class="number">1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MedianFinder object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MedianFinder obj = new MedianFinder();</span></span><br><span class="line"><span class="comment"> * obj.addNum(num);</span></span><br><span class="line"><span class="comment"> * double param_2 = obj.findMedian();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h4 id="Test2"><a href="#Test2" class="headerlink" title="Test2"></a>Test2</h4><p><img src="/images/数据流中的中位数/2.jpg" alt=""></p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>今天介绍的是LeetCode上的困难题目——数据流中的中位数。其实可以用排序的方式进行计算，但是计算的话会耗费O(N*logN)的时间复杂度，代价太高。因为我们只关注数据流的中位数，为何要去排序呢。最后通过大根堆和小根堆进行操作就可以计算出中位数，时间代价也就O(logN)，空间复杂度为O(N)。</p>
</blockquote>
<h2 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h2><p><a href="https://leetcode-cn.com/problems/find-median-from-data-stream/submissions/" target="_blank" rel="noopener">LeetCode295.数据流的中位数</a></p>
<p><a href="https://www.nowcoder.com/practice/9be0172896bd43948f8a32fb954e1be1?tpId=13&amp;tqId=11216&amp;tPage=4&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">牛客网的数据流中的中位数</a></p>
]]></content>
      <categories>
        <category>LeetCode&amp;牛客题解</category>
      </categories>
      <tags>
        <tag>困难</tag>
      </tags>
  </entry>
  <entry>
    <title>滑动窗口算法</title>
    <url>/2020/01/01/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="滑动窗口操作"><a href="#滑动窗口操作" class="headerlink" title="滑动窗口操作"></a>滑动窗口操作</h2><ul>
<li>使用左右指针L、R</li>
<li>当一个数进入窗口时，必须从尾部进入，R向右移动一位</li>
<li>当一个数出窗口时，必须从头部出去，L向右移动一位</li>
<li>L、R只能向右移动，且R&gt;L</li>
</ul>
<hr>
<a id="more"></a>
<h2 id="算法原题-滑动窗口的最大值"><a href="#算法原题-滑动窗口的最大值" class="headerlink" title="算法原题(滑动窗口的最大值)"></a>算法原题(滑动窗口的最大值)</h2><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><blockquote>
<p>有一个整型数组arr和一个大小为w的窗口从数组的最左边滑到最右边，窗口每次向右边滑一个位置。<br>例如，数组为[4, 3, 5, 4, 3, 3, 6, 7]，窗口大小为3时：<br>[4 3 5] 4 3 3 6 7 窗口中最大值为5<br>4[3 5 4] 3 3 6 7 窗口中最大值为5<br>4 3[5 4 3] 3 6 7 窗口中最大值为5<br>4 3 5[4 3 3] 6 7 窗口中最大值为4<br>4 3 5 4[3 3 6] 7 窗口中最大值为6<br>4 3 5 4 3[3 6 7] 窗口中最大值为7<br>如果数组长度为n，窗口大小为w，则一共产生n - w + 1个窗口的最大值。<br>请实现一个函数。<br>输入：整型数组arr，窗口大小为w。<br>输出：一个长度为n - w + 1的数组res，res[i]表示每一种窗口状态下的最大值。<br>以本题为例，结果应该返回{ 5,5,5,4,6,7 }。</p>
</blockquote>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><ol>
<li>使用双向链表进行解答（LinkedList）</li>
<li>R的操作<ul>
<li>保证链表从左到右必须是从大到小，即头节点为最大值</li>
<li>每进入一个数，从链表的尾部进入，一但发现新的值比原来的链表的尾部大，先弹出，直到尾部的值大于即将插入的值，然后插入</li>
<li>每次压入的值都是原数组的下标值</li>
</ul>
</li>
<li>L的操作<ul>
<li>每一次进行L的操作时，判断链表的头节点是否过期，过期就直接弹出，否则继续向右移动</li>
<li>举例：当窗口的大小size=3，R=4，链表里面有4个数，大于size了，这个时候i=0就过期了，所以直接弹出头节点</li>
</ul>
</li>
</ol>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> god-jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/1/1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">maxSlidingWindow</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//记录滑动窗口实时的最大值结果</span></span><br><span class="line">            ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">//双向链表，从左到右必须是从大到小的顺序</span></span><br><span class="line">            LinkedList&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> length = num.length;</span><br><span class="line">            <span class="keyword">if</span> (length &lt; size || size == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> list;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">                <span class="comment">//如果链表的尾部小于即将插入的值，则弹出</span></span><br><span class="line">                <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; num[queue.peekLast()] &lt;= num[i]) &#123;</span><br><span class="line">                    queue.pollLast();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//插入只能从尾部插入</span></span><br><span class="line">                queue.addLast(i);</span><br><span class="line">                <span class="comment">//判断链表的头节点是否过期，从头部弹出</span></span><br><span class="line">                <span class="keyword">if</span> (i - queue.peekFirst() == size) &#123;</span><br><span class="line">                    queue.pollFirst();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//当达到滑动窗口的size时，进行收集结果</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt;= size - <span class="number">1</span>) &#123;</span><br><span class="line">                    list.add(num[queue.peekFirst()]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h3><p><img src="/images/滑动窗口最大值/1.jpg" alt=""></p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>以上就是滑动窗口最大值的解法，在leetcode上是属于困难难度的一道题目，但是你掌握了滑动窗口算法，加一些边界的判断就可以轻松拿下</p>
</blockquote>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://www.cnblogs.com/zzw1024/p/11042635.html" target="_blank" rel="noopener">一笔一画一人生</a></li>
<li><a href="https://blog.csdn.net/tangyuan_sibal/article/details/94486570" target="_blank" rel="noopener">经典算法总结</a></li>
</ul>
]]></content>
      <categories>
        <category>LeetCode&amp;牛客题解</category>
      </categories>
      <tags>
        <tag>困难</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客搭建gitalk</title>
    <url>/2019/12/31/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BAgittalk/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote>
<p>2019年1月份的时候就开始搭建了我的第一个博客hexo，部署到了Github Page上，也陆陆续续更新了一些大学时期学习的数据结构和算法内容，然后加了阅读量和访问量，后面发现没有评论系统的博客有点low的感觉，看了很多的评论系统，这里就不一一列举了，最后使用的是Gittalk评论系统。接下来就来介绍hexo集成Gittalk评论系统的全部过程。</p>
</blockquote>
<a id="more"></a>
<h2 id="关于Gitalk"><a href="#关于Gitalk" class="headerlink" title="关于Gitalk"></a>关于Gitalk</h2><blockquote>
<p>Gitalk是一个基于Github Issue和Preact开发的评论插件。使用Github账号登录，界面干净整洁，主要还是Gitalk支持MarkDown语法。（<strong>写过博客的都知道MarkDown好用</strong>）</p>
</blockquote>
<hr>
<h2 id="集成Gitalk"><a href="#集成Gitalk" class="headerlink" title="集成Gitalk"></a>集成Gitalk</h2><h3 id="建立评论仓库"><a href="#建立评论仓库" class="headerlink" title="建立评论仓库"></a>建立评论仓库</h3><ol>
<li>可以在你的个人Github上重新创建一个仓库来专门存放你的评论信息</li>
<li>可以直接使用你的hexo在Github上的仓库地址来存放你的评论信息，信息会放进你仓库里面的issue</li>
</ol>
<h3 id="新建一个OAuth-App"><a href="#新建一个OAuth-App" class="headerlink" title="新建一个OAuth App"></a>新建一个OAuth App</h3><p>​    地址：<a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">https://github.com/settings/applications/new</a></p>
<p><img src="/images/新建OAuth App.png" alt=""></p>
<p><img src="/images/OAuth说明.png" alt=""></p>
<p><strong>填完以上的信息会生成一个Client ID和一个Client Secret，等下的配置会用到这两个信息</strong></p>
<p><img src="/images/生成OAuth.png" alt=""></p>
<h3 id="更改配置文件"><a href="#更改配置文件" class="headerlink" title="更改配置文件"></a>更改配置文件</h3><ol>
<li>新建<code>/layout/_third-party/comments/gitalk.swig</code>文件，并添加内容：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if page.comments &amp;&amp; theme.gitalk.enable %&#125;</span><br><span class="line">  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/gitalk/dist/gitalk.css&quot;&gt;</span><br><span class="line">  &lt;script src=&quot;https://unpkg.com/gitalk/dist/gitalk.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">   &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        var gitalk = new Gitalk(&#123;</span><br><span class="line">          clientID: &apos;&#123;&#123; theme.gitalk.ClientID &#125;&#125;&apos;,</span><br><span class="line">          clientSecret: &apos;&#123;&#123; theme.gitalk.ClientSecret &#125;&#125;&apos;,</span><br><span class="line">          repo: &apos;&#123;&#123; theme.gitalk.repo &#125;&#125;&apos;,</span><br><span class="line">          owner: &apos;&#123;&#123; theme.gitalk.githubID &#125;&#125;&apos;,</span><br><span class="line">          admin: [&apos;&#123;&#123; theme.gitalk.adminUser &#125;&#125;&apos;],</span><br><span class="line">          id: location.pathname,</span><br><span class="line">          distractionFreeMode: &apos;&#123;&#123; theme.gitalk.distractionFreeMode &#125;&#125;&apos;</span><br><span class="line">        &#125;)</span><br><span class="line">        gitalk.render(&apos;gitalk-container&apos;)           </span><br><span class="line">       &lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>修改<code>/layout/_partials/comments.swig</code>，添加内容如下，与前面的<code>elseif</code>同一级别上：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% elseif theme.gitalk.enable %&#125;</span><br><span class="line"> &lt;div id=&quot;gitalk-container&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>修改<code>layout/_third-party/comments/index.swig</code>，在最后一行添加内容：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% include &apos;gitalk.swig&apos; %&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>新建<code>/source/css/_common/components/third-party/gitalk.styl</code>文件，添加内容：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.gt-header a, .gt-comments a, .gt-popup a</span><br><span class="line">  border-bottom: none;</span><br><span class="line">.gt-container .gt-popup .gt-action.is--active:before</span><br><span class="line">  top: 0.7em;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>修改<code>/source/css/_common/components/third-party/third-party.styl</code>，在最后一行上添加内容，引入样式：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@import &quot;gitalk&quot;;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>在主题配置文件<code>next/_config.yml</code>中添加如下内容：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gitalk:</span><br><span class="line">  enable: true</span><br><span class="line">  githubID: github帐号  # 例：god-jiang   </span><br><span class="line">  repo: 仓库名称   # 例：god-jiang.github.io</span><br><span class="line">  ClientID: Client ID</span><br><span class="line">  ClientSecret: Client Secret</span><br><span class="line">  adminUser: github帐号 #指定可初始化评论账户</span><br><span class="line">  distractionFreeMode: true</span><br></pre></td></tr></table></figure>
<p><strong>以上就是next主题中添加Gitalk评论的配置，博客上传到Github上后，打开某一篇文章就可以看到评论了。</strong></p>
<hr>
<h2 id="搭建完成效果"><a href="#搭建完成效果" class="headerlink" title="搭建完成效果"></a>搭建完成效果</h2><p><img src="/images/评论效果图.png" alt=""></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><blockquote>
<p>到这里就已经是大功告成了，当你用github账号登录，第一次加载会比较慢，因为第一次加载会自动在你的仓库下创建相对应的issue。</p>
</blockquote>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://segmentfault.com/a/1190000014085547" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014085547</a></li>
<li><a href="https://blog.csdn.net/qq_35076330/article/details/99968291" target="_blank" rel="noopener">https://blog.csdn.net/qq_35076330/article/details/99968291</a></li>
<li><a href="https://asdfv1929.github.io/2018/01/20/gitalk/" target="_blank" rel="noopener">https://asdfv1929.github.io/2018/01/20/gitalk/</a></li>
</ul>
]]></content>
      <categories>
        <category>hexo优化</category>
      </categories>
  </entry>
  <entry>
    <title>荷兰国旗问题&amp;快排&amp;BFPRT算法</title>
    <url>/2019/12/26/%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97%E9%97%AE%E9%A2%98-%E5%BF%AB%E6%8E%92-BFPRT%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="荷兰国旗问题"><a href="#荷兰国旗问题" class="headerlink" title="荷兰国旗问题"></a>荷兰国旗问题</h2><blockquote>
<p>给定一个数组arr和一个数num，请把小于num的数放在数组的左边，等于num的数放在数组的中间，大于num的数放在数组的右边。要求额外空间复杂度为O(1)，时间复杂度为O(N)</p>
</blockquote>
<a id="more"></a>
<h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3><p>初始化less=-1，more=len(arr)，当前位置为cur=0。</p>
<ul>
<li>如果arr[cur]&lt;num，交换arr[cur]和arr[++less]的数，然后cur++</li>
<li>如果arr[cur]&gt;num，交换arr[cur]和arr[–more]的数，然后cur不变</li>
<li>如果当前位置上的数等于num，less和more均不变，cur++</li>
<li>当cur==more时，停止比较，返回</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NetherLandsFlag</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] partition(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="keyword">int</span> less = L - <span class="number">1</span>;<span class="comment">//小于区域的边界</span></span><br><span class="line">        <span class="keyword">int</span> more = R + <span class="number">1</span>;<span class="comment">//大于区域的边界</span></span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur &lt; more) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[cur] &lt; num) &#123;</span><br><span class="line">                swap(arr, ++less, cur++);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[cur] &gt; num) &#123;</span><br><span class="line">                swap(arr, --more, cur);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] res = partition(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">        System.out.println(Arrays.toString(res));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行截图"><a href="#运行截图" class="headerlink" title="运行截图"></a>运行截图</h3><p><img src="/images/荷兰国旗.png" alt=""></p>
<hr>
<h2 id="稳定算法的定义"><a href="#稳定算法的定义" class="headerlink" title="稳定算法的定义"></a>稳定算法的定义</h2><blockquote>
<p>假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这个排序算法是稳定的；否则称为不稳定的。</p>
</blockquote>
<hr>
<h2 id="BFPRT算法"><a href="#BFPRT算法" class="headerlink" title="BFPRT算法"></a>BFPRT算法</h2><h3 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h3><blockquote>
<p>在一大堆数中求其前k大或前k小的问题，简称TOP-K问题。目前解决TOP-K问题最有效的算法是BFPRT算法，又称为中位数的中位数算法，该算法由Blum、Floyd、Pratt、Rivest、Tarjan提出，最坏时间复杂度为O(N)</p>
</blockquote>
<p>一般第一反应解决TOP-K问题就是对所有数据进行一次排序，然后取其前k即可，但是有两个问题：</p>
<ol>
<li>排序的平均复杂度为O(n*logn)，最坏时间复杂度为O(n^2)，不能保证较好的复杂度</li>
<li>我们只需要前k大的数，而对其余不需要的数也进行了排序，浪费了大量排序时间</li>
</ol>
<p>除了这种方法之外，堆排序也是一个比较好的选择， 可以维护一个大小为k的堆，时间复杂度为O(n*logk)。</p>
<h3 id="算法套路"><a href="#算法套路" class="headerlink" title="算法套路"></a>算法套路</h3><ol>
<li>对整个数组进行分组，每组5个数，不满5个的凑成最后一组</li>
<li>对每个组进行组内排序，组内5个数排序的时间复杂度为O(1)，所以总共有n/5个组，时间复杂度为O(N)</li>
<li>拿出排序后的每个组的中位数，组成一个新的n/5长度的数组</li>
<li>递归调用BFPRT算法，求出最后的中位数num</li>
<li>拿到BFPRT的返回的num，利用荷兰国旗算法把小于的放在数组的左边，等于的放在数组的中间，大于放在数组的右边。</li>
</ol>
<h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BFPRT</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bfprt</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1、对arr数组进行分组，每5个为一组</span></span><br><span class="line">        <span class="comment">//2、进行组内排序，时间复杂度为O(N)，取出每个组的中位数</span></span><br><span class="line">        <span class="comment">//3、每个组的中位数组成一个n/5的数组new_arr</span></span><br><span class="line">        <span class="comment">//4、递归bfprt(new_arr,new_arr.length/2)</span></span><br><span class="line">        <span class="comment">//5、得到一个中位数num</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//利用这个中位数进行荷兰国旗算法，小于在左边，等于在中间，大于在右边</span></span><br><span class="line">    <span class="comment">//如果num==k,则该中位数就是第k大的数</span></span><br><span class="line">    <span class="comment">//如果num&lt;k，则递归求num之后的数组</span></span><br><span class="line">    <span class="comment">//如果num&gt;k，则递归求num之前的数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度证明"><a href="#时间复杂度证明" class="headerlink" title="时间复杂度证明"></a>时间复杂度证明</h3><p><img src="/images/BFPRT时间复杂度.png" alt=""></p>
<hr>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>算法导论</li>
<li>csdn博客</li>
</ol>
<blockquote>
<p>以上讲的是荷兰国旗的解法，可以运用于经典快排算法的partition操作，也可以用于BFPRT算法求解（TOP-K问题）</p>
</blockquote>
]]></content>
      <categories>
        <category>算法积累ing</category>
      </categories>
      <tags>
        <tag>算法进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>有趣的位运算</title>
    <url>/2019/12/20/%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h2 id="位运算概述"><a href="#位运算概述" class="headerlink" title="位运算概述"></a>位运算概述</h2><p>从现代计算机中所有的数据都以二进制的形式存储在设备中。即0、1两种状态，计算机对二进制进行的运算（+、-、*、/）都叫位运算。示例：</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">35</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">47</span>;</span><br><span class="line"><span class="keyword">int</span> c = a + b;</span><br></pre></td></tr></table></figure>
<p>计算a+b的值，在计算机中就是以二进制进行运算的。所以上面我们所给的int变量会在机器内部先转换为二进制在进行相加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">35:  0 0 1 0 0 0 1 1</span><br><span class="line">47:  0 0 1 0 1 1 1 1</span><br><span class="line">————————————————————</span><br><span class="line">82:  0 1 0 1 0 0 1 0</span><br></pre></td></tr></table></figure>
<p><strong>所以，合理的运用位运算更能显著提高代码在机器上的运行效率。</strong></p>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><table>
<thead>
<tr>
<th style="text-align:center">含义</th>
<th style="text-align:center">运算符</th>
<th style="text-align:left">例子</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">左移</td>
<td style="text-align:center">&lt;&lt;</td>
<td style="text-align:left">0011  =&gt;  0110</td>
</tr>
<tr>
<td style="text-align:center">右移</td>
<td style="text-align:center">&gt;&gt;</td>
<td style="text-align:left">0110  =&gt;  0011</td>
</tr>
<tr>
<td style="text-align:center">按位或</td>
<td style="text-align:center">︳</td>
<td style="text-align:left">0011 <br> ——-  =&gt;1011<br>1011</td>
</tr>
<tr>
<td style="text-align:center">按位与</td>
<td style="text-align:center">&amp;</td>
<td style="text-align:left">0011 <br> ——-  =&gt;0011<br>1011</td>
</tr>
<tr>
<td style="text-align:center">按位取反</td>
<td style="text-align:center">~</td>
<td style="text-align:left">0011  =&gt;1100</td>
</tr>
<tr>
<td style="text-align:center">按位异或 (相同为零不同为一)</td>
<td style="text-align:center">^</td>
<td style="text-align:left">0011 <br> ——-  =&gt;1000<br>1011</td>
</tr>
</tbody>
</table>
<h2 id="经典运用"><a href="#经典运用" class="headerlink" title="经典运用"></a>经典运用</h2><h3 id="不用加减乘除做加法"><a href="#不用加减乘除做加法" class="headerlink" title="不用加减乘除做加法"></a>不用加减乘除做加法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//step1:异或查看两个数进行加法操作后的结果</span></span><br><span class="line"><span class="comment">//step2:与运算计算出想对应的位置的进位结果，然后左移一位</span></span><br><span class="line"><span class="comment">//b代表的是两数相加是否有进位，有的话就继续，没有的话就结束得出相加后的答案</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(b != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = a ^ b;<span class="comment">//计算出相对应的位置相加后的结果</span></span><br><span class="line">            b = (a &amp; b) &lt;&lt; <span class="number">1</span>;<span class="comment">//计算出想对应的位置的进位，然后左移一位</span></span><br><span class="line">            a = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个其实可以简写成return (a^b)+((a&amp;b)&lt;&lt;1);</span></span><br></pre></td></tr></table></figure>
<h3 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">0</span>||a == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(a != <span class="number">0</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            a = a &amp; (a-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="不使用第三个变量的情况下交换两个变量的值"><a href="#不使用第三个变量的情况下交换两个变量的值" class="headerlink" title="不使用第三个变量的情况下交换两个变量的值"></a>不使用第三个变量的情况下交换两个变量的值</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原理：运用异或的特性</span></span><br><span class="line"><span class="comment">//A ^ B = C --&gt; C ^ A = B --&gt; C ^ B = A</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    x = x ^ y;</span><br><span class="line">    y = x ^ y;</span><br><span class="line">    x = x ^ y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他运用"><a href="#其他运用" class="headerlink" title="其他运用"></a>其他运用</h2><ul>
<li>判断一个数的奇偶性</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((a &amp; <span class="number">1</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">"a是偶数"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"a是奇数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>两数的中位数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="comment">//通过位运算不会造成溢出</span></span><br><span class="line">	<span class="keyword">int</span> mid = a + (a - b) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>两数的平均数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">average</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (a &amp; b)+((x ^ y) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上就是我今天分享的常见位运算的经典问题，其实位运算的应用远远不止这些，在算法方面适当的使用还是很有帮助的。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法积累ing</category>
      </categories>
      <tags>
        <tag>运算</tag>
      </tags>
  </entry>
  <entry>
    <title>三大高效排序之堆排序(Java实现)</title>
    <url>/2019/12/17/%E4%B8%89%E5%A4%A7%E9%AB%98%E6%95%88%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%A0%86%E6%8E%92%E5%BA%8F-Java%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="堆排序的介绍"><a href="#堆排序的介绍" class="headerlink" title="堆排序的介绍"></a>堆排序的介绍</h2><blockquote>
<p>堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是<strong>完全二叉树</strong>。</p>
</blockquote>
<a id="more"></a>
<ul>
<li>完全二叉树：除了最后一层之外的其他每一层都被完全填充，每一层从左到右的填充数据，不能空缺</li>
<li>大根堆：任意一个节点的值均大于等于它的左右孩子的值，位于堆顶的节点值最大</li>
<li>小根堆：任意一个节点的值均小于等于它的左右孩子的值，位于堆顶的节点值最小</li>
</ul>
<p><strong>本节分享的堆排序以大根堆为例子</strong></p>
<h2 id="堆排序的实现步骤"><a href="#堆排序的实现步骤" class="headerlink" title="堆排序的实现步骤"></a>堆排序的实现步骤</h2><ul>
<li><h3 id="把一个数组调整为大根堆（heapInsert）"><a href="#把一个数组调整为大根堆（heapInsert）" class="headerlink" title="把一个数组调整为大根堆（heapInsert）"></a>把一个数组调整为大根堆（heapInsert）</h3><p>假设当前节点的下标为i，那么它的父亲节点为(i-1)/2，每次heapInsert的时候就把insert进来的节点与它的父亲节点进行比较，比它的父节点大就交换，一直重复调整</p>
</li>
<li><h3 id="每次把堆顶放到最后的节点位置，然后调整整个堆为大根堆（heapify）"><a href="#每次把堆顶放到最后的节点位置，然后调整整个堆为大根堆（heapify）" class="headerlink" title="每次把堆顶放到最后的节点位置，然后调整整个堆为大根堆（heapify）"></a>每次把堆顶放到最后的节点位置，然后调整整个堆为大根堆（heapify）</h3><p>每次把堆顶的节点放到最后，然后堆大小减1，然后调整为大根堆，一直重复，直到大根堆的大小为0为止</p>
</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> size = arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            heapInsert(arr, i);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, <span class="number">0</span>, --size);</span><br><span class="line">        <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            heapify(arr, <span class="number">0</span>, size);</span><br><span class="line">            swap(arr, <span class="number">0</span>, --size);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//heapInsert操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapInsert</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (arr[index] &gt; arr[(index - <span class="number">1</span>) / <span class="number">2</span>]) &#123;</span><br><span class="line">            swap(arr, index, (index - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">            index = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//heapify操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; size) &#123;</span><br><span class="line">            <span class="keyword">int</span> largest = left + <span class="number">1</span> &lt; size &amp;&amp; arr[left + <span class="number">1</span>] &gt; arr[left] ? left + <span class="number">1</span> : left;</span><br><span class="line">            largest = arr[index] &gt; arr[largest] ? index : largest;</span><br><span class="line">            <span class="keyword">if</span> (largest == index)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            swap(arr, index, largest);</span><br><span class="line">            index = largest;</span><br><span class="line">            left = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//交换两数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行截图"><a href="#运行截图" class="headerlink" title="运行截图"></a>运行截图</h2><p><img src="/images/归并运行截图.png" alt=""></p>
<blockquote>
<p>以上就是今天分享的堆排序，主要操作是heapInsert和heapify，时间复杂度为O(N*logN)，空间复杂度为O(1)</p>
</blockquote>
]]></content>
      <categories>
        <category>算法积累ing</category>
      </categories>
      <tags>
        <tag>高效排序</tag>
      </tags>
  </entry>
  <entry>
    <title>三大高效排序之归并排序(Java实现)</title>
    <url>/2019/12/16/%E4%B8%89%E5%A4%A7%E9%AB%98%E6%95%88%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-Java%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="归并排序的介绍"><a href="#归并排序的介绍" class="headerlink" title="归并排序的介绍"></a>归并排序的介绍</h2><p>归并排序(英语：Merge sort，或Mergesort)，是创建在归并操作上的一种有效的排序算法，效率为O(n log n)。1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。</p>
<a id="more"></a>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>是利用递归与分治的技术将数据序列划分为越来越小的半子表，再对半子表排序，最后再用递归方法将排好序的半子表合并成越来越大的有序序列。</p>
<h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><p><strong>将两个有序的数列合并成一个大的有序的序列。通过递归，层层合并，即为归并。</strong></p>
<p><img src="/images/归并排序图示.png" alt=""></p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">//归并排序，时间复杂度为O(N*logN)，空间复杂度为O(N)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//分治的结束条件</span></span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//保证不溢出取start和end的中位数</span></span><br><span class="line">        <span class="keyword">int</span> mid = start + ((end - start) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//递归排序并且合并</span></span><br><span class="line">        MergeSort(arr, start, mid);</span><br><span class="line">        MergeSort(arr, mid + <span class="number">1</span>, end);</span><br><span class="line">        Merge(arr, start, mid, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> mid, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[end - start + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> p1 = start;</span><br><span class="line">        <span class="keyword">int</span> p2 = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= end) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[p1] &gt; arr[p2]) &#123;</span><br><span class="line">                temp[p++] = arr[p2++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[p++] = arr[p1++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= mid) &#123;</span><br><span class="line">            temp[p++] = arr[p1++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p2 &lt;= end) &#123;</span><br><span class="line">            temp[p++] = arr[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">            arr[i + start] = temp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        MergeSort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行截图"><a href="#运行截图" class="headerlink" title="运行截图"></a>运行截图</h2><p><img src="/images/归并运行截图.png" alt=""></p>
<blockquote>
<p>1、以上就是今天分享的归并排序，时间复杂度为O(N*logN)，空间复杂度为O(N)</p>
<p>2、归并排序的额外空间复杂度可以做到O(1)，但是非常难，不需要掌握，有一篇论文”归并排序内部缓存法”可以做到</p>
</blockquote>
]]></content>
      <categories>
        <category>算法积累ing</category>
      </categories>
      <tags>
        <tag>高效排序</tag>
      </tags>
  </entry>
  <entry>
    <title>三大高效排序之快速排序(Java实现)</title>
    <url>/2019/12/16/%E4%B8%89%E5%A4%A7%E9%AB%98%E6%95%88%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-Java%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>快速排序是一种原地排序，只需要一个很小的栈作为辅助空间，空间复杂度为O(logN)，所以适合在数据集比较大且无序的时候使用。</p>
<p><strong>时间复杂度</strong></p>
<p>时间复杂度比较复杂，最好的情况是O(N)，最差的时候是O(N^2)，所以平时说的O(N*logN)为其平均时间复杂度。</p>
<a id="more"></a>
<h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>随机找出一个数，可以随机取，也可以取固定位置，一般是取第一个或最后一个称为基准，然后就是比基准小的在左边，比基准大的放到右边，如何放做，就是和基准进行交换，这样交换完左边都是比基准小的，右边都是比较基准大的，这样就将一个数组分成了两个子数组，然后再按照同样的方法把子数组再分成更小的子数组，直到不能分解为止。</p>
<h2 id="操作实现"><a href="#操作实现" class="headerlink" title="操作实现"></a>操作实现</h2><p>partition方法中</p>
<p>1.选择数组中的第一个元素arr[startIndex]作为轴（pivot）</p>
<p>2.左指针为left，从最左边开始寻找第一个比pivot大的数</p>
<p>3.右指针为right，从最右面的一个元素开始向左寻找第一个小于等于pivot的数值</p>
<p>4.经过2，3两个步骤后，将会出现以下两种情况</p>
<p>​           （1）：left和right没有相遇，此时进行交换，swap（arr,left,right）;</p>
<p>​           （2）：left和right相遇，做swap（arr,startIndex,left），然后返回left</p>
<p>5.partition中返回pivot用于分割数组，下一次用于排序的数组被分割为(startIndex,pivot-1),(pivot+1,endIndex)两段，进行递归操作</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        quickSort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//时间复杂度O(n*logn)，空间复杂度O(n*logn)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (startIndex &lt; endIndex) &#123;</span><br><span class="line">            <span class="comment">//找出基准</span></span><br><span class="line">            <span class="keyword">int</span> partition = partition(arr, startIndex, endIndex);</span><br><span class="line">            <span class="comment">//分成两边递归进行</span></span><br><span class="line">            quickSort(arr, startIndex, partition - <span class="number">1</span>);</span><br><span class="line">            quickSort(arr, partition + <span class="number">1</span>, endIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//找基准</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = arr[startIndex];</span><br><span class="line">        <span class="keyword">int</span> left = startIndex;</span><br><span class="line">        <span class="keyword">int</span> right = endIndex;</span><br><span class="line">        <span class="keyword">while</span> (left != right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt; pivot) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= pivot) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到left比基准大，right比基准小，进行交换</span></span><br><span class="line">            <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">                swap(arr, left, right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一轮完成，让left和right重合的位置和基准交换，返回基准的位置</span></span><br><span class="line">        swap(arr, startIndex, left);</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//两数交换</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行截图"><a href="#运行截图" class="headerlink" title="运行截图"></a>运行截图</h2><p><img src="/images/快排运行截图.png" alt=""></p>
<blockquote>
<p>1、以上就是今天分享的快速排序，时间复杂度为O(N<em>logN)，空间复杂度为O(N\</em>logN)</p>
<p>2、快排是不稳定排序，要想做到稳定性是可以的，但是非常难，不需要掌握，有一篇论文叫”01 stable sort”可以做到</p>
<p>3、有一道题目，是奇数放数组左边，偶数放在数组右边，还要求原始的相对次序不变，额外空间复杂度为O(1)，碰到这个问题，直接可以怼面试官，根本不可能做出来</p>
</blockquote>
]]></content>
      <categories>
        <category>算法积累ing</category>
      </categories>
      <tags>
        <tag>高效排序</tag>
      </tags>
  </entry>
  <entry>
    <title>神级遍历-morris</title>
    <url>/2019/12/15/%E7%A5%9E%E7%BA%A7%E9%81%8D%E5%8E%86-morris/</url>
    <content><![CDATA[<h2 id="morris遍历介绍"><a href="#morris遍历介绍" class="headerlink" title="morris遍历介绍"></a>morris遍历介绍</h2><p>morris遍历是二叉树遍历算法的超强进阶算法，跟递归、非递归（栈实现）的空间复杂度，morris遍历可以将非递归遍历中的空间复杂度降为O(1)。从而实现时间复杂度为O(N)，而空间复杂度为O(1)的精妙算法。</p>
<p>morris遍历利用的是树的叶节点左右孩子为空（树的大量空闲指针），实现空间开销的极限缩减。</p>
<a id="more"></a>
<h2 id="morris遍历的实现原则"><a href="#morris遍历的实现原则" class="headerlink" title="morris遍历的实现原则"></a>morris遍历的实现原则</h2><p><strong>记作当前节点为cur。</strong></p>
<ol>
<li>如果cur无左孩子，cur向右移动（cur=cur.right）</li>
<li>如果cur有左孩子，找到cur左子树上最右的节点，记为mostright<ol>
<li>如果mostright的right指针指向空，让其指向cur，cur向左移动（cur=cur.left）</li>
<li>如果mostright的right指针指向cur，让其指向空，cur向右移动（cur=cur.right）</li>
</ol>
</li>
</ol>
<p>实现以上的原则，即实现了morris遍历。</p>
<h2 id="morris遍历的实质"><a href="#morris遍历的实质" class="headerlink" title="morris遍历的实质"></a>morris遍历的实质</h2><p>建立一种机制，对<strong>于没有左子树的节点只到达一次，对于有左子树的节点会到达两次</strong></p>
<h2 id="morris遍历的实例"><a href="#morris遍历的实例" class="headerlink" title="morris遍历的实例"></a>morris遍历的实例</h2><p>一个树若按层遍历的结构为{1,2,3,4,5,6,7}，即该树为满二叉树，头结点值为1，左右孩子为2,3，叶节点为4,5,6,7</p>
<p>我们按照morris遍历来遍历该树。</p>
<p>1）首先cur来到头结点1，按照morris原则的第二条第一点，它存在左孩子，cur左子树上最右的节点为5，它的right指针指向空，所以让其指向1，cur向左移动到2。</p>
<p>2）2有左孩子，且它左子树最右的节点4指向空，按照morris原则的第二条第一点,让4的right指针指向2，cur向左移动到4</p>
<p>3）4不存在左孩子，按照morris原则的第一条，cur向右移动，在第二步中，4的right指针已经指向了2，所以cur会回到2</p>
<p>4）重新回到2，有左孩子，它左子树最右的节点为4，但是在第二步中，4的right指针已经指向了2，不为空。所以按照morris原则的第二条第二点，2向右移动到5，同时4的right指针重新指向空</p>
<p>5）5不存在左孩子，按照morris原则的第一条，cur向右移动，在第一步中，5的right指针已经指向了1，所以cur会回到1</p>
<p>6）cur回到1，回到头结点，左子树遍历完成，1有左孩子，左子树上最右的节点为5，它的right指针指向1，按照morris原则的第二条第二点，1向右移动到3，同时5的right指针重新指回空</p>
<p>……</p>
<p>当到达最后一个节点7时，按照流程下来，此时7无左右孩子，遍历结束。</p>
<h2 id="morris代码实现（前序、中序、后序遍历）"><a href="#morris代码实现（前序、中序、后序遍历）" class="headerlink" title="morris代码实现（前序、中序、后序遍历）"></a>morris代码实现（前序、中序、后序遍历）</h2><p>前序遍历：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">morrisPre</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node cur = head;</span><br><span class="line">    Node mostRight = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        mostRight = cur.left;</span><br><span class="line">        <span class="keyword">if</span>(mostRight != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span> (mostRight.right !=<span class="keyword">null</span> &amp;&amp; mostRight.right != cur)&#123;</span><br><span class="line">                mostRight = mostRight.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(mostRight.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                mostRight.right = cur;</span><br><span class="line">                System.out.print(cur.value+<span class="string">" "</span>);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                mostRight.right = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.print(cur.value + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>中序遍历：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">morrisIn</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node cur = head;</span><br><span class="line">    Node mostRight = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        mostRight = cur.left;</span><br><span class="line">        <span class="keyword">if</span>(mostRight != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span> (mostRight.right !=<span class="keyword">null</span> &amp;&amp; mostRight.right != cur)&#123;</span><br><span class="line">                mostRight = mostRight.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(mostRight.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                mostRight.right = cur;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                mostRight.right = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(cur.value+<span class="string">" "</span>);</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后续遍历（复杂一点）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">morrisPos</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       Node cur = head;</span><br><span class="line">       Node mostRight = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">           mostRight = cur.left;</span><br><span class="line">           <span class="keyword">if</span>(mostRight != <span class="keyword">null</span>)&#123;</span><br><span class="line">               <span class="keyword">while</span> (mostRight.right !=<span class="keyword">null</span> &amp;&amp; mostRight.right != cur)&#123;</span><br><span class="line">                   mostRight = mostRight.right;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>(mostRight.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                   mostRight.right = cur;</span><br><span class="line">                   cur = cur.left;</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                   mostRight.right = <span class="keyword">null</span>;</span><br><span class="line">                   printEdge(cur.left);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           cur = cur.right;</span><br><span class="line">       &#125;</span><br><span class="line">       printEdge(head);</span><br><span class="line">       System.out.println();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printEdge</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">       Node tail =reverseEdge(node);</span><br><span class="line">       Node cur = tail;</span><br><span class="line">       <span class="keyword">while</span> (cur != <span class="keyword">null</span> )&#123;</span><br><span class="line">           System.out.print(cur.value+<span class="string">" "</span>);</span><br><span class="line">           cur =cur.right;</span><br><span class="line">       &#125;</span><br><span class="line">       reverseEdge(tail);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reverseEdge</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">       Node pre = <span class="keyword">null</span>;</span><br><span class="line">       Node next = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">while</span> (node != <span class="keyword">null</span>)&#123;</span><br><span class="line">           next = node.right;</span><br><span class="line">           node.right = pre;</span><br><span class="line">           pre = node;</span><br><span class="line">           node = next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> pre;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上就是我今天所要分享的morris遍历，神级算法，时间复杂度为O(N)，空间复杂度为O(1)。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法积累ing</category>
      </categories>
      <tags>
        <tag>算法进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>链表反转解法</title>
    <url>/2019/04/20/%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC%E8%A7%A3%E6%B3%95/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote>
<p>当初大二学习数据结构的时候，有许多数据结构我都学得有点懵，总感觉没有一个系统的概括和总结，导致我的链表学得一般。后来班上有个同学微信跟我说叫我关注”程序员小灰”这个公众号，说他讲得很生动形象，最后关注了一波，看了他里面一道经典的面试题——链表反转。接下来就来讲解链表反转的解法。</p>
</blockquote>
<a id="more"></a>
<h2 id="链表反转图示"><a href="#链表反转图示" class="headerlink" title="链表反转图示"></a>链表反转图示</h2><p><img src="/images/链表反转解法/1.png" alt=""></p>
<h2 id="解法说明"><a href="#解法说明" class="headerlink" title="解法说明"></a>解法说明</h2><ol>
<li><p>链表反转的本质其实就是把每一个节点原本指向下一个节点的next的指针，反转过来指向它的前置节点。</p>
<p><img src="/images/链表反转解法/2.png" alt=""></p>
</li>
<li><p>进行链表反转的时候，需要同时知道三个节点才能进行反转。</p>
<p><img src="/images/链表反转解法/3.png" alt=""></p>
</li>
</ol>
<h2 id="解法步骤"><a href="#解法步骤" class="headerlink" title="解法步骤"></a>解法步骤</h2><ol>
<li><p>以p2节点为根，把p2节点原本指向p3的next指针反转，指向p1</p>
<p><img src="/images/链表反转解法/4.png" alt=""></p>
</li>
<li><p>三个临时节点引用p1，p2，p3分别向后移动一位</p>
<p><img src="/images/链表反转解法/5.png" alt=""></p>
</li>
<li><p>重复”1”的工作，以p2节点为根，把p2节点原本指向p3的next指针反转，指向p1</p>
<p><img src="/images/链表反转解法/6.png" alt=""></p>
</li>
<li><p>重复”2”的工作，三个临时节点引用p1，p2，p3分别向后移动一位</p>
<p><img src="/images/链表反转解法/7.png" alt=""></p>
</li>
<li><p>继续重复以上的工作，一直到p2为空为止</p>
<p><img src="/images/链表反转解法/8.png" alt=""></p>
</li>
<li><p>最后，把head节点的next指向空，成为反转链表的尾节点。并把p1赋值给head，让p1所在节点成为反转链表的头节点</p>
<p><img src="/images/链表反转解法/9.png" alt=""></p>
</li>
</ol>
<p>​    <strong>听完上面的讲解，估计有点懵逼，来看看代码的实现，再结合上面的图示步骤，相信你就会理解链表反转了</strong></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    ListNode(<span class="keyword">int</span> val)&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode p1 = head;</span><br><span class="line">        ListNode p2 = head.next;</span><br><span class="line">        ListNode p3 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(p2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            p3 = p2.next;</span><br><span class="line">            p2.next = p1;</span><br><span class="line">            p1 = p2;</span><br><span class="line">            p2 = p3;</span><br><span class="line">        &#125;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        head = p1;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>对于链表的反转就介绍到这里，感谢大家的支持。嘻嘻嘻~~~</p>
</blockquote>
<h2 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h2><ul>
<li>程序员小灰公众号</li>
<li><a href="https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=13&amp;tqId=11168&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">牛客网原题链接</a></li>
</ul>
]]></content>
      <categories>
        <category>LeetCode&amp;牛客题解</category>
      </categories>
      <tags>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title>全排列算法</title>
    <url>/2019/03/02/%E5%85%A8%E6%8E%92%E5%88%97%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="全排列算法详细解析"><a href="#全排列算法详细解析" class="headerlink" title="全排列算法详细解析"></a>全排列算法详细解析</h2><p>全排列在笔试面试和ACM竞赛中很热门，因为它难度适中，既可以考察递归实现，又能进一步考察非递归的实现，便于区分出考生的水平。（<strong>自己的心得：回溯是思想，深搜是本质，递归是实现</strong>）</p>
<a id="more"></a>
<h4 id="一、全排列的递归实现（以下所有代码以java为主）"><a href="#一、全排列的递归实现（以下所有代码以java为主）" class="headerlink" title="一、全排列的递归实现（以下所有代码以java为主）"></a>一、全排列的递归实现（以下所有代码以java为主）</h4><p>以abcd为例，共有24种排列方式，abcd,abdc,acbd,acdb…….，因此可以知道——<em>全排列就是从第一个数字起每个数分别与它后面的数字交换。</em>递归的代码如下：</p>
<pre><code>public class Main{
    public static int count=0;
    public static void swap(char[] a,int i,int j){
        char tmp = a[i];
        a[i]=a[j];
        a[j]=tmp;
}

    public static void perm(char[] a,int st,int len){
        if(st==len-1){
            for(int i=0;i&lt;len;i++){
                System.out.print(a[i]);
            }
            System.out.println(&quot;&quot;);
            count++;
        }else{
            for(int i=st;i&lt;len;i++){
                swap(a,st,i);
                perm(a,st+1,len);
                swap(a,st,i);
            }
        }
    }
    public static void main(String[] args) {
        char[] a=&quot;abcd&quot;.toCharArray();
        perm(a,0,4);
        System.out.println(&quot;总共有：&quot;+count+&quot;种&quot;);
    }
}
</code></pre><h6 id="运行结果如下："><a href="#运行结果如下：" class="headerlink" title="运行结果如下："></a>运行结果如下：</h6><p><img src="/images/perm.jpg" alt="全排列的结果"></p>
<h3 id="二、以蓝桥杯里面的一道例题来使用全排列解决"><a href="#二、以蓝桥杯里面的一道例题来使用全排列解决" class="headerlink" title="二、以蓝桥杯里面的一道例题来使用全排列解决"></a>二、以蓝桥杯里面的一道例题来使用全排列解决</h3><p><strong>题目：</strong><br><em>凑算式:  A+B/C+DEF/GHI = 10<br>这个算式中A~I代表1~9的数字，不同的字母代表不同的数字。比如： 6+8/3+952/714就是一种解法, 5+3/1+972/486是另一种解法。这个算式一共有多少种解法？</em></p>
<p>代码如下：</p>
<pre><code>public class Main {
    static int count=0;
    public static void swap(char[] a,int i,int j){
        char temp=a[i];
        a[i]=a[j];
        a[j]=temp;
    }
    public static boolean check(char[] a){
        double[] num = new double[9];
        for(int i=0;i&lt;9;i++){
            num[i]=a[i]-&apos;0&apos;;
        }
        if(num[0]+num[1]*1.0/num[2]+(num[3]*100+num[4]*10+num[5])*1.0/(num[6]*100+num[7]*10+num[8])==10){
            return true;
        }
        return false;
    }

    public static void perm(char[] a,int st,int length){
        if(st==length-1){
            if(check(a)){
                count++;
            }
        }else{
            for(int i=st;i&lt;length;i++){
                swap(a,st,i);
                perm(a,st+1,length);
                swap(a,st,i);
            }
        }
    }
    public static void main(String[] args) {    
        char[] a=&quot;123456789&quot;.toCharArray();
        perm(a,0,9);
        System.out.println(&quot;共有&quot;+count+&quot;种解法&quot;);
    }
}
</code></pre><h6 id="运行结果如下：-1"><a href="#运行结果如下：-1" class="headerlink" title="运行结果如下："></a>运行结果如下：</h6><p><img src="/images/perm01.jpg" alt=""></p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p><strong>全排列就是从第一个数字起每个数分别与它后面的数字交换</strong></p>
]]></content>
      <categories>
        <category>算法积累ing</category>
      </categories>
      <tags>
        <tag>算法基础</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis开发流程</title>
    <url>/2019/02/16/MyBatis%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>通过这几天的学习，大概懂得了mybatis的开发流程还有基础的CURD操作，就想着把它写下来，接下来会写下mybatis框架的开发步骤，举例代码就用insert，其他read、update、delete大致跟insert一样。<br><a id="more"></a></p>
<h2 id="mybatis开发步骤"><a href="#mybatis开发步骤" class="headerlink" title="mybatis开发步骤"></a>mybatis开发步骤</h2><h4 id="一、导入相对应的jar包"><a href="#一、导入相对应的jar包" class="headerlink" title="一、导入相对应的jar包"></a>一、导入相对应的jar包</h4><p>如图所示：<br><img src="/images/myBatisJar.jpg" alt="jar"></p>
<h4 id="二、写主配置文件myBatis-config-xml"><a href="#二、写主配置文件myBatis-config-xml" class="headerlink" title="二、写主配置文件myBatis-config.xml"></a>二、写主配置文件myBatis-config.xml</h4><p><code>&lt;environments default=&quot;development&quot;&gt;
        &lt;environment id=&quot;development&quot;&gt;
            &lt;transactionManager type=&quot;JDBC&quot; /&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;
                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;amp;characterEncoding=UTF-8&quot; /&gt;
                &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;
                &lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;
    &lt;mappers&gt;
    &lt;mapper resource=&quot;god/jiang/entity/DeptMapper.xml&quot;/&gt;
&lt;/mappers&gt;</code></p>
<h4 id="三、写映射文件"><a href="#三、写映射文件" class="headerlink" title="三、写映射文件"></a>三、写映射文件</h4><p>例如创建一个xxx.java的javebean,同时就要创建一个xxx.Mapper.xml来映射数据库的字段，还有要先写CURD的SQL语句，如图所示：<br><img src="/images/myBatisMapper.jpg" alt="mapper"></p>
<h4 id="四、写Dao的接口和实现（以insert为例子）"><a href="#四、写Dao的接口和实现（以insert为例子）" class="headerlink" title="四、写Dao的接口和实现（以insert为例子）"></a>四、写Dao的接口和实现（以insert为例子）</h4><p>1.先用Resources.getResourcesAsReader(myBatis-config.xml)读取主配置文件<br>2.构建sessionFactory<br>3.创建session(mybatis默认开启事务)<br>4.业务逻辑（insert为例子）<br>5.提交事务<br>代码如下：<br><img src="/images/myBatisSave.jpg" alt="insert"></p>
<h4 id="五、test（省略）"><a href="#五、test（省略）" class="headerlink" title="五、test（省略）"></a>五、test（省略）</h4><p>…<br>…<br>…</p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><blockquote>
<p>MyBatis是一款优秀的持久层框架，它支持定制化SQL、存储过程以及高级映射。MyBatis避免了几乎所有的JDBC代码和手动设置参数以及获取结果集。MyBatis可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录。<br>以上就是我对MyBatis的开发流程的理解和CURD示例。</p>
</blockquote>
]]></content>
      <categories>
        <category>SSM学习ing</category>
      </categories>
      <tags>
        <tag>学习经历</tag>
      </tags>
  </entry>
  <entry>
    <title>学习mybatis的记录初体验</title>
    <url>/2019/01/22/%E5%AD%A6%E4%B9%A0mybatis%E7%9A%84%E8%AE%B0%E5%BD%9501/</url>
    <content><![CDATA[<p>今天刚开始学习mybatis，听了mybatis和hibernate之间的比较，大致是这样的：<br>一、灵活性：mybatis可以直接使用SQL语句，灵活性较高<br>二、效率性：mybatis直接用SQL，效率高（hibernate使用hql语句，底层需要转换成<br>SQL来操作数据库，时间上有消耗）</p>
<a id="more"></a>
<p>三、移植性：hibernate更好，因为hibernate用配置文件关联数据库，用hql语句与<br>数据库无直接关系</p>
<p>听完课学了大概一个小时，弄懂了mybatis开发的大致流程，但是轮到我自己动手操<br>作的时候，一直保空指针异常，初学者总是遇到这个问题，弄了我将近2个多小时，<br>最后才知道原来要使用SQL语句的时候，SqlSession.insert(1,2)传的参数弄错了，<br>第一个参数要传的是mapper.xml的命名空间加定义的id来定位，第二个参数就是你<br>要传的值。</p>
<p>总的来说，我还是觉得学习编程，理论固然重要，但是动手能力也很重要，编码能力<br>也很重要，这就是我学习mybatis的初次体验。</p>
]]></content>
      <categories>
        <category>SSM学习ing</category>
      </categories>
      <tags>
        <tag>学习经历</tag>
      </tags>
  </entry>
  <entry>
    <title>god_jiang的第一篇博客</title>
    <url>/2019/01/17/god-jiang-title/</url>
    <content><![CDATA[<p>这是我得第一个博客网站，也不知道说些啥，就是假期大家好好学习，不要过度玩电脑游戏，偶尔放松一下没啥，但是关键得ssm框架还是得先学好，下学期好找实习。。。。</p>
]]></content>
  </entry>
</search>
