---
title: Java程序员校招面试——计算机网络
copyright: true
date: 2020-07-10 23:48:13
tags: 计算机网络
categories: 校招面试总结
---

## 前言

> 现在是2020年7月中旬，应该很多互联网大厂开始了他们的秋招提前批吧。然而很多大四学生要参加提前批的话需要有扎实的数据结构基础和刷算法题的能力之外，到了面试环节，面试官比较喜欢考察计算机网络和操作系统的原理，今天就让我来分享我当初校招遇到的常见计算机网络的面试题。

<!--more-->

## 常见的面试题

**1、讲一下TCP的三次握手过程？**

![img](https://picb.zhimg.com/80/v2-6d5c8fd979f77dbd6ec54b2d51f90721_720w.jpg)

第一次握手：建立连接时，客户端发送syn包（syn=x）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）；

第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；

第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。

**2、讲一下TCP的四次挥手？**

![img](https://pic4.zhimg.com/80/v2-0cc92c48a269adf565e57e7ecfc1b67d_720w.jpg)

1）客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。

2）服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。

3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。

4）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。

5）客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。

6）服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。

**3、为什么不能用两次握手进行连接？**

3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。

现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。

**4、为什么四次挥手的TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？**

虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。

**5、TCP协议如何来保证传输的可靠性？**

数据包校验：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据端超时后会重发数据；

对失序数据包重排序：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层；

丢弃重复数据：对于重复数据，能够丢弃重复数据；

应答机制：当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；

超时重发：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；

流量控制：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。

**6、TCP的流量控制和拥塞控制。（主要讲拥塞控制）**

TCP协议有两个比较重要的控制算法，一个是**流量控制**，另一个是**拥塞控制**。

TCP协议通过滑动窗口来进行流量控制，它是控制发送方的发送速度从而使接收者来得及接收并处理。而拥塞控制是作用于网络，它是防止过多的包被发送到网络中，避免出现网络负载过大、网络拥塞的情况。

拥塞控制主要有四个算法，分别为**慢启动**、**拥塞避免**、**快重传**和**快恢复算法**。

![img](https://pic4.zhimg.com/80/v2-8bc172528b2b57de2677d6260d8b7de3_720w.jpg)

**慢开始：**当发送方每收到一个ACK，拥塞窗口cwnd的大小就会翻倍，就是2的n次幂递增。可以看到指数级增长。一般遵循以下判定：

- cwnd < ssthresh，继续使用慢开始算法；
- cwnd < ssthresh，停止使用慢开始算法，改用拥塞避免算法；
- cwnd = ssthresh，即可使用慢开始算法，也可以使用拥塞避免算法。

**拥塞避免：**当拥塞窗口cwnd超过慢启动门限ssthresh就会进入拥塞避免算法。

- 加法增大：每经过一个往返时间RTT（Round-TripTime），拥塞窗口+1，让拥塞窗口缓慢增大，按照线性规律增长。
- 乘法减小：当出现网络拥塞，比如丢包时，将慢开始门限（ssthresh）设为原先的一半，然后将cwnd设为1，执行慢开始算法（较低的起点，指数级增长）。

**快重传和快恢复：**为了减少因为拥塞导致的数据包丢失带来的重传时间，快重传的机制是：

- 接收方如果一个包丢失，则对后续的包继续发送针对该包的重传请求；
- 一旦发送方接收到三个一样的确认，就知道该包之后出现了错误，立刻重传该包；
- 此时发送方开始执行“快恢复”算法；
- 慢开始门限减半；
- cwnd设为慢开始门限减半后的数量；
- 执行拥塞避免算法（高起点，线性增长）；

**7、简述计算机网络中的七层模型。**

![img](https://pic1.zhimg.com/80/v2-cb4fc1b384f9b2b14fee4db42360fcfd_720w.jpg)

物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）

数据链路层：将比特组装成帧和点到点的传递（帧Frame）

网络层：负责数据包从源到宿的传递和网际互连（包PackeT）

传输层：提供端到端的可靠报文传递和错误恢复（段Segment）

会话层：建立、管理和终止会话（会话协议数据单元SPDU）

表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）

应用层：允许访问OSI环境的手段（应用协议数据单元APDU）

**8、网络层的ARP协议工作原理。**

网络层的ARP协议完成了IP地址与物理地址的映射。首先，每台主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址的对应关系。当源主机需要将一个数据包要发送到目的主机时，会首先检查自己ARP列表中是否存在该IP地址对应的MAC地址：如果有，就直接将数据包发送到这个MAC地址；如果没有，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的MAC地址。此ARP请求数据包里包括源主机的IP地址、硬件地址、以及目的主机的IP地址。网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个ARP响应数据包，告诉对方自己是它需要查找的MAC地址；源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。

**9、简单介绍一下HTTP的长连接和短连接。**

HTTP的长连接和短连接本质上是TCP长连接和短连接。HTTP属于应用层协议。

**短连接:**

浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。

**长连接:**

当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的 TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接要客户端和服务端都支持长连接。

**10、TCP和UDP有什么区别？**

（1）TCP提供的是面向连接的、可靠的数据流传输；UDP提供的是非面向连接的、不可靠的数据流传输。

（2）TCP提供可靠的服务，通过TCP连接传送的数据，无差错、不丢失，不重复，按序到达；UDP尽最大努力交付，即不保证可靠交付。

（3）TCP面向字节流；UDP面向报文。

（4）TCP连接只能是点到点的；UDP支持一对一、一对多、多对一和多对多的交互通信。

（5）TCP首部开销20字节；UDP的首部开销小，只有8个字节。

（6）TCP的逻辑通信信道是全双工的可靠信道；UDP的逻辑通信信道是不可靠信道。

**11、常见的HTTP状态码有哪些？**

**2开头 （请求成功）表示成功处理了请求的状态代码。**

200 （成功） 服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。 201 （已创建） 请求成功并且服务器创建了新的资源。 202 （已接受） 服务器已接受请求，但尚未处理。 203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。 204 （无内容） 服务器成功处理了请求，但没有返回任何内容。 205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。 206 （部分内容） 服务器成功处理了部分 GET 请求。

**3开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。**

300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。 302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。 304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。 307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。

**4开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。**

400 （错误请求） 服务器不理解请求的语法。 401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 403 （禁止） 服务器拒绝请求。 404 （未找到） 服务器找不到请求的网页。 405 （方法禁用） 禁用请求中指定的方法。 406 （不接受） 无法使用请求的内容特性响应请求的网页。 407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。 408 （请求超时） 服务器等候请求时发生超时。 409 （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。 411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。 412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。 413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。 415 （不支持的媒体类型） 请求的格式不受请求页面的支持。 416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。 417 （未满足期望值） 服务器未满足"期望"请求标头字段的要求。

**5开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。**

500 （服务器内部错误） 服务器遇到错误，无法完成请求。 501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。 502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。 503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。 504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。 505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。

**12、Post和Get有什么区别？**

GET主要用于从服务器查询数据，POST用于向服务器提交数据；

GET通过URL传递数据，POST通过http请求体传递数据；

GET传输数据量有限制，不能大于2kb，POST传递的数据量较大，一般大量的数据提交都是通过POST方式；

GET安全性较低，容易在URL中暴漏数据，POST安全性较高。

**13、在浏览器中输入[http://www.baidu.com](https://link.zhihu.com/?target=http%3A//www.baidu.com)后执行的全部过程。**

该答案有多种版本，建议自己百度选择一个适合自己的版本记下来就可以了。

**14、cookie 和session 有什么区别？**

cookie数据存放在客户的浏览器上，session数据放在服务器上；

cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当使用session；

session会在一定时间内保存在服务器上。当访问增多，会比较占用服务器的性能考虑到减轻服务器性能方面，应当使用COOKIE；

单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie；

建议：将登陆信息等重要信息存放为SESSION；其他信息如果需要保留，可以放在COOKIE中。

**15、HTTP和HTTPS的区别。**

- **工作层：**在OSI网络模型中，HTTP工作于**应用层**，而HTTPS工作在**传输层**。
- **连接端口：**HTTP标准端口为80，而HTTPS标准端口为443。
- **传输方式：**HTTP是超文本传输协议，信息是明文传输，而HTTPS是SSL加密传输协议。
- **工作耗时：**HTTP耗时=TCP握手，而HTTPS耗时=TCP握手+SSL握手。
- **显示形式：**HTTP的URL以http://开头，而HTTPS的URL以https://开头。
- **费用：**HTTP无需费用，而HTTPS需要到CA申请证书，一般免费证书较少，需要一定费用。
- **安全性：**HTTP的连接简单，是无状态的；而HTTPS是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP协议安全。

**16、列举几种常见的协议，并简述他们的作用。**

ICMP协议：因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。

TFTP协议：是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。

HTTP协议：超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。

DHCP协议：动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段。

NAT协议：网络地址转换属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术，

DHCP协议：一个局域网的网络协议，使用UDP协议工作，用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。

## 总结

> 基本上校招常见的一些计算机网络的面试题就是这些了，但是有一些大厂会问得比较深入，比如DDOS攻击，网站的安全性问题怎么解决，TCP粘包拆包问题等等。这些常见面试题可以熟记，但是也要多看看相关的书籍和博客巩固自己的基础，才能让自己在面试中立于不败之地。

**PS：大概常见的面试题我就记住这么多，以后有别的我再补充。**

**（version1.1）更新于2020年7月11日上午11点13分。**